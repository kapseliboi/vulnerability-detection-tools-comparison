import { EntityManager, getManager } from 'typeorm';
import { DetectionTool } from '../../entities/detectionTool';
import { AgreementsBetweenTools, calculateAgreement, calculateMedianAgreement, calculateTotalAgreement, compareFnByProperty, PerProjectResults } from '../../util';
import { assert } from 'console';
import { stringify } from 'csv/sync';
import sanitize from 'sanitize-filename';
import fs from 'fs';
import { Vulnerability } from '../../entities/vulnerability';

const UNIQUE_IDENTIFIERS: (keyof Vulnerability)[] = ['cve', 'snykId', 'ghsaId', 'npmId', 'ossIndexId', 'whiteSourceId'];

export async function analyzeVulnerabilityAgreement() {
    const entityManager = getManager();
    const tools = await getData(entityManager);
    if (!tools.length) {
        console.log('Nothing to analyze');
        return;
    }
    console.log('Collecting agreement data');
    const results = await collectAgreement(tools, entityManager);
    console.log('Calculating agreement and writing it to CSV');
    writeResultsToFiles(results)
}

function getData(entityManager: EntityManager) {
    console.log('Getting all dependency data from database');
    return entityManager.find(DetectionTool, {
        relations: [
            'toolExecutions',
            'toolExecutions.project',
            'toolExecutions.tool',
        ],
        order: {
            id: 'ASC',
        },
    });
}

async function collectAgreement(tools: DetectionTool[], entityManager: EntityManager) {
    // Sort projects
    for (const tool of tools) {
        tool.toolExecutions.sort(compareFnByProperty('project.name'));
    }
    // Verify that projects are in comparable order
    const length = tools[0].toolExecutions.length;
    assert(tools.every((tool) => tool.toolExecutions.length === length));
    for (let i = 0; i < length; ++i) {
        const name = tools[0].toolExecutions[i].project.name;
        assert(tools.every((tool) => tool.toolExecutions[i].project.name === name));
    }
    const perProjectResults: PerProjectResults = {};
    for (const tool of tools) {
        for (const toolExec of tool.toolExecutions) {
            const projectName = toolExec.project.name;
            const uniqueIdentifierOrComparison = UNIQUE_IDENTIFIERS.map((id, i) => `${i !== 0 ? ' or ' : '' }v."${id}" = v2."${id}"`);
            const res: { id: number; matching?: number; toolName: string }[] = await entityManager.createQueryBuilder(Vulnerability, 'v')
                .select('v.id, v2.id as matching, dt2.name as "toolName"')
                .leftJoin(
                    'tool_execution',
                    'te',
                    'v."toolExecutionId" = te.id',
                )
                .leftJoin(
                    'tool_execution',
                    'te2',
                    'te2."projectName" = te."projectName" and te2.id != te.id'
                )
                .leftJoin(
                    'vulnerability',
                    'v2',
                    `(${uniqueIdentifierOrComparison}) and v2."toolExecutionId" = te2.id`,
                )
                .leftJoin(
                    'detection_tool',
                    'dt2',
                    'dt2.id = te2."toolId"',
                )
                .where('v."toolExecutionId" = :teId and te."projectName" = :projectName', { teId: toolExec.id, projectName })
                .orderBy('te2."toolId"')
                .addOrderBy('v.id')
                .execute();

            if (!perProjectResults[projectName]) {
                perProjectResults[projectName] = {};
            }
            const projectResults = perProjectResults[projectName];
            if (!perProjectResults[toolExec.tool.name]) {
                projectResults[toolExec.tool.name] = {};
            }
            const toolResults = projectResults[toolExec.tool.name];
            let total = 0;
            let agreed = 0;
            let toolName = res[0]?.toolName;
            if (!toolName) {
                console.log(`No vulnerabilities for project ${projectName} with tool ${toolExec.tool.name}`);
                for (const t of tools) {
                    if (t.id != tool.id) {
                        toolResults[t.name] = {
                            agreed: 0,
                            total: 0,
                        };
                    }
                }
                continue;
            }
            console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
            for (const row of res) {
                const newToolName = row.toolName;
                if (newToolName !== toolName) {
                    toolResults[toolName] = {
                        agreed,
                        total,
                    };
                    total = 0;
                    agreed = 0;
                    toolName = newToolName;
                    console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
                }
                ++total;
                if (row.matching !== null && row.matching !== undefined) {
                    ++agreed;
                }
            }
            toolResults[toolName] = {
                agreed,
                total,
            };
        }
    }
    return perProjectResults;
}

const ANALYZE_VULNERABILITY_FILEPATH_PREFIX = 'analyze/vulnerability/';

function writeResultsToFiles(results: PerProjectResults) {
    const dateString = (new Date()).getTime();
    const projects = Object.keys(results);
    const agreementBetweenTools: AgreementsBetweenTools = {};
    const projectPath = `${ANALYZE_VULNERABILITY_FILEPATH_PREFIX}project`;
    if (!fs.existsSync(projectPath)) {
        fs.mkdirSync(projectPath, { recursive: true });
    }
    for (const project of projects) {
        const projectFilePath = `${projectPath}/${sanitize(project)}-${dateString}.csv`;
        const projectWriteStream = fs.createWriteStream(projectFilePath);
        const projectResultsByTool = results[project];
        const projectTools = Object.keys(projectResultsByTool);
        const projectRows = [];
        const projectHeaderRow = ['', ...projectTools];
        projectRows.push(projectHeaderRow);
        for (let i = 0; i < projectTools.length; ++i) {
            const tool = projectTools[i];
            const dataRow: (string|number)[] = [tool];
            dataRow[i+1] = 1;
            if (!agreementBetweenTools[tool]) {
                agreementBetweenTools[tool] = {};
            }
            const toolAgreement = agreementBetweenTools[tool];
            const toolRes = projectResultsByTool[tool];
            const comparedTools = Object.keys(toolRes);
            for (const comparedTool of comparedTools) {
                if (!toolAgreement[comparedTool]) {
                    toolAgreement[comparedTool] = [];
                }
                const comparedAgreement = toolAgreement[comparedTool];
                const comparedToolRes = toolRes[comparedTool];
                comparedAgreement.push(comparedToolRes);
                const resultIndex = projectTools.indexOf(comparedTool) + 1;
                const agreement = calculateAgreement(comparedToolRes);
                dataRow[resultIndex] = agreement;
            }
            projectRows.push(dataRow);
        }
        projectWriteStream.write(stringify(projectRows));
        projectWriteStream.close();
    }
    const tools = Object.keys(agreementBetweenTools);
    const filePath = `${ANALYZE_VULNERABILITY_FILEPATH_PREFIX}total-${dateString}.csv`;
    const writeStream = fs.createWriteStream(filePath);
    const rows = [];
    const headerRow = ['', ...tools];
    rows.push(headerRow);
    for (let i = 0; i < tools.length; ++i) {
        const toolName = tools[i];
        const dataRow: (string|number)[] = [toolName];
        dataRow[i + 1] = '1 (1)';
        const toolData = agreementBetweenTools[toolName];
        const comparedToolNames = Object.keys(toolData);
        for (const comparedTool of comparedToolNames) {
            const resultIndex = tools.indexOf(comparedTool) + 1;
            const totalAgreement = calculateTotalAgreement(toolData[comparedTool]);
            const medianAgreement = calculateMedianAgreement(toolData[comparedTool]);
            dataRow[resultIndex] = `${totalAgreement} (${medianAgreement})`;
        }
        rows.push(dataRow);
    }
    writeStream.write(stringify(rows));
    writeStream.close();
}
