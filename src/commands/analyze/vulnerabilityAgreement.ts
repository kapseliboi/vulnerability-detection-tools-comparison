import { EntityManager, getManager } from 'typeorm';
import { DetectionTool } from '../../entities/detectionTool';
import { compareFnByProperty, PerProjectResults, writeResultsToFiles } from '../../util';
import { assert } from 'console';
import { Vulnerability } from '../../entities/vulnerability';

const UNIQUE_IDENTIFIERS: (keyof Vulnerability)[] = ['cve', 'snykId', 'ghsaId', 'npmId', 'ossIndexId', 'whiteSourceId'];
const ANALYZE_VULNERABILITY_FILEPATH_PREFIX = 'analyze/vulnerability/';

export async function analyzeVulnerabilityAgreement() {
    const entityManager = getManager();
    const tools = await getData(entityManager);
    if (!tools.length) {
        console.log('Nothing to analyze');
        return;
    }
    console.log('Collecting agreement data');
    const results = await collectAgreement(tools, entityManager);
    console.log('Calculating agreement and writing it to CSV');
    writeResultsToFiles(results, ANALYZE_VULNERABILITY_FILEPATH_PREFIX);
}

function getData(entityManager: EntityManager) {
    console.log('Getting all toolExecution and project data from database');
    return entityManager.find(DetectionTool, {
        relations: [
            'toolExecutions',
            'toolExecutions.project',
            'toolExecutions.tool',
        ],
        order: {
            id: 'ASC',
        },
    });
}

async function collectAgreement(tools: DetectionTool[], entityManager: EntityManager) {
    // Sort projects
    for (const tool of tools) {
        tool.toolExecutions.sort(compareFnByProperty('project.name'));
    }
    // Verify that projects are in comparable order
    const length = tools[0].toolExecutions.length;
    assert(tools.every((tool) => tool.toolExecutions.length === length));
    for (let i = 0; i < length; ++i) {
        const name = tools[0].toolExecutions[i].project.name;
        assert(tools.every((tool) => tool.toolExecutions[i].project.name === name));
    }
    const perProjectResults: PerProjectResults = {};
    for (const tool of tools) {
        for (const toolExec of tool.toolExecutions) {
            const projectName = toolExec.project.name;
            const uniqueIdentifierOrComparison = UNIQUE_IDENTIFIERS.map((id, i) => `${i !== 0 ? ' or ' : '' }v."${id}" = v2."${id}"`);
            const res: { id: number; matching?: number; toolName: string }[] = await entityManager.createQueryBuilder(Vulnerability, 'v')
                .select('v.id, v2.id as matching, dt2.name as "toolName"')
                .leftJoin(
                    'tool_execution',
                    'te',
                    'v."toolExecutionId" = te.id',
                )
                .leftJoin(
                    'tool_execution',
                    'te2',
                    'te2."projectName" = te."projectName" and te2.id != te.id'
                )
                .leftJoin(
                    'vulnerability',
                    'v2',
                    `(${uniqueIdentifierOrComparison}) and v2."toolExecutionId" = te2.id`,
                )
                .leftJoin(
                    'detection_tool',
                    'dt2',
                    'dt2.id = te2."toolId"',
                )
                .where('v."toolExecutionId" = :teId and te."projectName" = :projectName', { teId: toolExec.id, projectName })
                .orderBy('te2."toolId"')
                .addOrderBy('v.id')
                .execute();

            if (!perProjectResults[projectName]) {
                perProjectResults[projectName] = {};
            }
            const projectResults = perProjectResults[projectName];
            if (!perProjectResults[toolExec.tool.name]) {
                projectResults[toolExec.tool.name] = {};
            }
            const toolResults = projectResults[toolExec.tool.name];
            let total = 0;
            let agreed = 0;
            let toolName = res[0]?.toolName;
            if (!toolName) {
                console.log(`No vulnerabilities for project ${projectName} with tool ${toolExec.tool.name}`);
                for (const t of tools) {
                    if (t.id != tool.id) {
                        toolResults[t.name] = {
                            agreed: 0,
                            total: 0,
                        };
                    }
                }
                continue;
            }
            console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
            for (const row of res) {
                const newToolName = row.toolName;
                if (newToolName !== toolName) {
                    toolResults[toolName] = {
                        agreed,
                        total,
                    };
                    total = 0;
                    agreed = 0;
                    toolName = newToolName;
                    console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
                }
                ++total;
                if (row.matching !== null && row.matching !== undefined) {
                    ++agreed;
                }
            }
            toolResults[toolName] = {
                agreed,
                total,
            };
        }
    }
    return perProjectResults;
}
