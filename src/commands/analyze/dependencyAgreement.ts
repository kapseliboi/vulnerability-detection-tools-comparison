import { EntityManager, getManager } from 'typeorm';
import { DetectionTool } from '../../entities/detectionTool';
import { compareFnByProperty } from '../../util';
import { assert } from 'console';
import { stringify } from 'csv/sync';
import sanitize from 'sanitize-filename';
import fs from 'fs';
import { Dependency } from '../../entities/dependency';

export async function analyzeDependencyAgreement() {
    const entityManager = getManager();
    const tools = await getData(entityManager);
    if (!tools.length) {
        console.log('Nothing to analyze');
        return;
    }
    console.log('Collecting agreement data');
    const results = await collectAgreement(tools, entityManager);
    console.log('Calculating agreement and writing it to CSV');
    writeResultsToFiles(results)
}

function getData(entityManager: EntityManager) {
    console.log('Getting all dependency data from database');
    return entityManager.find(DetectionTool, {
        relations: [
            'toolExecutions',
            'toolExecutions.project',
            'toolExecutions.tool',
        ],
        order: {
            id: 'ASC',
        },
    });
}

interface AgreementData {
    total: number;
    agreed: number;
}

interface PerProjectResults {
    [projectName: string]: {
        [toolName: string]: {
            [toolName: string]: AgreementData;
        }
    }
}

async function collectAgreement(tools: DetectionTool[], entityManager: EntityManager) {
    // Sort projects
    for (const tool of tools) {
        tool.toolExecutions.sort(compareFnByProperty('project.name'));
    }
    // Verify that projects are in comparable order
    const length = tools[0].toolExecutions.length;
    assert(tools.every((tool) => tool.toolExecutions.length === length));
    for (let i = 0; i < length; ++i) {
        const name = tools[0].toolExecutions[i].project.name;
        assert(tools.every((tool) => tool.toolExecutions[i].project.name === name));
    }
    const perProjectResults: PerProjectResults = {};
    for (const tool of tools) {
        for (const toolExec of tool.toolExecutions) {
            const projectName = toolExec.project.name;
            const res: { id: number; matching?: number; toolName: string }[] = await entityManager.createQueryBuilder(Dependency, 'd')
                .select('d.id, d2.id as matching, dt2.name as "toolName"')
                .leftJoin(
                    'tool_execution',
                    'te',
                    'd."toolExecutionId" = te.id',
                )
                .leftJoin(
                    'tool_execution',
                    'te2',
                    'te2."projectName" = te."projectName" and te2.id != te.id'
                )
                .leftJoin(
                    'dependency',
                    'd2',
                    'd."packageName" = d2."packageName" and d."version" = d2."version" and d2."toolExecutionId" = te2.id',
                )
                .leftJoin(
                    'detection_tool',
                    'dt2',
                    'dt2.id = te2."toolId"',
                )
                .where('d."toolExecutionId" = :teId and te."projectName" = :projectName', { teId: toolExec.id, projectName })
                .orderBy('te2."toolId"')
                .addOrderBy('d.id')
                .execute();

            if (!perProjectResults[projectName]) {
                perProjectResults[projectName] = {};
            }
            const projectResults = perProjectResults[projectName];
            if (!perProjectResults[toolExec.tool.name]) {
                projectResults[toolExec.tool.name] = {};
            }
            const toolResults = projectResults[toolExec.tool.name];
            let total = 0;
            let agreed = 0;
            let toolName = res[0]?.toolName;
            if (!toolName) {
                console.log(`No dependencies for project ${projectName} with tool ${toolExec.tool.name}`);
                for (const t of tools) {
                    if (t.id != tool.id) {
                        toolResults[t.name] = {
                            agreed: 0,
                            total: 0,
                        };
                    }
                }
                continue;
            }
            console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
            for (const row of res) {
                const newToolName = row.toolName;
                if (newToolName !== toolName) {
                    toolResults[toolName] = {
                        agreed,
                        total,
                    };
                    total = 0;
                    agreed = 0;
                    toolName = newToolName;
                    console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
                }
                ++total;
                if (row.matching !== null && row.matching !== undefined) {
                    ++agreed;
                }
            }
            toolResults[toolName] = {
                agreed,
                total,
            };
        }
    }
    return perProjectResults;
}

interface AgreementsBetweenTools {
    [toolName: string]: {
        [comparedToolName: string]: AgreementData[];
    }
}

const ANALYZE_DEPENDENCY_FILEPATH_PREFIX = 'analyze/dependency/';

function writeResultsToFiles(results: PerProjectResults) {
    const dateString = (new Date()).getTime();
    const projects = Object.keys(results);
    const agreementBetweenTools: AgreementsBetweenTools = {};
    const projectPath = `${ANALYZE_DEPENDENCY_FILEPATH_PREFIX}project`;
    if (!fs.existsSync(projectPath)) {
        fs.mkdirSync(projectPath, { recursive: true });
    }
    for (const project of projects) {
        const filePath = `${projectPath}/${sanitize(project)}-${dateString}.csv`;
        const writeStream = fs.createWriteStream(filePath);
        const projectResultsByTool = results[project];
        const tools = Object.keys(projectResultsByTool);
        const rows = [];
        const headerRow = ['', ...tools];
        rows.push(headerRow);
        for (let i = 0; i < tools.length; ++i) {
            const tool = tools[i];
            const dataRow: (string|number)[] = [tool];
            dataRow[i+1] = 1;
            if (!agreementBetweenTools[tool]) {
                agreementBetweenTools[tool] = {};
            }
            const toolAgreement = agreementBetweenTools[tool];
            const toolRes = projectResultsByTool[tool];
            const comparedTools = Object.keys(toolRes);
            for (const comparedTool of comparedTools) {
                if (!toolAgreement[comparedTool]) {
                    toolAgreement[comparedTool] = [];
                }
                const comparedAgreement = toolAgreement[comparedTool];
                const comparedToolRes = toolRes[comparedTool];
                comparedAgreement.push(comparedToolRes);
                const resultIndex = tools.indexOf(comparedTool) + 1;
                const agreement = calculateAgreement(comparedToolRes);
                dataRow[resultIndex] = agreement;
            }
            rows.push(dataRow);
        }
        writeStream.write(stringify(rows));
        writeStream.close();
    }
    const tools = Object.keys(agreementBetweenTools);
    const filePath = `${ANALYZE_DEPENDENCY_FILEPATH_PREFIX}total-${dateString}.csv`;
    const writeStream = fs.createWriteStream(filePath);
    const rows = [];
    const headerRow = ['', ...tools];
    rows.push(headerRow);
    for (let i = 0; i < tools.length; ++i) {
        const toolName = tools[i];
        const dataRow: (string|number)[] = [toolName];
        dataRow[i + 1] = '1 (1)';
        const toolData = agreementBetweenTools[toolName];
        const comparedToolNames = Object.keys(toolData);
        for (const comparedTool of comparedToolNames) {
            const resultIndex = tools.indexOf(comparedTool) + 1;
            const totalAgreement = calculateTotalAgreement(toolData[comparedTool]);
            const medianAgreement = calculateMedianAgreement(toolData[comparedTool]);
            dataRow[resultIndex] = `${totalAgreement} (${medianAgreement})`;
        }
        rows.push(dataRow);
    }
    writeStream.write(stringify(rows));
    writeStream.close();
}

function calculateAgreement(agreementData: AgreementData) {
    if (agreementData.total === 0) {
        return 1;
    }
    return agreementData.agreed/agreementData.total;
}

function calculateTotalAgreement(agreementData: AgreementData[]) {
    const data = agreementData.reduce((prev, cur) => ({
            agreed: prev.agreed + cur.agreed,
            total: prev.total + cur.total,
    }), { agreed: 0, total: 0 });
    return calculateAgreement(data);
}

function calculateMedianAgreement(agreementData: AgreementData[]) {
    const data = agreementData.map((agreement) => calculateAgreement(agreement)).sort();
    const lengthHalved = data.length/2;
    if (Number.isInteger(lengthHalved)) {
        return (data[lengthHalved - 1] + data[lengthHalved])/2;
    } else {
        return data[Math.ceil(lengthHalved)];
    }
}
