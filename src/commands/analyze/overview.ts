import fs from 'fs';
import { stringify } from 'csv';
import { getManager } from 'typeorm';
import { ToolExecution } from '../../entities/toolExecution';
import { Vulnerability } from '../../entities/vulnerability';
import { Stream } from 'stream';
import _ from 'lodash';

export async function analyzeOverview() {
    const filePath = 'analyze';
    if (!fs.existsSync(filePath)) {
        fs.mkdirSync(filePath, { recursive: true });
    }
    const writeStream = fs.createWriteStream(`${filePath}/overview-${(new Date()).getTime()}.csv`);
    Stream.Readable.from(toolExecReader(), { objectMode: true })
        .pipe(
            stringify({
                header: true
            })
        )
        .pipe(
            writeStream,
        );

    await new Promise((resolve, reject) => {
        writeStream.on('finish', resolve);
    });
}

async function* toolExecReader() {
    const entityManager = getManager();
    const toolExecCount = await entityManager.count(ToolExecution);
    for (let i = 0; i < toolExecCount; ++i) {
        const toolExec = await entityManager.createQueryBuilder(ToolExecution, 'toolExecution')
            .leftJoinAndSelect('toolExecution.tool', 'tool')
            .leftJoinAndSelect('toolExecution.project', 'project')
            .leftJoinAndSelect('toolExecution.dependencies', 'dependencies')
            .leftJoinAndSelect('toolExecution.vulnerabilities', 'vulnerabilities')
            .orderBy('toolExecution.project.name', 'ASC')
            .skip(i)
            .take(1)
            .getOne() as ToolExecution;

        console.log(`Processing results with tool ${toolExec.tool.name} ${toolExec.tool.version} for project ${toolExec.project.name}`);
        const result: any = {};
        result['Project name'] = toolExec.project.name;
        result['Commit hash'] = toolExec.project.commitHash;
        result['Number of starts'] = toolExec.project.stars;
        result['Number of commits'] = toolExec.project.commits;
        result['Number of contributors'] = toolExec.project.contributors;
        result['Number of forks'] = toolExec.project.forks;
        result['Number of issues'] = toolExec.project.issues;
        result['Main language'] = toolExec.project.mainLanguage;
        result['Number of PRs'] = toolExec.project.pullRequests;
        result['Number of lockfiles'] = toolExec.project.lockfileCount;
        result['Date of last commit'] = toolExec.project.lastCommitDate.toISOString();
        result['Tool'] = `${toolExec.tool.name} ${toolExec.tool.version}`;
        result['Date of tool execution'] = toolExec.createdAt;
        result['Tool execution duration (minutes)'] = Math.round((toolExec.durationMs / 1000 / 60 + Number.EPSILON) * 100) / 100;
        result['Reported dependencies'] = toolExec.dependencyCount;
        result['Unique dependencies'] = toolExec.dependencies.length;
        result['Unique packages'] = (await entityManager.query(
            `select COUNT(distinct p."name") from tool_execution te
            inner join dependency d on te.id = d."toolExecutionId"
            inner join package p on d."packageName" = p."name"
            where te.id = $1`,
            [ toolExec.id ],
        ))[0].count;
        result['Unique dependency paths'] = (await entityManager.query(
            `select COUNT(distinct dp."path") from tool_execution te
            inner join dependency d on te.id = d."toolExecutionId"
            inner join dependency_path dp on d.id = dp."dependencyId"
            where te.id = $1`,
            [ toolExec.id ],
        ))[0].count;
        result['Reported vulnerabilities'] = toolExec.vulnerabilityCount;
        result['Unique vulnerabilities'] = countUniqueVulnerabilities(toolExec.vulnerabilities);
        result['Unique low severity vulns'] = countIfConditionMatched(toolExec.vulnerabilities, isLowSeverityVulnerability);
        result['Unique medium severity vulns'] = countIfConditionMatched(toolExec.vulnerabilities, isMediumSeverityVulnerability);
        result['Unique high severity vulns'] = countIfConditionMatched(toolExec.vulnerabilities, isHighSeverityVulnerability);
        result['Unique critical severity vulns'] = countIfConditionMatched(toolExec.vulnerabilities, isCriticalSeverityVulnerability);
        result['Unique unknown severity vulns'] = countIfConditionMatched(toolExec.vulnerabilities, isUnknownSeverityVulnerability);
        console.log(`Yielding ${i} result`);
        yield result;
    }
    return true;
}

const UNIQUE_IDENTIFIERS: (keyof Vulnerability)[] = ['cve', 'snykId', 'ghsaId', 'npmId', 'ossIndexId', 'whiteSourceId'];

function vulnerabilityComparator(a: Vulnerability, b: Vulnerability) {
    for (const id of UNIQUE_IDENTIFIERS) {
        if (a[id] === b[id]) {
            return true;
        }
    }
    return false;
}

function countUniqueVulnerabilities(vulns: Vulnerability[]) {
    return _.uniqWith(vulns, vulnerabilityComparator).length;
}

function countIfConditionMatched<T>(vulns: T[], condition: (v: T) => boolean) {
    return vulns.reduce(
        (count, vuln) => {
            if (condition(vuln)) {
                ++count;
            }
            return count;
        },
        0,
    );
}

function isLowSeverityVulnerability(vuln: Vulnerability) {
    return vuln.severity.toLowerCase().trim() === 'low';
}

function isMediumSeverityVulnerability(vuln: Vulnerability) {
    return vuln.severity.toLowerCase().trim() === 'medium';
}

function isHighSeverityVulnerability(vuln: Vulnerability) {
    return vuln.severity.toLowerCase().trim() === 'high';
}

function isCriticalSeverityVulnerability(vuln: Vulnerability) {
    return vuln.severity.toLowerCase().trim() === 'critical';
}

function isUnknownSeverityVulnerability(vuln: Vulnerability) {
    return vuln.severity.toLowerCase().trim() === 'unknown';
}
