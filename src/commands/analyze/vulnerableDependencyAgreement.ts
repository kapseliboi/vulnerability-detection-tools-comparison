import { EntityManager, getManager } from 'typeorm';
import { DetectionTool } from '../../entities/detectionTool';
import { compareFnByProperty, PerProjectResults, writeResultsToFiles } from '../../util';
import { assert } from 'console';
import { Dependency } from '../../entities/dependency';

const ANALYZE_VULNERABLE_DEPENDENCY_FILEPATH_PREFIX = 'analyze/vulnerable_dependency/';

export async function analyzeVulnerableDependencyAgreement() {
    const entityManager = getManager();
    const tools = await getData(entityManager);
    if (!tools.length) {
        console.log('Nothing to analyze');
        return;
    }
    console.log('Collecting agreement data');
    const results = await collectAgreement(tools, entityManager);
    console.log('Calculating agreement and writing it to CSV');
    writeResultsToFiles(results, ANALYZE_VULNERABLE_DEPENDENCY_FILEPATH_PREFIX);
}

function getData(entityManager: EntityManager) {
    console.log('Getting all toolExecution and project data from database');
    return entityManager.find(DetectionTool, {
        relations: [
            'toolExecutions',
            'toolExecutions.project',
            'toolExecutions.tool',
        ],
        order: {
            id: 'ASC',
        },
    });
}

async function collectAgreement(tools: DetectionTool[], entityManager: EntityManager) {
    // Sort projects
    for (const tool of tools) {
        tool.toolExecutions.sort(compareFnByProperty('project.name'));
    }
    // Verify that projects are in comparable order
    const length = tools[0].toolExecutions.length;
    assert(tools.every((tool) => tool.toolExecutions.length === length));
    for (let i = 0; i < length; ++i) {
        const name = tools[0].toolExecutions[i].project.name;
        assert(tools.every((tool) => tool.toolExecutions[i].project.name === name));
    }
    const perProjectResults: PerProjectResults = {};
    for (const tool of tools) {
        for (const toolExec of tool.toolExecutions) {
            const projectName = toolExec.project.name;
            const res: { id: number; matching?: number; toolName: string }[] = await entityManager.createQueryBuilder(Dependency, 'd')
                // only select rows where te2.tooldId and d.id form a unique combination
                .select('distinct on (te2."toolId", d.id) d.id, dvv2."vulnerabilityId" as matching, dt2.name as "toolName"')
                // get only vulnerable dependencies
                .innerJoin(
                    'dependency_vulnerabilities_vulnerability',
                    'dvv',
                    'd."id" = dvv."dependencyId"',
                )
                // get toolExecution info in order to restrict results to a certain project
                .leftJoin(
                    'tool_execution',
                    'te',
                    'd."toolExecutionId" = te.id',
                )
                // get comparison toolExecutions for the same project. NOTE that we don't want to compare a toolExecution to itself
                .leftJoin(
                    'tool_execution',
                    'te2',
                    'te2."projectName" = te."projectName" and te2.id != te.id'
                )
                // get comparison dependencies
                .leftJoin(
                    'dependency',
                    'd2',
                    `d."packageName" = d2."packageName" and d."version" = d2."version" and d2."toolExecutionId" = te2.id`,
                )
                // get information 
                .leftJoin(
                    'dependency_vulnerabilities_vulnerability',
                    'dvv2',
                    'd2."id" = dvv2."dependencyId"',
                )
                .leftJoin(
                    'detection_tool',
                    'dt2',
                    'dt2.id = te2."toolId"',
                )
                .where('d."toolExecutionId" = :teId and te."projectName" = :projectName', { teId: toolExec.id, projectName })
                .orderBy('te2."toolId"')
                .addOrderBy('d.id')
                .execute();

            if (!perProjectResults[projectName]) {
                perProjectResults[projectName] = {};
            }
            const projectResults = perProjectResults[projectName];
            if (!perProjectResults[toolExec.tool.name]) {
                projectResults[toolExec.tool.name] = {};
            }
            const toolResults = projectResults[toolExec.tool.name];
            let total = 0;
            let agreed = 0;
            let toolName = res[0]?.toolName;
            if (!toolName) {
                console.log(`No vulnerabilities for project ${projectName} with tool ${toolExec.tool.name}`);
                for (const t of tools) {
                    if (t.id != tool.id) {
                        toolResults[t.name] = {
                            agreed: 0,
                            total: 0,
                        };
                    }
                }
                continue;
            }
            console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
            for (const row of res) {
                const newToolName = row.toolName;
                if (newToolName !== toolName) {
                    toolResults[toolName] = {
                        agreed,
                        total,
                    };
                    total = 0;
                    agreed = 0;
                    toolName = newToolName;
                    console.log(`Comparing project ${projectName}: ${toolExec.tool.name} to ${toolName}`);
                }
                ++total;
                if (row.matching !== null && row.matching !== undefined) {
                    ++agreed;
                }
            }
            toolResults[toolName] = {
                agreed,
                total,
            };
        }
    }
    return perProjectResults;
}
