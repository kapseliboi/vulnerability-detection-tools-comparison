import { EntityManager, getManager } from 'typeorm';
import { Vulnerability } from '../entities/vulnerability';
import { confirmQuestion } from '../util';
import _ from 'lodash';

type VulnIds = Pick<Vulnerability, 'cve' | 'snykId' | 'ghsaId' | 'npmId' | 'ossIndexId' | 'whiteSourceId'>;
type LinkedVulns = Partial<Record<keyof VulnIds, Vulnerability[]>>;
type ReplacedValues = Partial<Record<keyof VulnIds, string[]>>;

export interface Options {
    index?: number;
}

const IDS_OF_INTEREST: (keyof VulnIds)[] = ['cve', 'snykId', 'ghsaId', 'npmId', 'ossIndexId', 'whiteSourceId']; 
const OLD_NPM_ID_MAX_LENGTH = 4;

export async function interlinkVulnerabilities(opts: Options) {
    const manager = getManager();
    let vulns = await getVulns(manager);
    for (let i = opts.index || 0; i < vulns.length; ++i) {
        console.log(`Processing vulnerability ${i+1}/${vulns.length}`);
        const vuln = vulns[i];
        const linkedVulns: LinkedVulns = {};
        let vulnInfo = getVulnInfo(vuln);
        let originalVulnInfo: VulnIds;
        let replacedValues: ReplacedValues = {};
        let originalReplacedValues: ReplacedValues;
        let needSaving = false;
        do {
            originalVulnInfo = _.clone(vulnInfo);
            originalReplacedValues = _.clone(replacedValues);
            const ids = Object.keys(vulnInfo) as (keyof VulnIds)[]
            for (const id of ids) {
                const relatedVulnerabilities = await manager.find(Vulnerability, {
                    where: getIdCondition(id, vulnInfo[id]!, replacedValues),
                });
                if (relatedVulnerabilities.length < 2) {
                    continue;
                }
                needSaving = true;
                await mergeVulnInfos(vulnInfo, replacedValues, relatedVulnerabilities);
                if (linkedVulns[id]) {
                    linkedVulns[id] = _.uniq(linkedVulns[id]!.concat(relatedVulnerabilities));
                } else {
                    linkedVulns[id] = relatedVulnerabilities;
                }
            }
        } while (!(_.isEqual(originalReplacedValues, replacedValues) && _.isEqual(originalVulnInfo, vulnInfo)));
        if (!needSaving) {
            continue;
        }
        const vulnsWithUpdatedInfo = updateLinkedVulnsWithVulnInfo(linkedVulns, vulnInfo);
        await manager.save(Vulnerability, vulnsWithUpdatedInfo);
        vulns = await getVulns(manager);
    }
}

function getIdCondition(id: keyof VulnIds, currentIdVal: string, replacedValues: ReplacedValues) {
    if (replacedValues[id]) {
        return replacedValues[id]!.concat(currentIdVal).map((val) => ({
            [id]: val,
        }));
    }
    return {
        [id]: currentIdVal
    };
}

function updateLinkedVulnsWithVulnInfo(linkedVulns: LinkedVulns, vulnInfo: VulnIds) {
    const linkedVulnKeys = Object.keys(linkedVulns) as (keyof LinkedVulns)[];
    const vulns = linkedVulnKeys
        .flatMap((id) =>
            linkedVulns[id]?.map(
                (vuln) => ({
                    ...vuln,
                    ...vulnInfo,
                }) as Vulnerability,
            ),
        )
        .filter((val) => !!val) as Vulnerability[];
    return _.uniq(vulns);
}

function getVulns(manager: EntityManager) {
    return manager.find(Vulnerability, {
        order: {
            source: 'ASC',
            internalId: 'ASC',
            id: 'ASC',
        },
    });
}

function getVulnInfo(vuln: Vulnerability) {
    const vulnInfo: VulnIds = {};
    for (const id of IDS_OF_INTEREST) {
        if (!vuln[id]) {
            continue;
        }
        vulnInfo[id] = vuln[id];
    }
    return vulnInfo;
}

async function mergeVulnInfos(vulnInfo: VulnIds, replacedValues: ReplacedValues, vulns: Vulnerability[]) {
    for (const vuln of vulns) {
        const newVulnInfo = getVulnInfo(vuln);
        for (const id of IDS_OF_INTEREST) {
            const oldVal = vulnInfo[id];
            const newVal = newVulnInfo[id];
            if (!newVal) {
                continue;
            }
            if (oldVal === newVal) {
                continue;
            }
            if (replacedValues[id]?.includes(newVal)) {
                continue;
            }
            if (oldVal) {
                console.log(`New value for ${id} is "${newVal}" and old is "${oldVal}".`);
                const replaceValue = await confirmQuestion('Should old value be replaced with the new value?');
                if (replaceValue) {
                    vulnInfo[id] = newVal;
                    if (replacedValues[id]) {
                        replacedValues[id]!.push(oldVal);
                    } else {
                        replacedValues[id] = [oldVal];
                    }
                } else {
                    if (replacedValues[id]) {
                        replacedValues[id]!.push(newVal);
                    } else {
                        replacedValues[id] = [newVal];
                    }
                }
            } else {
                vulnInfo[id] = newVal;
            }
        }
    }
}
