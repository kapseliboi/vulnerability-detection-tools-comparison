import { EntityManager, getManager, Not, Raw } from 'typeorm';
import readline from 'readline';
import { Dependency } from '../entities/dependency';
import { Project } from '../entities/project';
import { ToolExecution } from '../entities/toolExecution';
import { Vulnerability } from '../entities/vulnerability';
import { compareFnByProperty } from '../util';

async function question(q: string) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<string>((resolve) => rl.question(q, (answer) => {
        rl.close();
        resolve(answer);
    }));
}

export async function cleanUpVulnerabilities() {
    const entityManager = getManager();
    const handledVulnsWithMissingInfo: string[] = [];
    let updateRequired = true;
    while (updateRequired) {
        updateRequired = false;
        let projects = await getData(entityManager);
        for (const project of projects) {
            const toolDepIndices = project.toolExecutions.map(() => 0);
            const toolsToProcess = project.toolExecutions.map(() => false);
            const { toolExecutions } = project;
            let moreToProcess = getToolsToProcess(toolExecutions, toolDepIndices, toolsToProcess);
            while (moreToProcess) {
                const allVulns: Vulnerability[] = [];
                const vulnsWithMissingInfo: Vulnerability[] = [];
                for (let i = 0; i < toolsToProcess.length; ++i) {
                    if (!toolsToProcess[i]) {
                        continue;
                    }
                    const dep = toolExecutions[i].dependencies[toolDepIndices[i]];
                    for (const vuln of dep.vulnerabilities) {
                        allVulns.push(vuln);
                        if (hasMissingIdInformation(vuln)) {
                            vulnsWithMissingInfo.push(vuln);
                        }
                    }
                    toolDepIndices[i]++;
                }
                for (const vuln of vulnsWithMissingInfo) {
                    if (handledVulnsWithMissingInfo.includes(vuln.internalId)) {
                        continue;
                    }
                    const vulnsWithInfo = await tryToFindSameVulnerabilityWithAdditionalInfo(vuln, entityManager);
                    if (vulnsWithInfo.length) {
                        console.log('Saving vulnerabilities with new info and refreshing data from database');
                        await entityManager.save(Vulnerability, vulnsWithInfo);
                        updateRequired = true;
                        break;
                    }
                    if (allVulns.length === 1) {
                        handledVulnsWithMissingInfo.push(vuln.internalId);
                        continue;
                    }
                    const vulns = await manuallyLinkVuln(vuln, allVulns, entityManager);
                    if (vulns.length) {
                        console.log('Saving vulnerabilities with new info and refreshing data from database');
                        await entityManager.save(Vulnerability, vulns);
                        updateRequired = true;
                        break;
                    }
                    handledVulnsWithMissingInfo.push(vuln.internalId);
                }
                if (updateRequired) {
                    break;
                }
                moreToProcess = getToolsToProcess(toolExecutions, toolDepIndices, toolsToProcess);
            }
            if (updateRequired) {
                break;
            }
        }
    }
}

async function getData(entityManager: EntityManager) {
    console.log('Getting all vulnerability data from database');
    const projects = await entityManager.find(Project, {
        relations: [
            'toolExecutions',
            'toolExecutions.tool',
            'toolExecutions.dependencies',
            'toolExecutions.dependencies.package',
            'toolExecutions.dependencies.vulnerabilities',
        ],
        order: {
            name: 'ASC',
        },
    });
    console.log('Sorting all data for easier manipulation');
    for (const project of projects) {
        project.toolExecutions.sort(compareFnByProperty('tool.name', 'tool.version'));
        for (const toolExec of project.toolExecutions) {
            toolExec.dependencies.sort(compareFnByProperty('package.name', 'version'));
            for (const dependency of toolExec.dependencies) {
                dependency.vulnerabilities.sort(compareFnByProperty('cve', 'npmId', 'ghsaId', 'internalId'));
            }
        }
    }
    return projects;
}

async function manuallyLinkVuln(vuln: Vulnerability, vulns: Vulnerability[], entityManager: EntityManager) {
    console.log(`Vulnerability is missing information. Trying to link it to other vulnerabilities for same dependency on same project`);
    const sameVulns: Vulnerability[] = [];
    const alreadyHandledCVEs: string[] = [];
    const alreadyHandledNpmIds: string[] = [];
    const alreadyHandledGhsaIds: string[] = [];
    for (const vulnerability of vulns) {
        if (vulnerability === vuln) {
            continue;
        }
        if (vulnerability.cve && alreadyHandledCVEs.includes(vulnerability.cve)) {
            continue;
        }
        if (vulnerability.npmId && alreadyHandledNpmIds.includes(vulnerability.npmId)) {
            continue;
        }
        if (vulnerability.ghsaId && alreadyHandledGhsaIds.includes(vulnerability.ghsaId)) {
            continue;
        }
        console.log(`Vulnerability details:
            ${JSON.stringify(vuln, null, 2)}`);
        let q = `Is this the same vulnerability:
                ${JSON.stringify(vulnerability, null, 2)}
                (y/n): `;
        while (true) {
            const answer = await question(q);
            if (answer === 'y') {
                console.log('Adding vulnerability to matched vulnerabilities');
                sameVulns.push(vulnerability);
                break;
            } else if (answer === 'n') {
                if (vulnerability.cve) {
                    alreadyHandledCVEs.push(vulnerability.cve);
                }
                if (vulnerability.npmId) {
                    alreadyHandledNpmIds.push(vulnerability.npmId);
                }
                if (vulnerability.ghsaId) {
                    alreadyHandledGhsaIds.push(vulnerability.ghsaId);
                }
                break;
            } else {
                q = 'Answer y or n: ';
            }

        }
    }
    // We didn't find other instances of the same vulnerability
    if (!sameVulns.length) {
        return [];
    }
    const allOfSameVuln = await findAllVulnerabilitiesWithSameInternalId(vuln, entityManager);
    return fulfillVulnerabilityIdInfo(allOfSameVuln.concat(sameVulns));
}

function fulfillVulnerabilityIdInfo(vulns: Vulnerability[]) {
    let cve, npmId, snykId, ghsaId;
    cve = npmId = snykId = ghsaId = undefined;
    for (const vuln of vulns) {
        if (vuln.cve) {
            if (cve && cve.toUpperCase() !== vuln.cve.toUpperCase()) {
                console.log(`CVE conflict. This should never happen. Write new code to handle this`);
            }
            cve = vuln.cve;
        }
        if (vuln.npmId) {
            if (npmId && npmId.toUpperCase() !== vuln.npmId.toUpperCase()) {
                console.log(`npmId conflict. This should never happen. Write new code to handle this`);
            }
            npmId = vuln.npmId;
        }
        if (vuln.snykId) {
            if (snykId && snykId.toUpperCase() !== vuln.snykId.toUpperCase()) {
                console.log(`snykId conflict. This should never happen. Write new code to handle this`);
            }
            snykId = vuln.snykId;
        }
        if (vuln.ghsaId) {
            if (ghsaId && ghsaId.toUpperCase() !== vuln.ghsaId.toUpperCase()) {
                console.log(`ghsaId conflict. This should never happen. Write new code to handle this`);
            }
            ghsaId = vuln.ghsaId;
        }
    }
    console.log(`Copying all possible info`);
    for (const vuln of vulns) {
        vuln.cve = cve;
        vuln.npmId = npmId;
        vuln.snykId = snykId;
        vuln.ghsaId = ghsaId;
    }
    return vulns;
}

function hasMissingIdInformation(vuln: Vulnerability) {
    if (!(vuln.ghsaId || vuln.npmId || vuln.cve)) {
        return true;
    }
    return false;
}

function getToolsToProcess(toolExecutions: ToolExecution[], toolDepIndices: number[], toolsToProcess: boolean[]) {
    const depCandidates: Dependency[] = [];
    for (let i = 0; i < toolExecutions.length; ++i) {
        const toolExec = toolExecutions[i];
        const depIndex = toolDepIndices[i];
        depCandidates.push(toolExec.dependencies[depIndex]);
    }
    if (!depCandidates.length) {
        return false;
    }
    depCandidates.sort(compareFnByProperty('package.name', 'version'));
    const dep = depCandidates[0];
    for (let i = 0; i < toolExecutions.length; ++i) {
        const toolExec = toolExecutions[i];
        const depIndex = toolDepIndices[i];
        const depCandidate = toolExec.dependencies[depIndex];
        if (depCandidate.package.name === dep.package.name && depCandidate.version === dep.version) {
            toolsToProcess[i] = true;
        } else {
            toolsToProcess[i] = false;
        }
    }
    return true;
}

function getInternalIdCondition(vuln: Vulnerability) {
    return Raw((alias) => `LOWER(${alias}) = :value`, { value: vuln.internalId.toLowerCase() });
}

async function tryToFindSameVulnerabilityWithAdditionalInfo(vuln: Vulnerability, entityManager: EntityManager) {
    const internalIdCondition = getInternalIdCondition(vuln);
    const sameVulnsWithExtraInfo = await entityManager.find(Vulnerability, {
        where: [
            { internalId: internalIdCondition, cve: Not(null) },
            { internalId: internalIdCondition, ghsaId: Not(null) },
            { internalId: internalIdCondition, npmId: Not(null) },
        ],
    });
    if (sameVulnsWithExtraInfo.length) {
        console.log(`Found missing info for vulnerability ${vuln.internalId} from database automatically. Getting all of the same vulnerabilities for update`);
        const allOfSameVuln = await findAllVulnerabilitiesWithSameInternalId(vuln, entityManager);
        return fulfillVulnerabilityIdInfo(allOfSameVuln.concat(vuln));
    } else {
        console.log(`Tried to find missing info automatically from database but found nothing.`);
        return [];
    }
}

function findAllVulnerabilitiesWithSameInternalId(vuln: Vulnerability, entityManager: EntityManager) {
    const internalIdCondition = getInternalIdCondition(vuln);
    return entityManager.find(Vulnerability, {
        where: {
            internalId: internalIdCondition,
        },
    });
}
