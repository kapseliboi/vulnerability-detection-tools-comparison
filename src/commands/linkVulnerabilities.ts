import _ from 'lodash';
import { EntityManager, getManager, Raw } from 'typeorm';
import { Dependency } from '../entities/dependency';
import { Vulnerability } from '../entities/vulnerability';
import { confirmQuestion } from '../util';

interface PartialVulnerability {
    internalId: string;
    cve?: string;
    npmId?: string;
    ghsaId?: string;
    snykId?: string;
    whiteSourceId?: string;
    ossIndexId?: string;
    description?: string;
    source: string;
}

export interface Options {
    index?: number;
}

export async function linkVulnerabilities(opts: Options) {
    const entityManager = getManager();
    let firstIteration = true;
    const handledVulnsWithMissingInfo: string[] = [];
    while (true) {
        let needUpdate = false;
        const unlinkedVulns: PartialVulnerability[] = await getData(entityManager);
        if (firstIteration && opts.index) {
            for (let i = 0; i < opts.index; ++i) {
                const vuln = unlinkedVulns[i];
                handledVulnsWithMissingInfo.push(vuln.internalId);
            }
        }
        for (let i = 0; i < unlinkedVulns.length; ++i) {
            console.log(`Processing vulnerability ${i+1}/${unlinkedVulns.length}`);
            const vuln = unlinkedVulns[i];
            if (handledVulnsWithMissingInfo.includes(vuln.internalId)) {
                continue;
            }
            handledVulnsWithMissingInfo.push(vuln.internalId);
            if (await processUnlinkedVuln(vuln, entityManager)) {
                needUpdate = true;
                break;
            }
        }
        if (!needUpdate) {
            break;
        }
    }
}

function getData(entityManager: EntityManager) {
    return entityManager.createQueryBuilder(Vulnerability, 'vulnerability')
        .select('distinct "internalId", cve, "npmId", "ghsaId", "snykId", "whiteSourceId", "ossIndexId", "source", description')
        .where('"npmId" is NULL AND "ghsaId" is NULL AND cve is NULL')
        .orderBy('"internalId"')
        .execute();
}

async function processUnlinkedVuln(unlinkedVulnerability: PartialVulnerability, entityManager: EntityManager) {
    const allOfSameVuln = await entityManager.find(Vulnerability, {
        where: {
            internalId: getInternalIdCondition(unlinkedVulnerability),
        },
        relations: ['dependencies', 'dependencies.package'],
    });
    const dependencies = allOfSameVuln.flatMap((sameVuln) => sameVuln.dependencies);
    const uniqDeps = _.uniqBy(dependencies, (dep) => ({ name: dep.package.name, version: dep.version }));
    const allOfSameDeps = await entityManager.find(Dependency, {
        where: uniqDeps.map((dep) => ({
            package: {
                name: dep.package.name,
            },
            version: dep.version,
        })),
        relations: ['vulnerabilities']
    });
    const potentialSameVulns = _.uniqBy(allOfSameDeps.flatMap((dep) =>
        dep.vulnerabilities.filter(
            (vuln) => vuln.internalId !== unlinkedVulnerability.internalId && vuln.source !== unlinkedVulnerability.source
        ),
    ), (vuln) => vuln.internalId);
    if (!potentialSameVulns.length) {
        return false;
    }
    const vulns = await manuallyLinkVuln(unlinkedVulnerability, potentialSameVulns, entityManager);
    if (!vulns.length) {
        return false;
    }
    console.log('Saving updated vulns');
    await entityManager.save(vulns);
    return true;
}

async function manuallyLinkVuln(vuln: PartialVulnerability, vulns: Vulnerability[], entityManager: EntityManager) {
    console.log(`Vulnerability is missing information. Trying to link it to other vulnerabilities`);
    const sameVulns: Vulnerability[] = [];
    const alreadyHandledCVEs: string[] = [];
    const alreadyHandledNpmIds: string[] = [];
    const alreadyHandledGhsaIds: string[] = [];
    for (let i = 0; i < vulns.length; ++i) {
        const vulnerability = vulns[i];
        if (vulnerability === vuln) {
            continue;
        }
        if (vulnerability.cve && alreadyHandledCVEs.includes(vulnerability.cve)) {
            continue;
        }
        if (vulnerability.npmId && alreadyHandledNpmIds.includes(vulnerability.npmId)) {
            continue;
        }
        if (vulnerability.ghsaId && alreadyHandledGhsaIds.includes(vulnerability.ghsaId)) {
            continue;
        }
        if (i > 0) {
            console.log('\n\n\n-------------------------------\n\n\n');
        } else {
            console.log(`Vulnerability details:
                ${JSON.stringify(vuln, null, 2)}
            `);
        }
        const q = `Is this the same vulnerability: ${JSON.stringify(vulnerability, null, 2)}`;
        const isSame = await confirmQuestion(q);
        if (isSame) {
            console.log('Adding vulnerability to matched vulnerabilities');
            sameVulns.push(vulnerability);
        } else {
            if (vulnerability.cve) {
                alreadyHandledCVEs.push(vulnerability.cve);
            }
            if (vulnerability.npmId) {
                alreadyHandledNpmIds.push(vulnerability.npmId);
            }
            if (vulnerability.ghsaId) {
                alreadyHandledGhsaIds.push(vulnerability.ghsaId);
            }
        }
    }
    // We didn't find other instances of the same vulnerability
    if (!sameVulns.length) {
        return [];
    }
    const allOfSameVuln = await findAllVulnerabilitiesWithSameInternalId(vuln, entityManager);
    return fulfillVulnerabilityIdInfo(allOfSameVuln.concat(sameVulns));
}

function fulfillVulnerabilityIdInfo(vulns: Vulnerability[]) {
    const fields: Extract<keyof Vulnerability, string>[] = ['cve', 'npmId', 'snykId', 'ghsaId', 'ossIndexId', 'whiteSourceId'];
    const values: any = {};
    for (const vuln of vulns) {
        for (const field of fields) {
            const savedVal = values[field];
            const vulnVal = vuln[field];
            if (vulnVal) {
                if (savedVal && savedVal.toUpperCase() !== (vulnVal as string).toUpperCase()) {
                    console.log(`${field} conflict. This should never happen. Write new code to handle this`);
                }
                values[field] = vulnVal;
            }
        }
    }
    console.log(`Copying all possible info`);
    for (const vuln of vulns) {
        Object.assign(vuln, values);
    }
    return vulns;
}

function getInternalIdCondition(vuln: { internalId: string }) {
    return Raw((alias) => `LOWER(${alias}) = :value`, { value: vuln.internalId.toLowerCase() });
}

function findAllVulnerabilitiesWithSameInternalId(vuln: PartialVulnerability, entityManager: EntityManager) {
    const internalIdCondition = getInternalIdCondition(vuln);
    return entityManager.find(Vulnerability, {
        where: {
            internalId: internalIdCondition,
        },
    });
}
