import fs from 'fs';
import config from '../config';
import { EntityManager, getManager } from 'typeorm';
import { Project } from '../entities/project';
import {
    GitHubApiDependencyCountNode,
    GitHubApiDependencyCountResponse,
    GitHubSearchObject,
} from '../interfaces/types';
import {
    doRequestWithRetry,
    downloadProject,
    getGitHubGraphQlClient,
    getGitHubRestClient,
    saveToDbWithErrorHandling,
    sleep,
    supportedLockfilesRegex,
} from '../util';
import { createInterface } from 'readline';
import { exec } from 'child_process';
import path from 'path';
import { gql } from 'graphql-request';
import { promisify } from 'util';

const execAsync = promisify(exec);

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

export interface Options {
    inputFiles: string[];
    minDepCount: number;
    limit: number;
    noDownloadOrInstall: boolean;
    groupSize: number;
}

export async function select(options: Options) {
    const readPromises: Promise<GitHubSearchObject>[] = [];
    for (const inputFile of options.inputFiles) {
        readPromises.push(readFile(inputFile, { encoding: 'utf-8' }).then((val) => JSON.parse(val.toString())));
    }
    const objs = await Promise.all(readPromises);
    
    const entityManager = getManager();
    const projectsPerInputFile = await getProjectsPerInputFile(objs, options, entityManager);

    const backupFile = `automaticallyFilteredProjects-${(new Date()).getTime()}.json`;
    console.log(`Backing up automatically filtered project candidates to file ${backupFile}`);
    await writeFile(backupFile, JSON.stringify(projectsPerInputFile, null, 2));

    if (options.groupSize) {
        await processProjectsInGroups(projectsPerInputFile, options, entityManager);
    } else {
        await processProjects(projectsPerInputFile, options, entityManager);
    }

    console.log('Select operation completed');
}

async function prepareProjectForAnalysis(project: Project, warmupPromise: Promise<void>, options: Options) {
    await prepareFork(project);

    console.log(`Cloning project locally to enable WhiteSource Bolt and to warmup fork's dependency graph`);
    await warmupPromise;
    if (!options.noDownloadOrInstall) {
        downloadProject(project, true, true, true);
    }

    console.log('Warm up dependency graph and enable whitesource bolt for forked project');
    warmupPromise = warmupDependencyGraphAndEnableWhiteSourceBolt(project);
    return warmupPromise;
}

async function prepareFork(project: Project) {
    console.log(`Forking project ${project.name}`);
    await forkProject(project);
    console.log(`Enabling dependabot for forked project ${project.name}`);
    await enableDependabotForForkedProject(project);
}

async function getProjectsPerInputFile(objs: GitHubSearchObject[], options: Options, entityManager: EntityManager) {
    const projectsPerInputFile: Project[][] = [];
    for (const obj of objs) {
        const projs: Project[] = [];
        const limit = options.limit || obj.items.length;
        let addedProjectCount = 0;
        let i = 0;
        while (i < obj.items.length && addedProjectCount < limit) {
            const proj = obj.items[i];
            const project = entityManager.create(Project, {
                name: proj.name,
                forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
                commitHash: proj.lastCommitSHA,
                contributors: proj.contributors,
                stars: proj.stargazers,
                forks: proj.forks,
                commits: proj.commits,
                issues: proj.totalIssues,
                pullRequests: proj.totalPullRequests,
                mainLanguage: proj.mainLanguage,
                lastCommitDate: new Date(proj.lastCommit),
            });

            if (await checkDependencyFilesAndUpdateProjectInfo(options.minDepCount, project)) {
                console.log(`Adding project ${proj.name} for manual review`);
                projs.push(project);
                ++addedProjectCount;
            }
            ++i;
        }
        projectsPerInputFile.push(projs);
    }
    return projectsPerInputFile;
}

async function processProjectsInGroups(projectsPerInputFile: Project[][], options: Options, entityManager: EntityManager) {
    let actualGroupSize = options.groupSize;
    const totalLength = projectsPerInputFile.reduce((length, projs) => length + projs.length, 0);
    let i = 0;
    const indexArray = projectsPerInputFile.map(() => 0);
    let acceptedProjectsCount = 0;
    let processedProjectsCount = 0;
    let warmupPromise = Promise.resolve();
    let moreProjectsToAnalyze = true;
    while (moreProjectsToAnalyze) {
        for (let j = 0; j < projectsPerInputFile.length; ++j) {
            const projs = projectsPerInputFile[j];
            const amountToAddThisRound = Math.round(projs.length / totalLength * options.groupSize);
            let addedThisRound = 0;
            while (addedThisRound < amountToAddThisRound && indexArray[j] < projs.length) {
                ++processedProjectsCount;
                console.log(`Processing project ${processedProjectsCount}/${totalLength}`);
                const project = projs[indexArray[j]];
                if (!(await getUsersManualConfirmation(project))) {
                    console.log(`Skipping project ${project.name} due to manual decision by user`);
                    continue;
                }

                warmupPromise = prepareProjectForAnalysis(project, warmupPromise, options);
                ++addedThisRound;
                ++acceptedProjectsCount;
                ++indexArray[j];
                console.log(`Saving project number ${acceptedProjectsCount} to dataset`);
                await saveToDbWithErrorHandling(entityManager, Project, project);
            }
        }
        if (i === 0) {
            actualGroupSize = acceptedProjectsCount;
            console.log(`Realized groupSize is ${actualGroupSize}. Specified was ${options.groupSize}. Possible difference is caused by rounding`);
        }
        console.log(`Completed group number ${i}`);
        ++i;
    }

    console.log(`Waiting for dependency graph warmup and whitesource bolt enabling to complete`);
    await warmupPromise;
}

async function processProjects(projectsPerInputFile: Project[][], options: Options, entityManager: EntityManager) {
    let processedProjectsCount = 0;
    let acceptedProjectsCount = 0;
    const totalLength = projectsPerInputFile.reduce((length, projs) => length + projs.length, 0);
    let warmupPromise = Promise.resolve();
    for (let i = 0; i < projectsPerInputFile.length; ++i) {
        console.log(`Processing projects from inputfile number ${i}`);
        const projs = projectsPerInputFile[i];
        for (const project of projs) {
            ++processedProjectsCount;
            console.log(`Processing project ${processedProjectsCount}/${totalLength}`);
            if (!(await getUsersManualConfirmation(project))) {
                console.log(`Skipping project ${project.name} due to manual decision by user`);
                continue;
            }
            warmupPromise = prepareProjectForAnalysis(project, warmupPromise, options);
            ++acceptedProjectsCount;
            console.log(`Saving project number ${acceptedProjectsCount} to dataset`);
            await saveToDbWithErrorHandling(entityManager, Project, project);
        }
    }
    console.log(`Waiting for dependency graph warmup and whitesource bolt enabling to complete`);
    await warmupPromise;
}

async function checkDependencyFilesAndUpdateProjectInfo(minDepCount: number, project: Project, useFork: boolean = false) {
    let nodes;
    try {
        nodes = await getDependencyCountNodes(project, useFork);
    } catch(err) {
        console.log(`Project ${project.name} doesn't exist any more or the dependency graph of the project is somehow bugged`);
        return false;
    }

    if (nodes.length > 18) {
        console.log(`Rejecting project ${project.name} as it contains 20 or more manifest files and Dependabot only processes a maximum of 20 manifest files`);
        return false;
    }

    let depCount = 0;
    const packageJsonRegex = /\/?package\.json$/;
    let lockfileCount = 0;
    for (const manifest of nodes) {
        if (manifest.filename.match(supportedLockfilesRegex)) {
            if (
                manifest.dependenciesCount > 0
                && !nodes.find(
                    (val) => path.dirname(val.filename) === path.dirname(manifest.filename)
                        && val.filename.match(packageJsonRegex)
                )
            ) {
                console.log(`Rejecting project ${project.name} because it contains a lockfile (${manifest.filename}) without a corresponding package.json`);
            }
            ++lockfileCount;
            if (manifest.exceedsMaxSize || !manifest.parseable) {
                console.log(`Rejected project ${project.name} because it contains a lockfile whose dependencies couldn't be parsed`);
                return false;
            } else {
                depCount += manifest.dependenciesCount;
            }
        } else if (manifest.filename.match(packageJsonRegex)) {
            if (
                manifest.dependenciesCount > 0
                && !nodes.find(
                    (val) => path.dirname(val.filename) === path.dirname(manifest.filename)
                        && val.filename.match(supportedLockfilesRegex)
                )
            ) {
                console.log(`Rejecting project ${project.name} because it contains a package.json file (${manifest.filename}) without a corresponding lockfile`);
                return false;
            }
        } else {
            console.log(`Spotted unsupported manifest file with name ${manifest.filename} and with ${manifest.dependenciesCount} dependencies.`);
            if (manifest.dependenciesCount > 0) {
                console.log(`Rejecting project ${project.name} because it contains non-npm dependencies`);
                return false;
            }
        }
    }

    project.lockfileCount = lockfileCount;
    console.log(`Found ${depCount} dependencies for project ${project.name}`);
    await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000);
    const result = depCount >= minDepCount;
    if (!result) {
        console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${minDepCount}`);
    }
    return result;
}

async function getDependencyCountNodes(project: Project, useFork: boolean) {
    const [owner, repo] = (useFork ? project.forkedName : project.name).split('/');
    const client = getGitHubGraphQlClient();
    // Only get 4 dependency manifests at a time to avoid timeouts
    const manifestCount = 4;
    let moreManifests = true;
    const nodes: GitHubApiDependencyCountNode[] = [];
    let startCursor = '';
    while (moreManifests) {
        const query = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                dependencyGraphManifests(last: ${manifestCount}${startCursor ? ', before: "' + startCursor + '"' : ''}) {
                    nodes {
                        dependenciesCount
                        exceedsMaxSize
                        filename
                        parseable
                    }
                    pageInfo {
                        startCursor
                        hasPreviousPage
                    }
                }
            }
        }`;

        const res = await doRequestWithRetry<GitHubApiDependencyCountResponse>(client, query, 15);
        for (const node of res.repository.dependencyGraphManifests.nodes) {
            nodes.push(node);
        }
        moreManifests = nodes.length < 20 && res.repository.dependencyGraphManifests.pageInfo.hasPreviousPage;
        startCursor = res.repository.dependencyGraphManifests.pageInfo.startCursor;
    }
    return nodes;
}

async function getUsersManualConfirmation(project: Project) {
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}) be added to the data set? (y/n):`, (yesOrNo) => {
            resolve(yesOrNo.toLowerCase() === 'y');
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    const res = await client.post(`/repos/${project.name}/forks`);
    // Issues are required for WhiteSource Bolt
    if (!res.data.has_issues) {
        console.log('Enabling issues for forked project');
        await client.patch(`/repos/${project.forkedName}`, { has_issues: true });
    }
}

async function deleteForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.delete(`/repos/${project.forkedName}`);
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.put(`/repos/${project.forkedName}/vulnerability-alerts`);
}

async function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..', '..');
    await execAsync(`../../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH}`, { cwd: __dirname });
}

function warmupDependencyGraphAndEnableWhiteSourceBolt(project: Project) {
    return execAsync(
        String.raw`find "$(pwd)" \( -name "package-lock.json" -o -name "yarn.lock" -o -name "npm-shrinkwrap.json" \) -not -path "*/node_modules/*" -execdir sh -c 'rm -f package.json {}; git add . && git commit -m "Remove manifests" && git push origin HEAD && sleep 10 && git restore -s HEAD~1 -- package.json {}; git add . && git commit -m "Restore manifests" && git push origin HEAD && sleep 10' \;`,
        { cwd: config.TMP_DIR_PATH},
    ).then(() => enableWhiteSourceBoltForForkedProject(project));
}
