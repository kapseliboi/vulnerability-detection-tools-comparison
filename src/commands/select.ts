import fs from 'fs';
import config from '../config';
import { EntityManager, getManager } from 'typeorm';
import { Project } from '../entities/project';
import {
    GitHubApiDependencyCountNode,
    GitHubApiDependencyCountResponse,
    GitHubSearchObject,
} from '../interfaces/types';
import {
    doRequestWithRetry,
    downloadProject,
    getGitHubGraphQlClient,
    getGitHubRestClient,
    saveToDbWithErrorHandling,
    sleep,
    supportedLockfilesRegex,
} from '../util';
import { createInterface } from 'readline';
import { execSync } from 'child_process';
import path from 'path';
import { gql } from 'graphql-request';
import { promisify } from 'util';

const readFile = promisify(fs.readFile);

export interface Options {
    inputFiles: string[];
    minDepCount: number;
    limit: number;
    noDownloadOrInstall: boolean;
    groupSize?: number;
}

export async function select(options: Options) {
    const readPromises: Promise<GitHubSearchObject>[] = [];
    for (const inputFile of options.inputFiles) {
        readPromises.push(readFile(inputFile, { encoding: 'utf-8' }).then((val) => JSON.parse(val.toString())));
    }
    const objs = await Promise.all(readPromises);
    
    const entityManager = getManager();
    const projectsPerInputFile = await getProjectsPerInputFile(objs, options, entityManager);
    const projects: Project[] = [];
    let groupSize = options.groupSize;

    if (options.groupSize) {
        groupSize = addProjectsInGroups(projects, projectsPerInputFile, options.groupSize);
    } else {
        for (const projs of projectsPerInputFile) {
            for (const project of projs) {
                projects.push(project);
            }
        }
    }
    if (options.groupSize) {
        console.log(`Group size is ${groupSize}. Specified was ${options.groupSize}. Possible difference is caused by rounding`);
    }

    for (let i = 0; i < projects.length; ++i) {
        const project = projects[i];
        console.log(`Manual review of project number ${i}`);
        if (!(await getUsersManualConfirmation(project))) {
            console.log(`Skipping project ${project.name} due to manual decision by user`);
            continue;
        }

        await prepareFork(project);

        console.log('Cloning project locally to enable WhiteSource Bolt');
        if (!options.noDownloadOrInstall) {
            downloadProject(project, true, true);
        }

        console.log('Enable whitesource bolt for forked project');
        enableWhiteSourceBoltForForkedProject(project);
        console.log('Saving project to dataset');
        await saveToDbWithErrorHandling(entityManager, Project, project);
        if (groupSize && (i + 1) % groupSize === 0) {
            console.log(`First group of ${groupSize} completed`);
        }
    }

    console.log('Select operation completed');
}

async function prepareFork(project: Project) {
    console.log(`Forking project ${project.name}`);
    await forkProject(project);
    console.log(`Enabling dependabot for forked project ${project.name}`);
    await enableDependabotForForkedProject(project);
}

async function getProjectsPerInputFile(objs: GitHubSearchObject[], options: Options, entityManager: EntityManager) {
    const githubRestClient = getGitHubRestClient({ validateStatus: undefined });
    const projectsPerInputFile: Project[][] = [];
    for (const obj of objs) {
        const projs: Project[] = [];
        const limit = options.limit || obj.items.length;
        let addedProjectCount = 0;
        let i = 0;
        while (i < obj.items.length && addedProjectCount < limit) {
            const proj = obj.items[i];
            const project = entityManager.create(Project, {
                name: proj.name,
                forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
                commitHash: proj.lastCommitSHA,
                contributors: proj.contributors,
                stars: proj.stargazers,
                forks: proj.forks,
                commits: proj.commits,
                issues: proj.totalIssues,
                pullRequests: proj.totalPullRequests,
                mainLanguage: proj.mainLanguage,
                lastCommitDate: new Date(proj.lastCommit),
            });
            const enoughDependencies = !options.minDepCount || await checkDependencyFilesAndUpdateProjectInfo(options.minDepCount, project);
            const projectExists = enoughDependencies || (await githubRestClient.get(`/repos/${project.name}`)).status === 200;
            if (enoughDependencies && projectExists) {
                console.log(`Adding project ${proj.name} for manual review`);
                projs.push(project);
                ++addedProjectCount;
            }
            ++i;
        }
        projectsPerInputFile.push(projs);
    }
    return projectsPerInputFile;
}

function addProjectsInGroups(projects: Project[], projectsPerInputFile: Project[][], groupSize: number) {
    let actualGroupSize = groupSize;
    const totalLength = projectsPerInputFile.reduce((length, projs) => length + projs.length, 0);
    let i = 0;
    while (projects.length < totalLength) {
        for (const projs of projectsPerInputFile) {
            const amountToAddThisRound = Math.round(projs.length / totalLength * groupSize);
            for (let k = i*amountToAddThisRound; k < (i + 1)*amountToAddThisRound && k < projs.length; ++k) {
                projects.push(projs[k]);
            }
        }
        if (i === 0) {
            actualGroupSize = projects.length;
        }
        ++i;
    }
    return actualGroupSize;
}

async function checkDependencyFilesAndUpdateProjectInfo(minDepCount: number, project: Project, useFork: boolean = false) {
    let nodes;
    try {
        nodes = await getDependencyCountNodes(project, useFork);
    } catch(err) {
        console.log(`Project ${project.name} doesn't exist any more`);
        return false;
    }

    if (nodes.length >= 20) {
        console.log(`Rejecting repository as it contains 20 or more manifest files and Dependabot only processes a maximum of 20 manifest files`);
        return false;
    }

    let depCount = 0;
    const packageJsonRegex = /\/?package\.json$/;
    let lockfileCount = 0;
    let lockfileStr: string | undefined = undefined;
    for (const manifest of nodes) {
        if (manifest.filename.match(supportedLockfilesRegex)) {
            lockfileStr = manifest.filename;
            ++lockfileCount;
            if (manifest.exceedsMaxSize || !manifest.parseable) {
                console.log(`Rejected project ${project.name} because it contains a lockfile whose dependencies couldn't be parsed`);
                return false;
            } else {
                depCount += manifest.dependenciesCount;
            }
        } else if (manifest.filename.match(packageJsonRegex)) {
            const index = manifest.filename.match(packageJsonRegex)!.index;
            if (
                (!lockfileStr || !lockfileStr.startsWith(manifest.filename.substr(0, index)))
                && manifest.dependenciesCount > 0
            ) {
                console.log(`Rejecting project ${project.name} because it contains a package.json file (${manifest.filename}) without a corresponding lockfile`);
                return false;
            }
        } else {
            console.log(`Spotted unsupported manifest file with name ${manifest.filename} and with ${manifest.dependenciesCount} dependencies.`);
            if (manifest.dependenciesCount > 0) {
                console.log(`Rejecting project ${project.name} because it contains non-npm dependencies`);
                return false;
            }
        }
    }

    project.lockfileCount = lockfileCount;
    console.log(`Found ${depCount} dependencies for project ${project.name}`);
    await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000);
    const result = depCount >= minDepCount;
    if (!result) {
        console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${minDepCount}`);
    }
    return result;
}

async function getDependencyCountNodes(project: Project, useFork: boolean) {
    const [owner, repo] = (useFork ? project.forkedName : project.name).split('/');
    const client = getGitHubGraphQlClient();
    // Only get 12 dependency manifests at a time to avoid timeouts
    const manifestCount = 12;
    let moreManifests = true;
    const firstQuery = gql`{
        repository(owner:"${owner}", name:"${repo}") {
            dependencyGraphManifests(last: ${manifestCount}) {
                nodes {
                    dependenciesCount
                    exceedsMaxSize
                    filename
                    parseable
                }
                pageInfo {
                    startCursor
                }
            }
            defaultBranchRef {
                target {
                    oid
                }
            }
        }
    }`;

    let i = 0;
    const nodes: GitHubApiDependencyCountNode[] = [];
    let startCursor = '';
    while (moreManifests) {
        const query = i === 0 ?
            firstQuery
            : gql`{
                repository(owner:"${owner}", name:"${repo}") {
                    dependencyGraphManifests(last: ${manifestCount}, before: "${startCursor}") {
                        nodes {
                            dependenciesCount
                            exceedsMaxSize
                            filename
                            parseable
                        }
                        pageInfo {
                            startCursor
                        }
                    }
                }
            }`;

        const res = await doRequestWithRetry<GitHubApiDependencyCountResponse>(client, query);
        if (i === 0) {
            const latestHash = res.repository.defaultBranchRef.target?.oid;
            if (!latestHash) {
                throw new Error(`Could not get latest commit hash for ${JSON.stringify(project)}`);
            }
            project.commitHash = latestHash;
        }
        for (const node of res.repository.dependencyGraphManifests.nodes) {
            nodes.push(node);
        }
        moreManifests = res.repository.dependencyGraphManifests.nodes.length === manifestCount;
        startCursor = res.repository.dependencyGraphManifests.pageInfo.startCursor;
        ++i;
    }
    return nodes;
}

async function getUsersManualConfirmation(project: Project) {
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}/tree/${project.commitHash}) be added to the data set? (y/n):`, (yesOrNo) => {
            resolve(yesOrNo.toLowerCase() === 'y');
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    const res = await client.post(`/repos/${project.name}/forks`);
    // Issues are required for WhiteSource Bolt
    if (!res.data.has_issues) {
        console.log('Enabling issues for forked project');
        await client.patch(`/repos/${project.forkedName}`, { has_issues: true });
    }
}

async function deleteForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.delete(`/repos/${project.forkedName}`);
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.put(`/repos/${project.forkedName}/vulnerability-alerts`);
}

function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..', '..');
    execSync(`../../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH} https://${config.GITHUB_TOKEN}@github.com/${project.forkedName}`, { cwd: __dirname });
}
