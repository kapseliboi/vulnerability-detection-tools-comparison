import fs from 'fs';
import config from '../config';
import { EntityManager, getManager } from 'typeorm';
import { Project } from '../entities/project';
import {
    GitHubApiDependencyCountNode,
    GitHubApiDependencyCountResponse,
    GitHubSearchObject,
} from '../interfaces/types';
import {
    deleteRepository,
    doAxiosRequestWithRetry,
    doGitHubGraphQlRequestWithRetry,
    downloadProject,
    findLockfileDirs,
    findPackageJsonDirs,
    getGitHubGraphQlClient,
    getGitHubRestClient,
    saveToDbWithErrorHandling,
    sleep,
    supportedLockfilesRegex,
} from '../util';
import { createInterface, Interface } from 'readline';
import { exec } from 'child_process';
import path from 'path';
import { gql } from 'graphql-request';
import { promisify, format } from 'util';
import axios from 'axios';

const execAsync = promisify(exec);
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

export interface Options {
    inputFiles: string[];
    noForking: boolean;
    minDepCount: number;
    limit: number;
    noDownloadOrInstall: boolean;
    groupSize: number;
    filteredProjectsFile?: string;
}

export async function select(options: Options) {
    const readPromises: Promise<GitHubSearchObject>[] = [];
    for (const inputFile of options.inputFiles) {
        readPromises.push(readFile(inputFile, { encoding: 'utf-8' }).then((val) => JSON.parse(val.toString())));
    }
    const objs = await Promise.all(readPromises);
    
    const entityManager = getManager();
    const projectsPerInputFile: Project[][] = options.filteredProjectsFile
        ? JSON.parse((await readFile(options.filteredProjectsFile)).toString())
        : await getProjectsPerInputFile(objs, options, entityManager);
    if (!options.filteredProjectsFile) {
        const backupFile = `automaticallyFilteredProjects-${(new Date()).getTime()}.json`;
        console.log(`Backing up automatically filtered project candidates to file ${backupFile}`);
        await writeFile(backupFile, JSON.stringify(projectsPerInputFile, null, 2));
    }

    if (options.groupSize) {
        await processProjectsInGroups(projectsPerInputFile, objs, options, entityManager);
    } else {
        await processProjects(projectsPerInputFile, options, entityManager);
    }

    console.log('Select operation completed');
}

async function prepareProjectForAnalysis(
    project: Project,
    warmupPromise: Promise<number>,
    options: Options,
    entityManager: EntityManager,
) {
    const client = getGitHubRestClient();
    try {
        await prepareFork(project);
    } catch(err: any) {
        if (axios.isAxiosError(err)) {
            console.log(`Creating fork of project ${project.name} failed when sending ${err.config.method} request to ${err.config.baseURL}${err.config.url} with code ${err.response?.status}`);
        } else {
            console.log(`Creating fork of project ${project.name} failed for some reason. ${err && err.message}`);
        }
        console.log(`Removing project ${project.name} as forking was unsuccessful`);
        await entityManager.remove(Project, project);
        await deleteRepository(project.forkedName, client);
        return warmupPromise.then((val) => val + 1);
    }

    const removedCount = await warmupPromise;
    if (!options.noDownloadOrInstall) {
        console.log(`Cloning project ${project.name} locally`);
        await downloadProject(project, true, true, true);
        // Update project hash to database
        await entityManager.save(Project, project);
    }

    console.log(`Verify that GitHub API didn't make a mistake with lockfile listing with project ${project.name}`);
    const lockfileDirs = await findLockfileDirs();
    const packageJsonDirs = await findPackageJsonDirs();
    if (!verifyLockfilePairing(packageJsonDirs, lockfileDirs, project)) {
        console.log(`GitHub API made a mistake. Project ${project.name} has issues with lockfile pairing. Removing project from database`);
        await entityManager.remove(Project, project);
        await deleteRepository(project.forkedName, client);
        return Promise.resolve(removedCount + 1);
    }

    console.log(`Warm up dependency graph and enable whitesource bolt for project ${project.name}`);
    warmupPromise = warmupDependencyGraphAndEnableWhiteSourceBolt(project).then(() => removedCount);
    return warmupPromise;
}

/*
    Assumes that packageJsonDirs and lockfileDirs are sorted
*/
function verifyLockfilePairing(packageJsonDirs: string[], lockfileDirs: string[], project: Project) {
    if (packageJsonDirs.length !== lockfileDirs.length) {
        console.log(`Project ${project.name} has different amount of lockfiles and package.json files`);
        return false;
    }
    let i = 0;
    while (i < packageJsonDirs.length) {
        if (path.dirname(packageJsonDirs[i]) !== path.dirname(lockfileDirs[i])) {
            console.log(`Project ${project.name} a package.json file or a lockfile without a corresponding manifest file`);
            return false;
        }
        ++i;
    }
    return true;
}

async function prepareFork(project: Project) {
    console.log(`Forking project ${project.name}`);
    await forkProject(project);
    console.log(`Enabling dependabot for forked project ${project.name}`);
    await enableDependabotForForkedProject(project);
}

async function getProjectsPerInputFile(objs: GitHubSearchObject[], options: Options, entityManager: EntityManager) {
    const projectsPerInputFile: Project[][] = [];
    for (const obj of objs) {
        const projs: Project[] = [];
        const limit = options.limit || obj.items.length;
        let addedProjectCount = 0;
        let i = 0;
        while (i < obj.items.length && addedProjectCount < limit) {
            const proj = obj.items[i];
            const project = entityManager.create(Project, {
                name: proj.name,
                forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
                commitHash: proj.lastCommitSHA,
                contributors: proj.contributors || 0,
                stars: proj.stargazers,
                forks: proj.forks || 0,
                commits: proj.commits,
                issues: proj.totalIssues || 0,
                pullRequests: proj.totalPullRequests || 0,
                mainLanguage: proj.mainLanguage,
                lastCommitDate: new Date(proj.lastCommit),
            });

            if (await checkDependencyFilesAndUpdateProjectInfo(options.minDepCount, project)) {
                console.log(`Adding project ${proj.name} for manual review (project number ${projs.length + 1})`);
                projs.push(project);
                ++addedProjectCount;
            }
            ++i;
        }
        projectsPerInputFile.push(projs);
    }
    return projectsPerInputFile;
}

async function processProjectsInGroups(
    projectsPerInputFile: Project[][],
    gitHubSearchObjects: GitHubSearchObject[],
    options: Options,
    entityManager: EntityManager,
) {
    let actualGroupSize = options.groupSize;
    const totalCountOfProjects = gitHubSearchObjects.reduce((count, val) => count + val.items.length , 0);
    const countOfFilteredProjects = projectsPerInputFile.reduce((length, projs) => length + projs.length, 0);
    let i = 0;
    const indexArray = projectsPerInputFile.map(() => 0);
    let acceptedProjectsCount = 0;
    let processedProjectsCount = 0;
    let warmupPromise = Promise.resolve(0);
    let { readline, originalConsoleLog } = replaceConsoleLogWithInputVersion();
    while (processedProjectsCount < countOfFilteredProjects) {
        for (let j = 0; j < projectsPerInputFile.length; ++j) {
            const projs = projectsPerInputFile[j];
            const amountToAddThisRound = Math.round(gitHubSearchObjects[j].items.length / totalCountOfProjects * options.groupSize);
            let addedThisRound = 0;
            while (addedThisRound < amountToAddThisRound && indexArray[j] < projs.length) {
                const project = projs[indexArray[j]];
                ++processedProjectsCount;
                ++indexArray[j];
                const res = await addAndProcessProject(
                    project,
                    processedProjectsCount,
                    acceptedProjectsCount,
                    countOfFilteredProjects,
                    warmupPromise,
                    options,
                    readline,
                    entityManager,
                );
                warmupPromise = res.warmupPromise;
                if (acceptedProjectsCount !== res.acceptedProjectsCount) {
                    acceptedProjectsCount = res.acceptedProjectsCount;
                    ++addedThisRound;
                }

                if (addedThisRound === amountToAddThisRound) {
                    restoreOriginalConsoleLog(readline, originalConsoleLog);
                    console.log(`Waiting for project analysis preparations to complete before switching to another input file in case of errors in GitHub API dependency data`);
                    const removedProjects = await warmupPromise;
                    warmupPromise = Promise.resolve(0);
                    addedThisRound -= removedProjects;
                    acceptedProjectsCount -= removedProjects;
                    const tmp = replaceConsoleLogWithInputVersion();
                    readline = tmp.readline;
                }
            }
        }
        if (i === 0) {
            actualGroupSize = acceptedProjectsCount;
            console.log(`Realized groupSize is ${actualGroupSize}. Specified was ${options.groupSize}. Possible difference is caused by rounding`);
        }
        console.log(`Completed group number ${i}`);
        ++i;
    }
    restoreOriginalConsoleLog(readline, originalConsoleLog);

    console.log(`Waiting for dependency graph warmup and whitesource bolt enabling to complete`);
    await warmupPromise;
}

async function processProjects(projectsPerInputFile: Project[][], options: Options, entityManager: EntityManager) {
    let processedProjectsCount = 0;
    let acceptedProjectsCount = 0;
    const countOfFilteredProjects = projectsPerInputFile.reduce((length, projs) => length + projs.length, 0);
    let warmupPromise = Promise.resolve(0);
    const { readline, originalConsoleLog } = replaceConsoleLogWithInputVersion();
    for (let i = 0; i < projectsPerInputFile.length; ++i) {
        console.log(`Processing projects from inputfile number ${i}`);
        const projs = projectsPerInputFile[i];
        for (const project of projs) {
            ++processedProjectsCount;
            const res = await addAndProcessProject(
                project,
                processedProjectsCount,
                acceptedProjectsCount,
                countOfFilteredProjects,
                warmupPromise,
                options,
                readline,
                entityManager,
            );
            warmupPromise = res.warmupPromise;
            if (acceptedProjectsCount !== res.acceptedProjectsCount) {
                acceptedProjectsCount = res.acceptedProjectsCount;
            }
        }
    }
    restoreOriginalConsoleLog(readline, originalConsoleLog);
    console.log(`Waiting for dependency graph warmup and whitesource bolt enabling to complete`);
    await warmupPromise;
}

async function addAndProcessProject(
    project: Project,
    processedProjectsCount: number,
    acceptedProjectsCount: number,
    countOfFilteredProjects: number,
    warmupPromise: Promise<number>,
    options: Options,
    readline: Interface,
    entityManager: EntityManager,
) {
    console.log(`Processing project ${processedProjectsCount}/${countOfFilteredProjects}`);
    if (await entityManager.findOne(Project, project)) {
        console.log(`Project already exists in the database. Skipping fork preparations for the project but adding it to the data set`);
        ++acceptedProjectsCount;
        return {
            warmupPromise,
            acceptedProjectsCount,
        };
    }
    if (!(await getUsersManualConfirmation(project, readline))) {
        console.log(`Skipping project ${project.name} due to manual decision by user`);
        return {
            warmupPromise,
            acceptedProjectsCount,
        };
    }
    ++acceptedProjectsCount;
    console.log(`Saving project number ${acceptedProjectsCount} to dataset`);
    await saveToDbWithErrorHandling(entityManager, Project, project);
    if(!options.noForking) {
        warmupPromise = prepareProjectForAnalysis(project, warmupPromise, options, entityManager);
    }
    return {
        warmupPromise,
        acceptedProjectsCount,
    };
}

function replaceConsoleLogWithInputVersion() {
    console.log(`Overriding default console.log with a version that allows input to be shown all the time`);
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    const originalConsoleLog = console.log;
    console.log = (msg?: any, ...data: any[]): void => {
        logWhilePreservingInputOnFirstLine(readline, data.length ? format(msg, data) : format(msg));
    };
    return {
        originalConsoleLog,
        readline,
    };
}

function restoreOriginalConsoleLog(readline: Interface, originalConsoleLog: (...data: any[]) => void) {
    console.log(`Restoring original console.log`);
    readline.close();
    console.log = originalConsoleLog;
}

function logWhilePreservingInputOnFirstLine(readline: Interface, txt: string) {
    // Count how many lines the readline answer + prompt takes at the moment
    const rowsOfReadline = Math.ceil((readline.line.length + readline.getPrompt().length + 1) / (readline as any).columns);
    // Use ANSI escape codes to move the cursor above the readline lines and then remove everything from cursor until end
    // and then add new text + line breaks for the readline._refreshLine to overwrite
    const finalStr = `\n\r\x1B[${rowsOfReadline}A\x1B[0J${txt}${Array(rowsOfReadline + 1).join('\n')}`;
    process.stdout.write(finalStr, (err) => {
        (readline as any)._refreshLine();
    });
}

async function checkDependencyFilesAndUpdateProjectInfo(minDepCount: number, project: Project, useFork: boolean = false) {
    let nodes;
    try {
        nodes = await getDependencyCountNodes(project, useFork);
    } catch(err) {
        console.log(`Project ${project.name} doesn't exist any more or the dependency graph of the project is somehow bugged`);
        return false;
    }

    if (nodes.length >= 20) {
        console.log(`Rejecting project ${project.name} as it contains 20 or more manifest files and Dependabot only processes a maximum of 20 manifest files`);
        return false;
    }

    let depCount = 0;
    const packageJsonRegex = /\/?package\.json$/;
    let lockfileCount = 0;
    const githubWorkflowRegex = /^\.github\/workflows\/.+\.yml$/;
    const packageJsonDirs: string[] = [];
    const lockfileDirs: string[] = [];
    for (const manifest of nodes) {
        if (manifest.filename.match(supportedLockfilesRegex) && manifest.dependenciesCount) {
            ++lockfileCount;
            lockfileDirs.push(path.dirname(manifest.filename));
            if (manifest.exceedsMaxSize || !manifest.parseable) {
                console.log(`Rejected project ${project.name} because it contains a lockfile whose dependencies couldn't be parsed`);
                return false;
            } else {
                depCount += manifest.dependenciesCount;
            }
        } else if (manifest.filename.match(packageJsonRegex) && manifest.dependenciesCount) {
            packageJsonDirs.push(path.dirname(manifest.filename));
        // Ignore github workflows and empty manifest files as GitHub doesn't delete removed manifest files from the API, they are just shown empty
        } else if (!manifest.filename.match(githubWorkflowRegex) && manifest.dependenciesCount) {
            console.log(`Spotted unsupported manifest file with name ${manifest.filename} and with ${manifest.dependenciesCount} dependencies.`);
            if (manifest.dependenciesCount) {
                console.log(`Rejecting project ${project.name} because it contains non-npm dependencies`);
                return false;
            }
        }
    }

    packageJsonDirs.sort();
    lockfileDirs.sort();
    if (!verifyLockfilePairing(packageJsonDirs, lockfileDirs, project)) {
        console.log(`Rejecting project ${project.name}`);
        return false;
    }

    project.lockfileCount = lockfileCount;
    console.log(`Found ${depCount} dependencies for project ${project.name}`);
    await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000);
    const result = depCount >= minDepCount;
    if (!result) {
        console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${minDepCount}`);
    }
    return result;
}

async function getDependencyCountNodes(project: Project, useFork: boolean) {
    const [owner, repo] = (useFork ? project.forkedName : project.name).split('/');
    console.log(`Getting dependency information from GitHub for project ${owner}/${repo}`);
    const client = getGitHubGraphQlClient();
    // Only get 1 dependency manifest at a time to avoid timeouts
    const manifestCount = 1;
    let moreManifests = true;
    const nodes: GitHubApiDependencyCountNode[] = [];
    let startCursor = '';
    while (moreManifests) {
        const query = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                dependencyGraphManifests(last: ${manifestCount}${startCursor ? ', before: "' + startCursor + '"' : ''}) {
                    nodes {
                        dependenciesCount
                        exceedsMaxSize
                        filename
                        parseable
                    }
                    pageInfo {
                        startCursor
                        hasPreviousPage
                    }
                }
            }
        }`;

        const res = await doGitHubGraphQlRequestWithRetry<GitHubApiDependencyCountResponse>(client, query, 5);
        for (const node of res.repository.dependencyGraphManifests.nodes) {
            nodes.push(node);
        }
        moreManifests = nodes.length < 20 && res.repository.dependencyGraphManifests.pageInfo.hasPreviousPage;
        startCursor = res.repository.dependencyGraphManifests.pageInfo.startCursor;
    }
    return nodes;
}

async function getUsersManualConfirmation(project: Project, readline: Interface) {
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}) be added to the data set? (y/n): `, (yesOrNo) => {
            if (yesOrNo.toLowerCase() === 'y') {
                resolve(true);
            } else if (yesOrNo.toLowerCase() === 'n') {
                resolve(false);
            } else {
                resolve(getUsersManualConfirmation(project, readline));
            }
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    const res = await client.post(`/repos/${project.name}/forks`);
    // Issues are required for WhiteSource Bolt
    if (!res.data.has_issues) {
        console.log('Enabling issues for forked project');
        await doAxiosRequestWithRetry(client, { method: 'PATCH', url: `/repos/${project.forkedName}`, data: { has_issues: true } }, 10);
    } else {
        // Forking doesn't guarantee that the project is created immediately. Check that it exists
        await doAxiosRequestWithRetry(client, { method: 'GET', url: `/repos/${project.forkedName}` }, 10);
    }
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await doAxiosRequestWithRetry(client, { method: 'PUT', url: `/repos/${project.forkedName}/vulnerability-alerts` }, 10);
}

async function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..', '..');
    await execAsync(`../../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH}`, { cwd: __dirname });
    console.log(`Enabled whitesource for forked project ${project.forkedName}`);
}

function warmupDependencyGraphAndEnableWhiteSourceBolt(project: Project) {
    return execAsync(
        String.raw`find "$(pwd)" \( -name "package-lock.json" -o -name "npm-shrinkwrap.json" \) -not -path "*/node_modules/*" -execdir sh -c 'rm -f package.json {}; git add . && git commit -m "Remove manifests" && git push origin HEAD && sleep 10 && git restore -s HEAD~1 -- package.json {}; git add . && git commit -m "Restore manifests" && git push origin HEAD && sleep 10' \;`,
        { cwd: config.TMP_DIR_PATH},
    ).then(() => enableWhiteSourceBoltForForkedProject(project));
}
