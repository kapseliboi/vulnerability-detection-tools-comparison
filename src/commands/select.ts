import fs from 'fs';
import config from '../config';
import { getManager } from 'typeorm';
import { Project } from '../entities/project';
import { CliSelectOptions, GitHubApiDependencyCountResponse, GitHubSearchObject } from '../interfaces/types';
import { downloadProject, getGitHubGraphQlClient, getGitHubRestClient, saveToDbWithErrorHandling, sleep } from '../util';
import _ from 'lodash';
import { createInterface } from 'readline';
import { execSync } from 'child_process';
import path from 'path';
import { gql } from 'graphql-request';

export async function select(options: CliSelectOptions) {
    const { items: projs }: GitHubSearchObject = JSON.parse(fs.readFileSync(options.inputFile, 'utf-8'));
    const shuffledProjects = _.shuffle(projs);
    const entityManager = getManager();
    const projects: Project[] = [];
    const startTime = Date.now();
    for (const proj of shuffledProjects) {
        const project = entityManager.create(Project, {
            name: proj.name,
            forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
            commitHash: proj.lastCommitSHA,
            contributors: proj.contributors,
            stars: proj.stargazers,
            forks: proj.forks,
            commits: proj.commits,
            issues: proj.totalIssues,
            pullRequests: proj.totalPullRequests,
        });
        if (options.minDepCount) {
            await prepareFork(project);
        }
        projects.push(project);
    }

    const endTime = Date.now();
    const duration = endTime - startTime;
    if (options.minDepCount && duration < config.SELECT_FORK_WAIT_TIME_MS) {
        console.log(`Ensuring that GitHub has ${config.SELECT_FORK_WAIT_TIME_MS / 1000} seconds to process the dependencies of the fork`);
        await sleep(config.SELECT_FORK_WAIT_TIME_MS - duration);
    }

    for (const project of projects) {
        if (options.minDepCount && !(await checkMinDepCountAndUpdateProjectInfo(options.minDepCount, project, true))) {
            console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${options.minDepCount}`);
            continue;
        }

        if (!(await getUsersManualConfirmation(project))) {
            if (options.minDepCount) {
                console.log('Deleting forked project');
                await deleteForkedProject(project);
            }
            continue;
        }

        if (!options.minDepCount) {
            await prepareFork(project);
        }

        console.log('Cloning project locally to enable WhiteSource Bolt');
        if (!options.noDownloadOrInstall) {
            downloadProject(project, true, true);
        }

        console.log('Enable whitesource bolt for forked project');
        enableWhiteSourceBoltForForkedProject(project);
        console.log('Saving project to dataset');
        await saveToDbWithErrorHandling(entityManager, Project, project);
    }

    console.log('Select operation completed');
}

async function prepareFork(project: Project) {
    console.log('Forking project');
    await forkProject(project);
    console.log('Enabling dependabot for forked project');
    await enableDependabotForForkedProject(project);
}

async function checkMinDepCountAndUpdateProjectInfo(minDepCount: number, project: Project, useFork: boolean = false) {
    const [owner, repo] = useFork ? project.forkedName.split('/') : project.name.split('/');
    const client = getGitHubGraphQlClient();
    // Only get first 10 dependency manifests to avoid timeouts
    const query = gql`{
        repository(owner:"${owner}", name:"${repo}") {
            dependencyGraphManifests(first: 10) {
                nodes {
                    dependenciesCount
                    exceedsMaxSize
                    filename
                    parseable
                }
            }
            defaultBranchRef {
                target {
                    oid
                }
            }
        }
    }`;
    const res = await client.request<GitHubApiDependencyCountResponse>(query);
    let depCount = 0;
    const packageJsonRegex = /\/?package.json$/;
    const packageLockJsonRegex = /\/?package-lock.json$/;
    let lockfileCount = 0;
    for (const manifest of res.repository.dependencyGraphManifests.nodes) {
        if (manifest.filename.match(packageLockJsonRegex)) {
            ++lockfileCount;
            if (manifest.exceedsMaxSize || !manifest.parseable) {
                console.log(`Project contains manifest file whose dependencies couldn't be parsed`);
            } else {
                depCount += manifest.dependenciesCount;
            }
        } else if (!manifest.filename.match(packageJsonRegex)) {
            ++lockfileCount;
            console.log(`Spotted unsupported manifest file with name ${manifest.filename}`);
        }
    }
    const latestHash = res.repository.defaultBranchRef.target?.oid;
    if (!latestHash) {
        throw new Error(`Could not get latest commit hash for ${JSON.stringify(project)}`);
    }
    project.commitHash = latestHash;
    project.lockfileCount = lockfileCount;
    console.log(`Found ${depCount} dependencies for project ${project.name}`);
    return depCount >= minDepCount;
}

async function getUsersManualConfirmation(project: Project) {
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}/tree/${project.commitHash}) be added to the data set? (y/n):`, (yesOrNo) => {
            resolve(yesOrNo.toLowerCase() === 'y');
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    const res = await client.post(`/repos/${project.name}/forks`);
    // Issues are required for WhiteSource Bolt
    if (!res.data.has_issues) {
        console.log('Enabling issues for forked project');
        await client.patch(`/repos/${project.forkedName}`, { has_issues: true });
    }
}

async function deleteForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.delete(`/repos/${project.forkedName}`);
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.put(`/repos/${project.forkedName}/vulnerability-alerts`);
}

function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..', '..');
    execSync(`../../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH} https://${config.GITHUB_TOKEN}@github.com/${project.forkedName}`, { cwd: __dirname });
}
