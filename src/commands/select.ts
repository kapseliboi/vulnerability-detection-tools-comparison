import fs from 'fs';
import config from '../config';
import { getManager } from 'typeorm';
import { Project } from '../entities/project';
import {
    GitHubApiDependencyCountResponse,
    GitHubSearchObject,
} from '../interfaces/types';
import {
    doRequestWithRetry,
    downloadProject,
    getGitHubGraphQlClient,
    getGitHubRestClient,
    saveToDbWithErrorHandling,
    sleep,
    supportedLockfilesRegex,
} from '../util';
import { createInterface } from 'readline';
import { execSync } from 'child_process';
import path from 'path';
import { gql } from 'graphql-request';
import { promisify } from 'util';

const readFile = promisify(fs.readFile);

export interface Options {
    inputFiles: string[];
    minDepCount: number;
    limit: number;
    noDownloadOrInstall: boolean;
    groupSize?: number;
}

export async function select(options: Options) {
    const readPromises: Promise<GitHubSearchObject>[] = [];
    for (const inputFile of options.inputFiles) {
        readPromises.push(readFile(inputFile, { encoding: 'utf-8' }).then((val) => JSON.parse(val.toString())));
    }
    const objs = await Promise.all(readPromises);
    
    const entityManager = getManager();
    const githubRestClient = getGitHubRestClient();
    githubRestClient.defaults.validateStatus = undefined;
    const projectsPerInputFile: Project[][] = [];
    for (const obj of objs) {
        const projs: Project[] = [];
        const limit = options.limit || obj.items.length;
        let addedProjectCount = 0;
        let i = 0;
        while (i < obj.items.length && addedProjectCount < limit) {
            const proj = obj.items[i];
            const project = entityManager.create(Project, {
                name: proj.name,
                forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
                commitHash: proj.lastCommitSHA,
                contributors: proj.contributors,
                stars: proj.stargazers,
                forks: proj.forks,
                commits: proj.commits,
                issues: proj.totalIssues,
                pullRequests: proj.totalPullRequests,
                mainLanguage: proj.mainLanguage,
                lastCommitDate: new Date(proj.lastCommit),
            });
            const enoughDependencies = !options.minDepCount || await checkMinDepCountAndUpdateProjectInfo(options.minDepCount, project);
            const projectExists = enoughDependencies || (await githubRestClient.get(`/repos/${project.name}`)).status === 200;
            if (enoughDependencies && projectExists) {
                console.log(`Adding project ${proj.name} for manual review`);
                projs.push(project);
                ++addedProjectCount;
            } else {
                console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${options.minDepCount}`);
            }
            ++i;
        }
        projectsPerInputFile.push(projs);
    }

    const projects: Project[] = [];
    let groupSize = options.groupSize;

    if (options.groupSize) {
        const totalLength = projectsPerInputFile.reduce((length, projs) => length + projs.length, 0);
        let i = 0;
        while (projects.length < totalLength) {
            for (const projs of projectsPerInputFile) {
                const amountToAddThisRound = Math.round(projs.length / totalLength * options.groupSize);
                for (let k = i*amountToAddThisRound; k < (i + 1)*amountToAddThisRound && k < projs.length; ++k) {
                    projects.push(projs[k]);
                }
            }
            if (i === 0) {
                groupSize = projects.length;
            }
            ++i;
        }
    } else {
        for (const projs of projectsPerInputFile) {
            for (const project of projs) {
                projects.push(project);
            }
        }
    }
    if (options.groupSize) {
        console.log(`Group size is ${groupSize}. Specified was ${options.groupSize}. Possible difference is caused by rounding`);
    }

    for (let i = 0; i < projects.length; ++i) {
        const project = projects[i];
        console.log(`Manual review of project number ${i}`);
        if (!(await getUsersManualConfirmation(project))) {
            console.log(`Skipping project ${project.name} due to manual decision by user`);
            continue;
        }

        await prepareFork(project);

        console.log('Cloning project locally to enable WhiteSource Bolt');
        if (!options.noDownloadOrInstall) {
            downloadProject(project, true, true);
        }

        console.log('Enable whitesource bolt for forked project');
        enableWhiteSourceBoltForForkedProject(project);
        console.log('Saving project to dataset');
        await saveToDbWithErrorHandling(entityManager, Project, project);
        if (groupSize && (i + 1) % groupSize === 0) {
            console.log(`First group of ${groupSize} completed`);
        }
    }

    console.log('Select operation completed');
}

async function prepareFork(project: Project) {
    console.log(`Forking project ${project.name}`);
    await forkProject(project);
    console.log(`Enabling dependabot for forked project ${project.name}`);
    await enableDependabotForForkedProject(project);
}

async function checkMinDepCountAndUpdateProjectInfo(minDepCount: number, project: Project, useFork: boolean = false) {
    const [owner, repo] = useFork ? project.forkedName.split('/') : project.name.split('/');
    const client = getGitHubGraphQlClient();
    // Only get first 10 dependency manifests to avoid timeouts
    const query = gql`{
        repository(owner:"${owner}", name:"${repo}") {
            dependencyGraphManifests(first: 10) {
                nodes {
                    dependenciesCount
                    exceedsMaxSize
                    filename
                    parseable
                }
            }
            defaultBranchRef {
                target {
                    oid
                }
            }
        }
    }`;
    let res;
    try {
        res = await doRequestWithRetry<GitHubApiDependencyCountResponse>(client, query);
    } catch(err) {
        console.log(`Project ${project.name} doesn't exist any more`);
        return false;
    }
    let depCount = 0;
    const packageJsonRegex = /\/?package\.json$/;
    let lockfileCount = 0;
    for (const manifest of res.repository.dependencyGraphManifests.nodes) {
        if (manifest.filename.match(supportedLockfilesRegex)) {
            ++lockfileCount;
            if (manifest.exceedsMaxSize || !manifest.parseable) {
                console.log(`Project contains manifest file whose dependencies couldn't be parsed`);
            } else {
                depCount += manifest.dependenciesCount;
            }
        } else if (!manifest.filename.match(packageJsonRegex)) {
            console.log(`Spotted unsupported manifest file with name ${manifest.filename}`);
        }
    }
    const latestHash = res.repository.defaultBranchRef.target?.oid;
    if (!latestHash) {
        throw new Error(`Could not get latest commit hash for ${JSON.stringify(project)}`);
    }
    project.commitHash = latestHash;
    project.lockfileCount = lockfileCount;
    console.log(`Found ${depCount} dependencies for project ${project.name}`);
    await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000);
    return depCount >= minDepCount;
}

async function getUsersManualConfirmation(project: Project) {
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}/tree/${project.commitHash}) be added to the data set? (y/n):`, (yesOrNo) => {
            resolve(yesOrNo.toLowerCase() === 'y');
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    const res = await client.post(`/repos/${project.name}/forks`);
    // Issues are required for WhiteSource Bolt
    if (!res.data.has_issues) {
        console.log('Enabling issues for forked project');
        await client.patch(`/repos/${project.forkedName}`, { has_issues: true });
    }
}

async function deleteForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.delete(`/repos/${project.forkedName}`);
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.put(`/repos/${project.forkedName}/vulnerability-alerts`);
}

function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..', '..');
    execSync(`../../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH} https://${config.GITHUB_TOKEN}@github.com/${project.forkedName}`, { cwd: __dirname });
}
