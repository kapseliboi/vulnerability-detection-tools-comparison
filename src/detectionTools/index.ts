import owaspDc from './owaspDc';
import npmAudit from './npmAudit';
import owaspDt from './owaspDt';
import snyk from './snyk';
import whiteSource from './whitesource';
import dependabot from './dependabot';
import config from '../config';
import fs from 'fs';
import path from 'path';
import { Project } from '../entities/project';
import { getManager } from 'typeorm';
import { saveToDbWithErrorHandling } from '../util';
import { fork } from 'child_process';

export const tools = [
    { ...owaspDc, path: path.join(__dirname, 'owaspDc') },
    { ...owaspDt, path: path.join(__dirname, 'owaspDt') },
    { ...npmAudit, path: path.join(__dirname, 'npmAudit') },
    { ...snyk, path: path.join(__dirname, 'snyk') },
    { ...whiteSource, path: path.join(__dirname, 'whitesource') },
    { ...dependabot, path: path.join(__dirname, 'dependabot') },
];

export async function runDetectionWithAllTools(project: Project, lockfileDirs: string[]) {
    const projectPath = config.TMP_DIR_PATH;
    const resultsPath = config.RESULTS_PATH;
    const projectResultsPath = ensureResultsFolderIsReady(project, resultsPath);
    const projectAnalysisPromises: Promise<void>[] = [];
    for (const tool of tools) {
        const dbTool = await tool.getDetectionTool();
        if (config.ENABLE_MULTITHREADING) {
            console.log(`Starting multithreaded analyze with ${dbTool.name} ${dbTool.version}`);
            const forkedChildProc = fork(tool.path);
            forkedChildProc.stdout?.pipe(process.stdout);
            forkedChildProc.stderr?.pipe(process.stderr);
            const promise = new Promise<void>((resolve, reject) => {
                forkedChildProc.on('exit', (code, signal) => {
                    if (code !== 0) {
                        reject(new Error(`${tool.TOOL_NAME} - failed with code ${code} and signal ${signal}`));
                    } else {
                        resolve();
                    }
                });
    
                forkedChildProc.on('error', (err) => {
                    console.log(`${tool.TOOL_NAME} - failed with error ${err?.message}\n\nStack:\n${err?.stack}`);
                    reject(err);
                });
            });
            forkedChildProc.send([project, projectPath, projectResultsPath, lockfileDirs, dbTool]);
            projectAnalysisPromises.push(promise);
        } else {
            console.log(`Starting analyze with ${dbTool.name} ${dbTool.version}`);
            projectAnalysisPromises.push(
                tool.runScan(project, projectPath, projectResultsPath, lockfileDirs, dbTool)
                    .then(() => { console.log(`${dbTool.name} executed successfully`); })
            );
        }
    }

    const entityManager = getManager();

    let succesfulAnalysis = true;
    const promises = await Promise.allSettled(projectAnalysisPromises);
    for (let i = 0; i < promises.length; ++i) {
        const promise = promises[i];
        const tool = tools[i];
        if (promise.status === 'rejected') {
            console.log(`${tool.TOOL_NAME} failed with error ${promise.reason}`);
            succesfulAnalysis = false;
        }
    }
    if (succesfulAnalysis) {
        project.lastSuccessfulAnalysis = new Date();
        await saveToDbWithErrorHandling(entityManager, Project, project);
    }
}

function ensureResultsFolderIsReady(project: Project, resultsPath: string) {
    if (!fs.existsSync(resultsPath)) {
        fs.mkdirSync(resultsPath);
    }

    const projectResultsPath = path.join(resultsPath, project.name, project.commitHash);
    if (!fs.existsSync(projectResultsPath)) {
        fs.mkdirSync(projectResultsPath, { recursive: true });
    }
    return projectResultsPath;
}
