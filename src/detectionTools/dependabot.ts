import { 
    DetectionToolFunction,
    GitHubApiDependenciesResponse,
    GitHubApiDependencyGraphManifestsNode,
    GitHubApiVulnerabilityAlertNode,
    GitHubApiVulnerabilityAlertsResponse,
} from '../interfaces/types';
import { gql } from 'graphql-request'; 
import { getGitHubGraphQlClient } from '../util';
import { Project } from '../entities/project';
import path from 'path';
import fs from 'fs';

const TOOL_NAME = 'dependabot';

const func: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs) => {
    const dependencies = await getDependencies(project);

    const vulnerabilities = await getVulnerabilities(project);
    
    const depPath = path.join(resultsPath, 'dependabotDeps.json');
    const vulnPath = path.join(resultsPath, 'dependabotVuln.json');

    fs.writeFileSync(depPath, JSON.stringify(dependencies, null, 2));
    fs.writeFileSync(vulnPath, JSON.stringify(vulnerabilities, null, 2));
}

export default func;

interface DependencyGraphDict {
    [filename: string]: GitHubApiDependencyGraphManifestsNode;
}

async function getDependencies(project: Project) {
    const [owner, repo] = project.forkedName.split('/');
    const client = getGitHubGraphQlClient();
    let endCursorDependencies = '';
    let endCursorDependencyPages = '';
    const dependencyGraphsByFilename: DependencyGraphDict = {};
    do {
        const dependencyQuery = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                dependencyGraphManifests(first: 2${!endCursorDependencies && endCursorDependencyPages ? ', after: "' + endCursorDependencyPages + '"' : ''}) {
                    nodes {
                        dependencies${endCursorDependencies ? '(after: "' + endCursorDependencies + '")' : ''} {
                            nodes {
                                packageManager
                                packageName
                                requirements
                            }
                            pageInfo {
                                endCursor
                                hasNextPage
                            }
                        }
                        exceedsMaxSize
                        filename
                        parseable
                    }
                    pageInfo {
                        endCursor
                        hasNextPage
                    }
                }
            }
        }`;
        const res = await client.request<GitHubApiDependenciesResponse>(dependencyQuery);
        const resNodes = res.repository.dependencyGraphManifests.nodes;
        if (!resNodes.length) {
            throw new Error('No nodes in dependency api query response');
        }

        endCursorDependencies = '';
        endCursorDependencyPages = '';

        for (const resNode of resNodes) {
            if (resNode.dependencies.pageInfo.hasNextPage) {
                endCursorDependencies = resNode.dependencies.pageInfo.endCursor;
            }

            if (dependencyGraphsByFilename[resNode.filename] && resNode.dependencies.nodes.length) {
                dependencyGraphsByFilename[resNode.filename].dependencies.nodes =
                    dependencyGraphsByFilename[resNode.filename].dependencies.nodes.concat(resNode.dependencies.nodes);
            } else {
                dependencyGraphsByFilename[resNode.filename] = resNode;
            }
        }

        if (res.repository.dependencyGraphManifests.pageInfo.hasNextPage) {
            endCursorDependencyPages = res.repository.dependencyGraphManifests.pageInfo.endCursor;
        }

    } while (endCursorDependencies || endCursorDependencyPages);

    return convertDictToArray(dependencyGraphsByFilename);
}

async function getVulnerabilities(project: Project) {
    const [owner, repo] = project.forkedName.split('/');
    const client = getGitHubGraphQlClient();
    let endCursor = '';
    let vulnerabilities: GitHubApiVulnerabilityAlertNode[] = [];

    do {
        const vulnerabilityQuery = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                vulnerabilityAlerts(first: 100${endCursor ? ', after: "' + endCursor + '"' : ''}) {
                    nodes {
                      securityAdvisory {
                        cvss {
                          score
                          vectorString
                        }
                        cwes(first: 100) {
                          nodes {
                            cweId
                            name
                          }
                        }
                        identifiers {
                          type
                          value
                        }
                        origin
                        permalink
                        publishedAt
                        references {
                          url
                        }
                        severity
                        summary
                        updatedAt
                        withdrawnAt
                      }
                        securityVulnerability {
                          firstPatchedVersion {
                              identifier
                          }
                          package {
                              ecosystem
                              name
                          }
                          severity
                          vulnerableVersionRange
                        }
                        vulnerableManifestFilename
                        vulnerableManifestPath
                        vulnerableRequirements
                    }
                    pageInfo {
                        endCursor
                        hasNextPage
                    }
                }
        }`;
        const res = await client.request<GitHubApiVulnerabilityAlertsResponse>(vulnerabilityQuery);
        endCursor = '';
        vulnerabilities = vulnerabilities.concat(res.repository.vulnerabilityAlerts.nodes);
        if (res.repository.vulnerabilityAlerts.pageInfo.hasNextPage) {
            endCursor = res.repository.vulnerabilityAlerts.pageInfo.endCursor;
        }

    } while (endCursor);

    return vulnerabilities;
    
}

function convertDictToArray<T>(dict: { [key: string]: T }): T[] {
    const filenames = Object.keys(dict);
    const arr: T[] = [];
    for (const filename of filenames) {
        arr.push(dict[filename]);
    }
    return arr;
}
