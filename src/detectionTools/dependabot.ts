import { 
    DetectionToolFunction,
    GitHubApiDependenciesResponse,
    GitHubApiDependencyGraphManifestsNode,
    GitHubApiVulnerabilityAlertNode,
    GitHubApiVulnerabilityAlertsResponse,
} from '../interfaces/types';
import { gql } from 'graphql-request'; 
import { getGitHubGraphQlClient, sleep } from '../util';
import { Project } from '../entities/project';
import path from 'path';
import fs from 'fs';

const TOOL_NAME = 'dependabot';

const func: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs) => {
    console.log('Getting dependabot dependencies from GitHub API');
    const dependencies = await getDependencies(project);

    console.log('Getting dependabot alerts from GitHub API');
    const vulnerabilities = await getVulnerabilities(project);
    
    const depPath = path.join(resultsPath, 'dependabotDeps.json');
    const vulnPath = path.join(resultsPath, 'dependabotVuln.json');

    fs.writeFileSync(depPath, JSON.stringify(dependencies, null, 2));
    fs.writeFileSync(vulnPath, JSON.stringify(vulnerabilities, null, 2));
}

export default func;

interface DependencyGraphDict {
    [filename: string]: GitHubApiDependencyGraphManifestsNode;
}

async function getDependencies(project: Project) {
    const [owner, repo] = project.forkedName.split('/');
    const client = getGitHubGraphQlClient();
    let endCursorDependencies = '';
    let startCursorDependencyPages = '';
    const dependencyGraphsByFilename: DependencyGraphDict = {};
    let requestCounter = 0;
    do {
        // dependencyGraphManifests have to be crawled backwards because forward pagination is broken in GitHub API
        const dependencyQuery = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                dependencyGraphManifests(last: 1${startCursorDependencyPages ? ', before: "' + startCursorDependencyPages + '"' : ''}) {
                    nodes {
                        dependencies${endCursorDependencies ? '(after: "' + endCursorDependencies + '")' : ''} {
                            nodes {
                                packageManager
                                packageName
                                requirements
                            }
                            pageInfo {
                                endCursor
                                hasNextPage
                            }
                        }
                        exceedsMaxSize
                        filename
                        parseable
                    }
                    pageInfo {
                        startCursor
                        hasPreviousPage
                    }
                }
            }
        }`;
        let res: GitHubApiDependenciesResponse;
        let tryAgain = true;
        while (tryAgain) {
            tryAgain = false;
            try {
                ++requestCounter;
                console.log(`Sending query number ${requestCounter} to GitHub API to get dependencies. Reason for sending query: ${endCursorDependencies ? 'more dependencies for current manifests' : 'more manifests'}`);
                res = await client.request<GitHubApiDependenciesResponse>(dependencyQuery);
            } catch (err) {
                if (err?.response.errors[0].message === 'timedout') {
                    console.log('GitHub API request timed out. Retrying in 2 seconds');
                    tryAgain = true;
                    await sleep(2000);
                } else {
                    throw err;
                }
            }
        }

        const resNodes = res!.repository.dependencyGraphManifests.nodes;
        if (!resNodes.length) {
            throw new Error('No nodes in dependency api query response');
        }

        endCursorDependencies = '';

        for (const resNode of resNodes) {
            if (resNode.dependencies.pageInfo.hasNextPage) {
                endCursorDependencies = resNode.dependencies.pageInfo.endCursor;
            }

            if (dependencyGraphsByFilename[resNode.filename]) {
                if (resNode.dependencies.nodes.length) {
                    dependencyGraphsByFilename[resNode.filename].dependencies.nodes =
                        dependencyGraphsByFilename[resNode.filename].dependencies.nodes.concat(resNode.dependencies.nodes);
                }
            } else {
                dependencyGraphsByFilename[resNode.filename] = resNode;
            }
        }

        if (!endCursorDependencies && res!.repository.dependencyGraphManifests.pageInfo.hasPreviousPage) {
            startCursorDependencyPages = res!.repository.dependencyGraphManifests.pageInfo.startCursor;
        } else if (!endCursorDependencies && !res!.repository.dependencyGraphManifests.pageInfo.hasPreviousPage) {
            startCursorDependencyPages = '';
        }

    } while (endCursorDependencies || startCursorDependencyPages);

    return convertDictToArray(dependencyGraphsByFilename);
}

async function getVulnerabilities(project: Project) {
    const [owner, repo] = project.forkedName.split('/');
    const client = getGitHubGraphQlClient();
    let endCursor = '';
    let vulnerabilities: GitHubApiVulnerabilityAlertNode[] = [];

    do {
        const vulnerabilityQuery = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                vulnerabilityAlerts(first: 100${endCursor ? ', after: "' + endCursor + '"' : ''}) {
                    nodes {
                      securityAdvisory {
                        cvss {
                          score
                          vectorString
                        }
                        cwes(first: 100) {
                          nodes {
                            cweId
                            name
                          }
                        }
                        identifiers {
                          type
                          value
                        }
                        origin
                        permalink
                        publishedAt
                        references {
                          url
                        }
                        severity
                        summary
                        updatedAt
                        withdrawnAt
                      }
                        securityVulnerability {
                          firstPatchedVersion {
                              identifier
                          }
                          package {
                              ecosystem
                              name
                          }
                          severity
                          vulnerableVersionRange
                        }
                        vulnerableManifestFilename
                        vulnerableManifestPath
                        vulnerableRequirements
                    }
                    pageInfo {
                        endCursor
                        hasNextPage
                    }
                }
            }
        }`;
        const res = await client.request<GitHubApiVulnerabilityAlertsResponse>(vulnerabilityQuery);
        endCursor = '';
        vulnerabilities = vulnerabilities.concat(res.repository.vulnerabilityAlerts.nodes);
        if (res.repository.vulnerabilityAlerts.pageInfo.hasNextPage) {
            endCursor = res.repository.vulnerabilityAlerts.pageInfo.endCursor;
        }

    } while (endCursor);

    return vulnerabilities;
    
}

function convertDictToArray<T>(dict: { [key: string]: T }): T[] {
    const filenames = Object.keys(dict);
    const arr: T[] = [];
    for (const filename of filenames) {
        arr.push(dict[filename]);
    }
    return arr;
}
