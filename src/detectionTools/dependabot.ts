import { 
    DetectionToolFunction,
    GitHubApiDependencyNode,
    GitHubApiPageInfo,
} from '../interfaces/types';
import { gql, GraphQLClient } from 'graphql-request'; 
import { getGitHubGraphQlClient, sleep, supportedLockfilesRegex } from '../util';
import { Project } from '../entities/project';
import semver from 'semver';
import { DepDict, enrichDependenciesWithVulnerabilities, getDepDictId, getDetectionToolBase, getPurl, VulnerabilityWithDepName } from './util';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { Dependency } from '../entities/dependency';
import { Package } from '../entities/package';
import { ToolExecution } from '../entities/toolExecution';
import { Vulnerability } from '../entities/vulnerability';

const TOOL_NAME = 'Dependabot';

interface GitHubApiCwe {
    cweId: string;
    name: string;
}
interface GitHubApiVulnerabilityAlertNode {
    securityAdvisory: GitHubApiSecurityAdvisory;
    securityVulnerability: {
        package: {
            ecosystem: string;
            name: string;
        }
        severity: string;
        vulnerableVersionRange: string;
    }
    vulnerableManifestFilename: string;
    vulnerableManifestPath: string;
    vulnerableRequirements: string;
}

interface GitHubApiSecurityAdvisory {
    cvss: {
        score: number;
        vectorString: string | null;
    }
    cwes: {
        nodes: GitHubApiCwe[];
    }
    ghsaId: string;
    identifiers: {
        type: string;
        value: string;
    }[];
    severity: string;
    summary: string;
}

interface GitHubApiVulnerabilityAlertsResponse {
    repository: {
        vulnerabilityAlerts: {
            nodes: GitHubApiVulnerabilityAlertNode[];
            pageInfo: GitHubApiPageInfo;
            totalCount: number;
        }
    }
}

interface GitHubApiDependencyGraphManifestsNode {
    dependencies: {
        nodes: GitHubApiDependencyNode[];
        pageInfo: GitHubApiPageInfo;
    };
    dependenciesCount: number;
    exceedsMaxSize: boolean;
    filename: string;
    parseable: boolean;
}

interface GitHubApiReversePageInfo {
    startCursor: string;
    hasPreviousPage: boolean;
}

interface GitHubApiDependenciesResponse {
    repository: {
        dependencyGraphManifests: {
            nodes: GitHubApiDependencyGraphManifestsNode[];
            pageInfo: GitHubApiReversePageInfo;
        }
    }
}

async function getDetectionTool() {
    // Dependabot doesn't really have versioning so just default to 1.0.0
    const version = '1.0.0';
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs, tool) => {
    const entityManager = getManager();
    const toolExecutionWithoutId = entityManager.create(ToolExecution, {
        durationMs: 0,
        dependencyCount: 0,
        vulnerabilityCount: 0,
        exitCode: 0,
        project,
        tool,
    });
    const toolExecution = await entityManager.save(ToolExecution, toolExecutionWithoutId);
    console.log(`${TOOL_NAME} - Getting dependabot dependencies from GitHub API`);
    let { dependencies, dependencyCount } = await getDependencies(project, entityManager, toolExecution);
    toolExecution.dependencyCount = dependencyCount;

    console.log(`${TOOL_NAME} - Getting dependabot alerts from GitHub API`);
    const { vulnerabilities, vulnerabilityCount } = await getVulnerabilities(project, entityManager, toolExecution);
    toolExecution.vulnerabilityCount = vulnerabilityCount;
    await entityManager.save(ToolExecution, toolExecution);

    console.log(`${TOOL_NAME} - Matching dependencies with vulnerabilities`);
    enrichDependenciesWithVulnerabilities(dependencies, vulnerabilities);

    console.log(`${TOOL_NAME} - Saving dependencies and vulnerabilities to database`);
    await entityManager.save(Dependency, dependencies);
}

export default {
    runScan,
    getDetectionTool,
}

async function getDependencies(project: Project, entityManager: EntityManager, toolExecution: ToolExecution) {
    const [owner, repo] = project.forkedName.split('/');
    const client = getGitHubGraphQlClient();
    let endCursorDependencies = '';
    let startCursorDependencyPages = '';
    const depDict: DepDict = {};
    let requestCounter = 0;
    let dependencyCounter = 0;
    do {
        // dependencyGraphManifests have to be crawled backwards because forward pagination is broken in GitHub API
        const dependencyQuery = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                dependencyGraphManifests(last: 1${startCursorDependencyPages ? ', before: "' + startCursorDependencyPages + '"' : ''}) {
                    nodes {
                        dependencies${endCursorDependencies ? '(after: "' + endCursorDependencies + '")' : ''} {
                            nodes {
                                packageManager
                                packageName
                                requirements
                            }
                            pageInfo {
                                endCursor
                                hasNextPage
                            }
                        }
                        dependenciesCount
                        exceedsMaxSize
                        filename
                        parseable
                    }
                    pageInfo {
                        startCursor
                        hasPreviousPage
                    }
                }
            }
        }`;
        const isMoreDependencies = !!endCursorDependencies;
        const queryRes = await doRequestWithTimeoutRetry(client, dependencyQuery, requestCounter, isMoreDependencies);
        const { res } = queryRes;
        requestCounter = queryRes.requestCounter;

        const resNodes = res.repository.dependencyGraphManifests.nodes;
        endCursorDependencies = '';
        for (const resNode of resNodes) {
            // Skip all non-lockfiles
            if (!resNode.filename.match(supportedLockfilesRegex)) {
                continue;
            }

            if (!isMoreDependencies) {
                dependencyCounter += resNode.dependenciesCount;
            }

            // If there is more dependencies in the current manifest files, save endcursor for them
            if (resNode.dependencies.pageInfo.hasNextPage) {
                endCursorDependencies = resNode.dependencies.pageInfo.endCursor;
            }

            addDependenciesToDepDict(resNode.dependencies.nodes, depDict, entityManager, toolExecution);
        }

        // If we have gone over all the dependencies in current manifest files and there is more manifest files
        if (!endCursorDependencies && res.repository.dependencyGraphManifests.pageInfo.hasPreviousPage) {
            startCursorDependencyPages = res.repository.dependencyGraphManifests.pageInfo.startCursor;

        // If we have gone over all dependencies in all manifest files 
        } else if (!endCursorDependencies && !res.repository.dependencyGraphManifests.pageInfo.hasPreviousPage) {
            startCursorDependencyPages = '';
        }

    } while (endCursorDependencies || startCursorDependencyPages);

    return {
        dependencies: _.sortBy(
            _.values(depDict),
            [(dep) => dep.package.name, 'version'],
        ),
        dependencyCount: dependencyCounter,
    };
}

function addDependenciesToDepDict(nodes: GitHubApiDependencyNode[], depDict: DepDict, entityManager: EntityManager, toolExecution: ToolExecution) {
    for (const dep of nodes) {
        if (!dep.requirements.startsWith('=')) {
            console.log(`${TOOL_NAME} - Warning: Skipping dependency with unexact version info ${JSON.stringify(dep)}`);
        } else {
            const version = semver.clean(dep.requirements);
            if (!version) {
                throw new Error(`Version info trouble with dep ${JSON.stringify(dep)}`);
            }
            const depDictId = getDepDictId(dep.packageName, version);
            if (!depDict[depDictId]) {
                const pkg = entityManager.create(Package, {
                    name: dep.packageName,
                });
                const dependency = entityManager.create(Dependency, {
                    package: pkg,
                    purl: getPurl(pkg.name, version, dep.packageManager),
                    version,
                    toolExecution,
                });
                depDict[depDictId] = dependency;
            }
        }
    }
}

async function doRequestWithTimeoutRetry(client: GraphQLClient, query: string, requestCounter: number, moreDeps: boolean) {
    while (true) {
        try {
            ++requestCounter;
            console.log(`${TOOL_NAME} - Sending query number ${requestCounter} to GitHub API to get dependencies. Reason for sending query: ${moreDeps ? 'more dependencies for current manifests' : 'more manifests'}`);
            return {
                res: await client.request<GitHubApiDependenciesResponse>(query),
                requestCounter,
            };
        } catch (err) {
            if (err?.response.errors[0].message === 'timedout') {
                console.log(`${TOOL_NAME} - GitHub API request timed out. Retrying in 2 seconds`);
                await sleep(2000);
            } else {
                throw err;
            }
        }
    }
}

async function getVulnerabilities(project: Project, entityManager: EntityManager, toolExecution: ToolExecution) {
    const [owner, repo] = project.forkedName.split('/');
    const client = getGitHubGraphQlClient();
    let endCursor = '';
    let vulnerabilityAlertCount = 0;
    const arr: VulnerabilityWithDepName[] = [];
    do {
        const vulnerabilityQuery = gql`{
            repository(owner:"${owner}", name:"${repo}") {
                vulnerabilityAlerts(first: 100${endCursor ? ', after: "' + endCursor + '"' : ''}) {
                    nodes {
                        securityAdvisory {
                            cvss {
                                score
                                vectorString
                            }
                            cwes(first: 100) {
                                nodes {
                                    cweId
                                    name
                                }
                            }
                            ghsaId
                            identifiers {
                                type
                                value
                            }
                            severity
                            summary
                        }
                        securityVulnerability {
                            package {
                                ecosystem
                                name
                            }
                            severity
                            vulnerableVersionRange
                        }
                    }
                    pageInfo {
                        endCursor
                        hasNextPage
                    }
                    totalCount
                }
            }
        }`;
        const res = await client.request<GitHubApiVulnerabilityAlertsResponse>(vulnerabilityQuery);
        endCursor = '';
        vulnerabilityAlertCount = res.repository.vulnerabilityAlerts.totalCount;
        addVulnerabilitiesToVulnArr(res.repository.vulnerabilityAlerts.nodes, arr, entityManager, toolExecution);

        if (res.repository.vulnerabilityAlerts.pageInfo.hasNextPage) {
            endCursor = res.repository.vulnerabilityAlerts.pageInfo.endCursor;
        }

    } while (endCursor);

    return {
        vulnerabilities: _.sortBy(_.uniqBy(arr, 'internalId'), ['name']),
        vulnerabilityCount: vulnerabilityAlertCount,
    };
}

function addVulnerabilitiesToVulnArr(nodes: GitHubApiVulnerabilityAlertNode[], vulns: VulnerabilityWithDepName[], entityManager: EntityManager, toolExecution: ToolExecution) {
    for (const alert of nodes) {
        const cve = getCve(alert.securityAdvisory);
        const cwe = getCwe(alert.securityAdvisory);
        const cvssInfo = getCvssInfo(alert.securityAdvisory);
        const vulnerability = {
            ...entityManager.create(Vulnerability, {
                cve,
                ...cvssInfo,
                cwe,
                description: alert.securityAdvisory.summary,
                internalId: alert.securityAdvisory.ghsaId,
                severity: alert.securityVulnerability.severity,
                source: 'GitHub',
                toolExecution,
            }),
            vulnerableVersionRange: alert.securityVulnerability.vulnerableVersionRange,
            name: alert.securityVulnerability.package.name,
        };
        vulns.push(vulnerability);
    }
}

function getCve(advisory: GitHubApiSecurityAdvisory) {
    for (const id of advisory.identifiers) {
        if (id.type === 'CVE') {
            return id.value;
        }
    }
    return undefined;
}

function getCwe(advisory: GitHubApiSecurityAdvisory) {
    return advisory.cwes.nodes.length ? advisory.cwes.nodes[0].cweId : undefined;
}

function getCvssInfo(advisory: GitHubApiSecurityAdvisory) {
    if (!advisory.cvss.vectorString && !advisory.cvss.score) {
        return {};
    } else {
        const cvssVersionRegex = /^CVSS:(\d\.\d)/;
        const cvssVersionMatch = advisory.cvss.vectorString?.match(cvssVersionRegex);
        return {
            cvssScore: advisory.cvss.score,
            cvssVector: advisory.cvss.vectorString || undefined,
            cvssVersion: cvssVersionMatch ? cvssVersionMatch[1] : undefined,
        }
    }
}
