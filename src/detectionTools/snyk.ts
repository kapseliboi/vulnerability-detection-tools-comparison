import { exec, spawn } from 'child_process';
import path from 'path';
import semver from 'semver';
import { DetectionToolFunction } from '../interfaces/types';
import {
    getPurl,
    getDetectionToolBase,
    getUniqueDepPaths,
    handleErrorsAndPromisify,
    DepDict,
    VulnDict,
    getDepDictId,
    runScanIfFork,
    saveDependencies,
    getHashFromUrl,
} from './util';
import perfHooks from 'perf_hooks';
import readline from 'readline';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ToolExecution } from '../entities/toolExecution';
import { Dependency } from '../entities/dependency';
import { DependencyPath } from '../entities/dependencyPath';
import { Package } from '../entities/package';
import { Vulnerability } from '../entities/vulnerability';
import config from '../config';
import { promisify } from 'util';
import { ManualReview } from '../entities/manualReview';
const execAsync = promisify(exec);
const rmAsync = promisify(fs.rm);
const JSONStream = require('JSONStream');
const performance = perfHooks.performance;

const TOOL_NAME = 'snyk';

interface SnykDepObj {
    hasDevDependencies: boolean;
    name: string;
    size: number;
    version: string;
    meta: {
        nodeVersion: string;
        lockfileVersion: number;
        packageManager: string;
    }
    dependencies: SnykDependencyDict;
}

interface SnykDependencyDict {
    [name: string]: SnykDependency;
}

interface SnykDependency {
    labels: {
        scope: string;
    };
    name: string;
    version: string;
    dependencies?: SnykDependencyDict;
}

interface SnykVulnObj {
    vulnerabilities: SnykVulnerability[];
    ok: boolean;
    dependencyCount: number;
    org: string;
    policy: string;
    isPrivate: boolean;
    licensesPolicy: {
        severities: {};
        orgLicenseRules: {
            [name: string]: {
                licenseType: string;
                severity: string;
                instructions: string;
            }
        }
    };
    packageManager: string;
    ignoreSettings: any | null;
    summary: string;
    remediation: {
        unresolved: SnykVulnerability[];
        upgrade: {};
        patch: {};
        ignore: {};
        pin: {};
    }
    filesystemPolicy: boolean;
    filtered: {
        ignore: any[];
        patch: any[];
    };
    uniqueCount: number;
    projectName: string;
    displayTargetFile: string;
    path: string;
}

interface SnykFunction {
    functionId: {
        className?: string | null;
        filePath: string;
        functionName: string;
    };
    version: string[];
}

interface SnykVulnerability {
    type?: string;
    CVSSv3: string;
    alternativeIds: string[];
    creationTime: string;
    credit: string[];
    cvssScore: number;
    description: string;
    disclosureTime: string;
    exploit: string;
    fixedIn: string[];
    functions: SnykFunction[];
    functions_new: SnykFunction[];
    id: string;
    identifiers: {
      CVE: string[];
      CWE: string[];
      GHSA?: string[];
      NSP?: number[];
      ALTERNATIVE?: string[];
    },
    language: string;
    modificationTime: string;
    moduleName: string;
    packageManager: string;
    packageName: string;
    patches: {
        comments: any[];
        id: string;
        modificationTime: string;
        urls: string[];
        version: string;
    }[];
    proprietary: boolean;
    publicationTime: string;
    references: {
        title: string;
        url: string;
    }[];
    semver: {
      vulnerable: string[];
    };
    severity: string;
    severityWithCritical: string;
    socialTrendAlert: boolean;
    title: string;
    from: string[];
    upgradePath: [boolean, ...string[]];
    isUpgradable: boolean;
    isPatchable: boolean;
    name: string;
    version: string;
}

async function getDetectionTool() {
    const version = (await execAsync('snyk -v')).stdout.trim();
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool, useResultFiles) => {
    const snykDepsReportTmpPath = path.join(resultsPath, 'tmp-snykDeps.json');
    const snykDepsReportPath = path.join(resultsPath, 'snykDeps.json');
    const snykVulnReportPath = path.join(resultsPath, 'snykVuln.json');

    const entityManager = getManager();

    // Save snyk results to file and print dependencies
    // This will unfortunately print dependencies for different subprojects independently instead of an array
    // This also prints out the vulnerabilities which are already saved to a file
    // Vulnerabilities can also be printed out in an array or in an object depending on if there are multiple subprojects
    const snykCmd = `snyk test --all-projects --detection-depth=1000 --dev --print-deps --json --json-file-output=${snykVulnReportPath}`;
    const cmd = `${snykCmd} > ${snykDepsReportTmpPath} || true`;
    const start = performance.now();
    if (!useResultFiles) {
        const child = spawn(cmd, { cwd: projectPath, shell: true });
        await handleErrorsAndPromisify(child, project, tool, entityManager);
    }
    const end = performance.now();
    if (!useResultFiles) {
        await parseDependenciesFromJsonFile(snykDepsReportTmpPath, snykDepsReportPath);
        await rmAsync(snykDepsReportTmpPath);
    }
    console.log(`${TOOL_NAME} - Reading vulnerability results from disk to memory`);
    const vulnObjsUnknown: SnykVulnObj[] | SnykVulnObj = JSON.parse(fs.readFileSync(snykVulnReportPath).toString());
    const vulnObjs = Array.isArray(vulnObjsUnknown) ? vulnObjsUnknown : [vulnObjsUnknown];
    const { dependencyCount, vulnerabilityCount } = getReportedCounts(vulnObjs);
    const toolExecWithoutId = entityManager.create(ToolExecution, {
        project,
        tool,
        dependencyCount,
        vulnerabilityCount,
        durationMs: end - start,
        exitCode: 0,
    });
    const toolExec = await entityManager.save(ToolExecution, toolExecWithoutId);

    const depDict = await getDependencies(snykDepsReportPath, lockfileDirs.length, entityManager, toolExec);
    console.log(`${TOOL_NAME} - linking vulnerabilities with dependencies`);
    await enrichDependenciesWithVulnerabilities(depDict, vulnObjs, entityManager, toolExec);

    console.log(`${TOOL_NAME} - saving dependencies and vulnerabilities to database`);
    let dependencies = _.values(depDict);
    dependencies = await saveDependencies(dependencies, entityManager);
    
    const depPaths = getUniqueDepPaths(dependencies);
    console.log(`${TOOL_NAME} - saving ${depPaths.length} dependency paths to database`);
    await entityManager.save(DependencyPath, depPaths, { chunk: 5000 });

    if (!config.SAVE_TOOL_RESULTS_TO_FILES) {
        fs.rmSync(snykDepsReportPath);
        fs.rmSync(snykVulnReportPath);
    }
}

async function parseDependenciesFromJsonFile(inputPath: string, outputPath: string) {
    return new Promise<void>((resolve, reject) => {
        let done = false;
        const objectLastLineRegex = /^\}$/;
        let objectLastLineContent: string | undefined = undefined;
        let objectLastLineIndex = -1;
        const objectFirstLineRegex = /^\{/;
        let objectFirstLineContent: string | undefined = undefined;
        let objectFirstLineIndex = -1;
        const arrayStartRegex = /^\[$/;
        const vulnerabilitiesRegex = /"vulnerabilities": \[$/;
        const rl = readline.createInterface({
            input: fs.createReadStream(inputPath),
            output: process.stdout,
            terminal: false,
        });
        const writeStream = fs.createWriteStream(outputPath);
        let index = -1;
        rl.on('line', (line) => {
            // Closing rl interface doesn't stop emitting of line events
            if (done) {
                return;
            }
            ++index;
            // Start an array of dependencies for each subproject snyk finds
            if (index === 0) {
                writeStream.write(`[${line}\n`);
            // Recognize the ending of a formatted JSON object to be able to add a comma or end the dependencies array
            } else if(objectLastLineRegex.test(line)) {
                objectLastLineIndex = index;
                objectLastLineContent = line;
            // If there is only one project then the vulnerabilities will be an object as well so we have to recognize which object it is
            } else if (objectFirstLineRegex.test(line)) {
                // In case the JSON is unformatted and all dependency JSON objects are fitted in to one line.
                // This should only happen is there are multiple projects which means that vulnerabilities will be reported in an array
                // so safe to assume we matched a dependencies object
                if ((index - 1) === objectFirstLineIndex) {
                    if ((index - 2) >= 0 && (index - 2) === objectLastLineIndex) {
                        writeStream.write(`${objectLastLineContent},\n`);
                    }
                    writeStream.write(`${objectFirstLineContent},\n`);
                    objectFirstLineIndex = index;
                    objectFirstLineContent = line;
                } else {
                    objectFirstLineIndex = index;
                    objectFirstLineContent = line;
                    if ((objectFirstLineIndex - 1) !== objectLastLineIndex) {
                        rl.close();
                        done = true;
                        reject(`JSON object's last line and next object's first line were not subsequent`);
                    }
                }
            } else if (arrayStartRegex.test(line)) {
                if ((index - 1) === objectFirstLineIndex) {
                    writeStream.write(`${objectFirstLineContent}]\n`);
                } else {
                    writeStream.write(`${objectLastLineContent}]\n`);
                }
                done = true;
                rl.close();
            } else if ((index - 1) === objectFirstLineIndex) {
                if (vulnerabilitiesRegex.test(line)) {
                    writeStream.write(`${objectLastLineContent}]\n`);
                    done = true;
                    rl.close();
                } else {
                    if (!objectLastLineContent || !objectFirstLineContent) {
                        done = true;
                        rl.close();
                        reject(`For some reason JSON object's last or first line of content is missing`);
                    } else {
                        writeStream.write(`${objectLastLineContent},\n`);
                        writeStream.write(`${objectFirstLineContent}\n`);
                        writeStream.write(`${line}\n`);
                        objectLastLineContent = undefined;
                        objectLastLineIndex = -1;
                        objectFirstLineContent = undefined;
                        objectFirstLineIndex = -1;

                    }
                }
            } else {
                writeStream.write(`${line}\n`);
            }
        });

        rl.on('close', () => {
            writeStream.close();
            resolve();
        });
    });
}

function getReportedCounts(vulnObjs: SnykVulnObj[]) {
    let dependencyCount = 0;
    let vulnerabilityCount = 0;
    for (const vulnObj of vulnObjs) {
        dependencyCount += vulnObj.dependencyCount;
        vulnerabilityCount += vulnObj.vulnerabilities.length;
    }
    return { dependencyCount, vulnerabilityCount };
}

function getDependencies(depResultPath: string, lockfileCount: number, entityManager: EntityManager, toolExec: ToolExecution) {
    const depDict: DepDict = {};
    let counter = 0;
    const stream = fs.createReadStream(depResultPath, { encoding: 'utf-8' });
    const parser = JSONStream.parse('*');
    stream.pipe(parser);
    parser.on('data', (depObj: SnykDepObj) => {
        ++counter;
        console.log(`${TOOL_NAME} - reading dependency information from JSON stream for project ${depObj.name}@${depObj.version}`);
        const currentPath = [getDepDictId(depObj.name || counter.toString(), depObj.version || '*')];
        getDependenciesRecursive(depObj.dependencies, depDict, currentPath, entityManager, toolExec);
    });
    
    return new Promise<DepDict>((resolve, reject) => {
        parser.on('close', () => {
            if (counter !== lockfileCount) {
                reject(`We didn't analyze all lockfiles`);
            } else {
                resolve(depDict);
            }
        });
    });
}

function getDependenciesRecursive(
    snykDepDict: SnykDependencyDict,
    depsDict: DepDict,
    currentPath: string[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    for (const key in snykDepDict) {
        const snykDep = snykDepDict[key];
        const version = semver.valid(snykDep.version)
            ? snykDep.version
            : getHashFromUrl(snykDep.version) || snykDep.version;
        const dictId = getDepDictId(snykDep.name, version);
        const clonedCurrentPath = _.clone(currentPath);
        clonedCurrentPath.push(dictId);

        const depPath = entityManager.create(DependencyPath, {
            path: clonedCurrentPath.join(','),
        });

        if (depsDict[dictId]) {
            depsDict[dictId].dependencyPaths.push(depPath);
        } else {
            const pkg = entityManager.create(Package, {
                name: snykDep.name,
            });
            const dependency = entityManager.create(Dependency, {
                package: pkg,
                purl: getPurl(snykDep.name, version),
                toolExecution,
                version,
                vulnerabilities: [],
                dependencyPaths: [depPath],
            });
            depsDict[dictId] = dependency;
        }

        if (snykDep.dependencies) {
            getDependenciesRecursive(snykDep.dependencies, depsDict, clonedCurrentPath, entityManager, toolExecution)
        }
    }
}

async function enrichDependenciesWithVulnerabilities(
    depDict: DepDict,
    vulnObjs: SnykVulnObj[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const vulnDict: VulnDict = {};
    for (const project of vulnObjs) {
        for (const snykVuln of project.vulnerabilities) {
            // Skip potential license issues
            if (snykVuln.type === 'license') {
                continue;
            }
            let vulnerability = vulnDict[snykVuln.id];
            if (!vulnerability) {
                vulnerability = createVulnerability(snykVuln, entityManager, toolExecution);
                vulnDict[snykVuln.id] = vulnerability;
            }
            const depId = getDepDictId(snykVuln.name, snykVuln.version);
            const dependency = depDict[depId];
            if (!dependency) {
                console.log(`${TOOL_NAME} - For some reason a dependency was not listed in the dependencies. Usually this means that the project itself contains a vulnerability. Adding a manual review for this`);
                const review = entityManager.create(ManualReview, { toolExecution, data: JSON.stringify(snykVuln), reason: `Couldn't find a corresponding dependency for vulnerability. Could be a self vulnerability`});
                await entityManager.save(ManualReview, review);
                continue;
            }
            dependency.vulnerabilities.push(vulnerability);
            if (dependency.vulnerabilities.length > 1) {
                dependency.vulnerabilities = _.uniqBy(dependency.vulnerabilities, 'internalId');
            }
            if (!assertDependencyPathExistence(snykVuln, dependency)) {
                console.log(`${TOOL_NAME} - Not all dependency paths were collected`);
                fs.writeFileSync(`snykerror-${toolExecution.project.name.split('/')[0]}.json`, JSON.stringify({ dependency, snykVuln }));
                throw new Error(`${TOOL_NAME} - Dependency path error`);
            }
        }
    }
}

function createVulnerability(snykVuln: SnykVulnerability, entityManager: EntityManager, toolExecution: ToolExecution) {
    return entityManager.create(Vulnerability, {
        ...getCvssInfo(snykVuln),
        cwe: getCwe(snykVuln),
        cve: getCve(snykVuln),
        description: snykVuln.description,
        internalId: snykVuln.id,
        npmId: getNpmId(snykVuln),
        ghsaId: getGhsaId(snykVuln),
        severity: snykVuln.severity,
        source: 'snyk',
        vulnerableVersionRange: snykVuln.semver.vulnerable.join(' || '),
        toolExecution,
    });
}

function assertDependencyPathExistence(snykVuln: SnykVulnerability, dep: Dependency) {
    return !!dep.dependencyPaths.find((depPath) => _.isEqual(snykVuln.from, depPath.path.split(',')));
}

function getNpmId(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.NSP?.length ? snykVuln.identifiers.NSP[0].toString() : undefined;
}

function getGhsaId(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.GHSA?.length ? snykVuln.identifiers.GHSA[0] : undefined;
}

function getCve(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.CVE.length ? snykVuln.identifiers.CVE[0] : undefined;
}

function getCwe(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.CWE.length ? snykVuln.identifiers.CWE[0] : undefined;
}

function getCvssInfo(snykVuln: SnykVulnerability) {
    const cvssVersionRegex = /^CVSS:(\d\.\d)/;
    const cvssVersionMatch = snykVuln.CVSSv3.match(cvssVersionRegex);
    return {
        cvssScore: snykVuln.cvssScore,
        cvssVector: snykVuln.CVSSv3,
        cvssVersion: cvssVersionMatch ? cvssVersionMatch[1] : undefined,
    };
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
};

runScanIfFork(runScan);
