import { exec, spawn } from 'child_process';
import path from 'path';
import { DetectionToolFunction } from '../interfaces/types';
import {
    getPurl,
    getDetectionToolBase,
    getUniqueDepPaths,
    handleErrorsAndPromisify,
    DepDict,
    VulnDict,
    getDepDictId,
    runScanIfFork,
    saveDependencies,
} from './util';
import perfHooks from 'perf_hooks';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ToolExecution } from '../entities/toolExecution';
import { Dependency } from '../entities/dependency';
import { DependencyPath } from '../entities/dependencyPath';
import { Package } from '../entities/package';
import { Vulnerability } from '../entities/vulnerability';
import config from '../config';
import { promisify } from 'util';
const execAsync = promisify(exec);
const JSONStream = require('JSONStream');
const performance = perfHooks.performance;

const TOOL_NAME = 'snyk';

interface SnykDepObj {
    hasDevDependencies: boolean;
    name: string;
    size: number;
    version: string;
    meta: {
        nodeVersion: string;
        lockfileVersion: number;
        packageManager: string;
    }
    dependencies: SnykDependencyDict;
}

interface SnykDependencyDict {
    [name: string]: SnykDependency;
}

interface SnykDependency {
    labels: {
        scope: string;
    };
    name: string;
    version: string;
    dependencies?: SnykDependencyDict;
}

interface SnykVulnObj {
    vulnerabilities: SnykVulnerability[];
    ok: boolean;
    dependencyCount: number;
    org: string;
    policy: string;
    isPrivate: boolean;
    licensesPolicy: {
        severities: {};
        orgLicenseRules: {
            [name: string]: {
                licenseType: string;
                severity: string;
                instructions: string;
            }
        }
    };
    packageManager: string;
    ignoreSettings: any | null;
    summary: string;
    remediation: {
        unresolved: SnykVulnerability[];
        upgrade: {};
        patch: {};
        ignore: {};
        pin: {};
    }
    filesystemPolicy: boolean;
    filtered: {
        ignore: any[];
        patch: any[];
    };
    uniqueCount: number;
    projectName: string;
    displayTargetFile: string;
    path: string;
}

interface SnykFunction {
    functionId: {
        className?: string | null;
        filePath: string;
        functionName: string;
    };
    version: string[];
}

interface SnykVulnerability {
    type?: string;
    CVSSv3: string;
    alternativeIds: string[];
    creationTime: string;
    credit: string[];
    cvssScore: number;
    description: string;
    disclosureTime: string;
    exploit: string;
    fixedIn: string[];
    functions: SnykFunction[];
    functions_new: SnykFunction[];
    id: string;
    identifiers: {
      CVE: string[];
      CWE: string[];
      GHSA?: string[];
      NSP?: number[];
      ALTERNATIVE?: string[];
    },
    language: string;
    modificationTime: string;
    moduleName: string;
    packageManager: string;
    packageName: string;
    patches: {
        comments: any[];
        id: string;
        modificationTime: string;
        urls: string[];
        version: string;
    }[];
    proprietary: boolean;
    publicationTime: string;
    references: {
        title: string;
        url: string;
    }[];
    semver: {
      vulnerable: string[];
    };
    severity: string;
    severityWithCritical: string;
    socialTrendAlert: boolean;
    title: string;
    from: string[];
    upgradePath: [boolean, ...string[]];
    isUpgradable: boolean;
    isPatchable: boolean;
    name: string;
    version: string;
}

async function getDetectionTool() {
    const version = (await execAsync('snyk -v')).stdout.trim();
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool) => {
    const snykDepsReportTmpPath = path.join(resultsPath, 'tmp-snykDeps.json');
    const snykDepsReportPath = path.join(resultsPath, 'snykDeps.json');
    const snykVulnReportPath = path.join(resultsPath, 'snykVuln.json');

    const entityManager = getManager();

    // Save snyk results to file and print dependencies
    // This will unfortunately print dependencies for different subprojects independently instead of an array
    // This also prints out the vulnerabilities which are already saved to a file
    const snykCmd = `snyk test --all-projects --detection-depth=1000 --dev --print-deps --json --json-file-output=${snykVulnReportPath}`;
    // Add commas between different dependency JSON objects
    const perlCmd = String.raw`perl -0pe 's/^\}\n\{\n/\},\n\{\n/gms'`;
    // Remove vulnerability info and turn comma separated JSON objects into an array
    const sedVulnCmd = String.raw`sed '/^}$/q'`;
    const sedArraifyCmd = String.raw`sed -e '1 i\[' -e '$a]'`;
    const cmd = `${snykCmd} > ${snykDepsReportTmpPath}; cat ${snykDepsReportTmpPath} | ${perlCmd} | ${sedVulnCmd} | ${sedArraifyCmd} > ${snykDepsReportPath} && rm ${snykDepsReportTmpPath}`;
    const start = performance.now();
    const child = spawn(cmd, { cwd: projectPath, shell: true });
    await handleErrorsAndPromisify(child, project, tool, entityManager);
    const end = performance.now();
    console.log(`${TOOL_NAME} - Reading vulnerability results from disk to memory`);
    const vulnObjsUnknown: SnykVulnObj[] | SnykVulnObj = JSON.parse(fs.readFileSync(snykVulnReportPath).toString());
    const vulnObjs = Array.isArray(vulnObjsUnknown) ? vulnObjsUnknown : [vulnObjsUnknown];
    const { dependencyCount, vulnerabilityCount } = getReportedCounts(vulnObjs);
    const toolExecWithoutId = entityManager.create(ToolExecution, {
        project,
        tool,
        dependencyCount,
        vulnerabilityCount,
        durationMs: end - start,
        exitCode: 0,
    });
    const toolExec = await entityManager.save(ToolExecution, toolExecWithoutId);

    const depDict = await getDependencies(snykDepsReportPath, entityManager, toolExec);
    console.log(`${TOOL_NAME} - linking vulnerabilities with dependencies`);
    enrichDependenciesWithVulnerabilities(depDict, vulnObjs, entityManager, toolExec);

    console.log(`${TOOL_NAME} - saving dependencies and vulnerabilities to database`);
    let dependencies = _.values(depDict);
    dependencies = await saveDependencies(dependencies, entityManager);
    
    const depPaths = getUniqueDepPaths(dependencies);
    console.log(`${TOOL_NAME} - saving ${depPaths.length} dependency paths to database`);
    await entityManager.save(DependencyPath, depPaths, { chunk: 5000 });

    if (!config.SAVE_TOOL_RESULTS_TO_FILES) {
        fs.rmSync(snykDepsReportPath);
        fs.rmSync(snykVulnReportPath);
    }
}

function getReportedCounts(vulnObjs: SnykVulnObj[]) {
    let dependencyCount = 0;
    let vulnerabilityCount = 0;
    for (const vulnObj of vulnObjs) {
        dependencyCount += vulnObj.dependencyCount;
        vulnerabilityCount += vulnObj.vulnerabilities.length;
    }
    return { dependencyCount, vulnerabilityCount };
}

function getDependencies(depResultPath: string, entityManager: EntityManager, toolExec: ToolExecution) {
    const depDict: DepDict = {};
    const stream = fs.createReadStream(depResultPath, { encoding: 'utf-8' });
    const parser = JSONStream.parse('*');
    stream.pipe(parser);
    parser.on('data', (depObj: SnykDepObj) => {
        console.log(`${TOOL_NAME} - reading dependency information from JSON stream for project ${depObj.name}@${depObj.version}`);
        const currentPath = [getDepDictId(depObj.name, depObj.version)];
        getDependenciesRecursive(depObj.dependencies, depDict, currentPath, entityManager, toolExec);
    });
    
    return new Promise<DepDict>((resolve, reject) => {
        parser.on('close', () => {
            resolve(depDict);
        });
    });
}

function getDependenciesRecursive(
    snykDepDict: SnykDependencyDict,
    depsDict: DepDict,
    currentPath: string[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    for (const key in snykDepDict) {
        const snykDep = snykDepDict[key];
        const dictId = getDepDictId(snykDep.name, snykDep.version);
        const clonedCurrentPath = _.clone(currentPath);
        clonedCurrentPath.push(dictId);

        const depPath = entityManager.create(DependencyPath, {
            path: clonedCurrentPath.join(','),
        });

        if (depsDict[dictId]) {
            depsDict[dictId].dependencyPaths.push(depPath);
        } else {
            const pkg = entityManager.create(Package, {
                name: snykDep.name,
            });
            const dependency = entityManager.create(Dependency, {
                package: pkg,
                purl: getPurl(snykDep.name, snykDep.version),
                toolExecution,
                version: snykDep.version,
                vulnerabilities: [],
                dependencyPaths: [depPath],
            });
            depsDict[dictId] = dependency;
        }

        if (snykDep.dependencies) {
            getDependenciesRecursive(snykDep.dependencies, depsDict, clonedCurrentPath, entityManager, toolExecution)
        }
    }
}

function enrichDependenciesWithVulnerabilities(
    depDict: DepDict,
    vulnObjs: SnykVulnObj[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const vulnDict: VulnDict = {};
    for (const project of vulnObjs) {
        for (const snykVuln of project.vulnerabilities) {
            // Skip potential license issues
            if (snykVuln.type === 'license') {
                continue;
            }
            let vulnerability = vulnDict[snykVuln.id];
            if (!vulnerability) {
                vulnerability = createVulnerability(snykVuln, entityManager, toolExecution);
                vulnDict[snykVuln.id] = vulnerability;
            }
            const depId = getDepDictId(snykVuln.name, snykVuln.version);
            const dependency = depDict[depId];
            dependency.vulnerabilities.push(vulnerability);
            if (dependency.vulnerabilities.length > 1) {
                dependency.vulnerabilities = _.uniqBy(dependency.vulnerabilities, 'internalId');
            }
            if (!assertDependencyPathExistence(snykVuln, dependency)) {
                console.log(`${TOOL_NAME} - Not all dependency paths were collected`);
                fs.writeFileSync('error.json', JSON.stringify({ dependency, snykVuln }));
                throw new Error(`${TOOL_NAME} - Dependency path error`);
            }
        }
    }
}

function createVulnerability(snykVuln: SnykVulnerability, entityManager: EntityManager, toolExecution: ToolExecution) {
    return entityManager.create(Vulnerability, {
        ...getCvssInfo(snykVuln),
        cwe: getCwe(snykVuln),
        cve: getCve(snykVuln),
        description: snykVuln.description,
        internalId: snykVuln.id,
        npmId: getNpmId(snykVuln),
        ghsaId: getGhsaId(snykVuln),
        severity: snykVuln.severity,
        source: 'snyk',
        vulnerableVersionRange: snykVuln.semver.vulnerable.join(' || '),
        toolExecution,
    });
}

function assertDependencyPathExistence(snykVuln: SnykVulnerability, dep: Dependency) {
    return !!dep.dependencyPaths.find((depPath) => _.isEqual(snykVuln.from, depPath.path.split(',')));
}

function getNpmId(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.NSP?.length ? snykVuln.identifiers.NSP[0].toString() : undefined;
}

function getGhsaId(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.GHSA?.length ? snykVuln.identifiers.GHSA[0] : undefined;
}

function getCve(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.CVE.length ? snykVuln.identifiers.CVE[0] : undefined;
}

function getCwe(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.CWE.length ? snykVuln.identifiers.CWE[0] : undefined;
}

function getCvssInfo(snykVuln: SnykVulnerability) {
    const cvssVersionRegex = /^CVSS:(\d\.\d)/;
    const cvssVersionMatch = snykVuln.CVSSv3.match(cvssVersionRegex);
    return {
        cvssScore: snykVuln.cvssScore,
        cvssVector: snykVuln.CVSSv3,
        cvssVersion: cvssVersionMatch ? cvssVersionMatch[1] : undefined,
    };
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
};

runScanIfFork(runScan);
