import { execSync, spawn } from 'child_process';
import path from 'path';
import { DetectionToolFunction } from '../interfaces/types';
import { getDefaultPurl, getDetectionToolBase, handleErrorsAndPromisify } from './util';
import perfHooks from 'perf_hooks';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ToolExecution } from '../entities/toolExecution';
import { Dependency } from '../entities/dependency';
import { DependencyPath } from '../entities/dependencyPath';
import { Package } from '../entities/package';
import { Vulnerability } from '../entities/vulnerability';
const JSONStream = require('JSONStream');
const performance = perfHooks.performance;

const TOOL_NAME = 'snyk';

interface SnykDepObj {
    hasDevDependencies: boolean;
    name: string;
    size: number;
    version: string;
    meta: {
        nodeVersion: string;
        lockfileVersion: number;
        packageManager: string;
    }
    dependencies: SnykDependencyDict;
}

interface SnykDependencyDict {
    [name: string]: SnykDependency;
}

interface SnykDependency {
    labels: {
        scope: string;
    };
    name: string;
    version: string;
    dependencies?: SnykDependencyDict;
}

interface SnykVulnObj {
    vulnerabilities: SnykVulnerability[];
    ok: boolean;
    dependencyCount: number;
    org: string;
    policy: string;
    isPrivate: boolean;
    licensesPolicy: {
        severities: {};
        orgLicenseRules: {
            [name: string]: {
                licenseType: string;
                severity: string;
                instructions: string;
            }
        }
    };
    packageManager: string;
    ignoreSettings: any | null;
    summary: string;
    remediation: {
        unresolved: SnykVulnerability[];
        upgrade: {};
        patch: {};
        ignore: {};
        pin: {};
    }
    filesystemPolicy: boolean;
    filtered: {
        ignore: any[];
        patch: any[];
    };
    uniqueCount: number;
    projectName: string;
    displayTargetFile: string;
    path: string;
}

interface SnykFunction {
    functionId: {
        className?: string | null;
        filePath: string;
        functionName: string;
    };
    version: string[];
}

interface SnykVulnerability {
    type?: string;
    CVSSv3: string;
    alternativeIds: string[];
    creationTime: string;
    credit: string[];
    cvssScore: number;
    description: string;
    disclosureTime: string;
    exploit: string;
    fixedIn: string[];
    functions: SnykFunction[];
    functions_new: SnykFunction[];
    id: string;
    identifiers: {
      CVE: string[];
      CWE: string[];
      GHSA?: string[];
      NSP?: number[];
      ALTERNATIVE?: string[];
    },
    language: string;
    modificationTime: string;
    moduleName: string;
    packageManager: string;
    packageName: string;
    patches: {
        comments: any[];
        id: string;
        modificationTime: string;
        urls: string[];
        version: string;
    }[];
    proprietary: boolean;
    publicationTime: string;
    references: {
        title: string;
        url: string;
    }[];
    semver: {
      vulnerable: string[];
    };
    severity: string;
    severityWithCritical: string;
    socialTrendAlert: boolean;
    title: string;
    from: string[];
    upgradePath: [boolean, ...string[]];
    isUpgradable: boolean;
    isPatchable: boolean;
    name: string;
    version: string;
}

async function getDetectionTool() {
    const version = execSync('snyk -v').toString().trim();
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs, tool) => {
    const snykDepsReportTmpPath = path.join(resultsPath, 'tmp-snykDeps.json');
    const snykDepsReportPath = path.join(resultsPath, 'snykDeps.json');
    const snykVulnReportPath = path.join(resultsPath, 'snykVuln.json');

    // Save snyk results to file and print dependencies
    // This will unfortunately print dependencies for different subprojects independently instead of an array
    // This also prints out the vulnerabilities which are already saved to a file
    const snykCmd = `snyk test --all-projects --detection-depth=1000 --dev --print-deps --json --json-file-output=${snykVulnReportPath}`;
    // Add commas between different dependency JSON objects
    const perlCmd = String.raw`perl -0pe 's/^\}\n\{\n/\},\n\{\n/gms'`;
    // Remove vulnerability info and turn comma separated JSON objects into an array
    const sedVulnCmd = String.raw`sed '/^}$/q'`;
    const sedArraifyCmd = String.raw`sed -e '1 i\[' -e '$a]'`;
    const cmd = `${snykCmd} > ${snykDepsReportTmpPath}; cat ${snykDepsReportTmpPath} | ${perlCmd} | ${sedVulnCmd} | ${sedArraifyCmd} > ${snykDepsReportPath} && rm ${snykDepsReportTmpPath}`;
    const start = performance.now();
    const child = spawn(cmd, { cwd: projectPath, shell: true });
    await handleErrorsAndPromisify(child, project, tool);
    const end = performance.now();
    console.log(`${TOOL_NAME} - Reading vulnerability results from disk to memory`);
    const vulnObjs: SnykVulnObj[] = JSON.parse(fs.readFileSync(snykVulnReportPath).toString());
    const { dependencyCount, vulnerabilityCount } = getReportedCounts(vulnObjs);
    const entityManager = getManager();
    const toolExecWithoutId = entityManager.create(ToolExecution, {
        project,
        tool,
        dependencyCount,
        vulnerabilityCount,
        durationMs: end - start,
        exitCode: 0,
    });
    const toolExec = await entityManager.save(ToolExecution, toolExecWithoutId);
    const {depDict, depPathDict } = await getDependencies(snykDepsReportPath, entityManager, toolExec);
    console.log(`${TOOL_NAME} - linking vulnerabilities with dependencies`);
    enrichDependenciesWithVulnerabilities(depDict, depPathDict, vulnObjs, entityManager, toolExec);

    console.log(`${TOOL_NAME} - saving results to database`);
    const dependencies = _.values(depDict);
    await entityManager.save(Dependency, dependencies);
    const depPaths = _.flatten(_.values(depPathDict));
    await entityManager.save(DependencyPath, depPaths);
    
}

function getReportedCounts(vulnObjs: SnykVulnObj[]) {
    let dependencyCount = 0;
    let vulnerabilityCount = 0;
    for (const vulnObj of vulnObjs) {
        dependencyCount += vulnObj.dependencyCount;
        vulnerabilityCount += vulnObj.uniqueCount;
    }
    return { dependencyCount, vulnerabilityCount };
}

interface Dict<T> {
    [id: string]: T;
}

type DepsDict = Dict<Dependency>;
type VulnDict = Dict<Vulnerability>;
type DepPathDict = Dict<DependencyPath[]>;

function createDepsDictId(name: string, version: string) {
    return `${name}@${version}`;
}

function getDependencies(depResultPath: string, entityManager: EntityManager, toolExec: ToolExecution) {
    const depDict: DepsDict = {};
    const depPathDict: DepPathDict = {};
    const stream = fs.createReadStream(depResultPath, { encoding: 'utf-8' });
    const parser = JSONStream.parse('*');
    stream.pipe(parser);
    parser.on('data', (depObj: SnykDepObj) => {
        console.log(`${TOOL_NAME} - reading dependency information from JSON stream for project ${depObj.name}@${depObj.version}`);
        const currentPath = [createDepsDictId(depObj.name, depObj.version)];
        getDependenciesRecursive(depObj.dependencies, depDict, depPathDict, currentPath, entityManager, toolExec);
    });
    
    return new Promise<{depDict: DepsDict, depPathDict: DepPathDict}>((resolve, reject) => {
        parser.on('close', () => {
            resolve({depDict, depPathDict});
        });
    });
}

function getDependenciesRecursive(
    snykDepDict: SnykDependencyDict,
    depsDict: DepsDict,
    depPathDict: DepPathDict,
    currentPath: string[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    for (const key in snykDepDict) {
        const snykDep = snykDepDict[key];
        const dictId = createDepsDictId(snykDep.name, snykDep.version);
        const clonedCurrentPath = _.clone(currentPath);
        clonedCurrentPath.push(dictId);
        if (depsDict[dictId]) {
            const depPath = entityManager.create(DependencyPath, {
                dependency: depsDict[dictId],
                path: clonedCurrentPath.join(','),
            });
            if (!depPathDict[dictId].find((depP) => depP.path === depPath.path)) {
                depPathDict[dictId].push(depPath);
            }
        } else {
            const pkg = entityManager.create(Package, {
                name: snykDep.name,
            });
            const dependency = entityManager.create(Dependency, {
                package: pkg,
                purl: getDefaultPurl(snykDep.name, snykDep.version),
                toolExecution,
                version: snykDep.version,
                vulnerabilities: [],
            });
            depsDict[dictId] = dependency;
            const depPath = entityManager.create(DependencyPath, {
                path: clonedCurrentPath.join(','),
                dependency,
            });
            depPathDict[dictId] = [depPath];
        }

        if (snykDep.dependencies) {
            getDependenciesRecursive(snykDep.dependencies, depsDict, depPathDict, clonedCurrentPath, entityManager, toolExecution)
        }
    }
}

function enrichDependenciesWithVulnerabilities(
    depDict: DepsDict,
    depPathDict: DepPathDict,
    vulnObjs: SnykVulnObj[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const vulnDict: VulnDict = {};
    for (const project of vulnObjs) {
        for (const snykVuln of project.vulnerabilities) {
            // Skip potential license issues
            if (snykVuln.type === 'license') {
                continue;
            }
            let vulnerability: Vulnerability | undefined = vulnDict[snykVuln.id];
            if (!vulnerability) {
                const cvssObj = getCvssInfo(snykVuln);
                const cwe = getCwe(snykVuln);
                const cve = getCve(snykVuln);
                vulnerability = entityManager.create(Vulnerability, {
                    ...cvssObj,
                    cwe,
                    cve,
                    description: snykVuln.description,
                    internalId: snykVuln.id,
                    severity: snykVuln.severity,
                    source: 'snyk',
                    vulnerableVersionRange: snykVuln.semver.vulnerable.join(' || '),
                    toolExecution,
                });
                vulnDict[snykVuln.id] = vulnerability;
                
            }
            const depId = createDepsDictId(snykVuln.name, snykVuln.version);
            const dependency = depDict[depId];
            dependency.vulnerabilities.push(vulnerability);
            if (dependency.vulnerabilities.length > 1) {
                dependency.vulnerabilities = _.uniqBy(dependency.vulnerabilities, 'internalId');
            }
            if (!assertDependencyPathExistence(snykVuln, depPathDict[depId])) {
                console.log('Not all dependency paths were collected');
                fs.writeFileSync('error.json', JSON.stringify({ dependency, snykVuln }));
                throw new Error('Dependency path error');
            }
        }
    }
}

function assertDependencyPathExistence(snykVuln: SnykVulnerability, depPaths: DependencyPath[]) {
    return !!depPaths.find((depPath) => _.isEqual(snykVuln.from, depPath.path.split(',')));
}

function getCve(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.CVE.length ? snykVuln.identifiers.CVE[0] : undefined;
}

function getCwe(snykVuln: SnykVulnerability) {
    return snykVuln.identifiers.CWE.length ? snykVuln.identifiers.CWE[0] : undefined;
}

function getCvssInfo(snykVuln: SnykVulnerability) {
    const cvssVersionRegex = /^CVSS:(\d\.\d)/;
    const cvssVersionMatch = snykVuln.CVSSv3.match(cvssVersionRegex);
    return {
        cvssScore: snykVuln.cvssScore,
        cvssVector: snykVuln.CVSSv3,
        cvssVersion: cvssVersionMatch ? cvssVersionMatch[1] : undefined,
    };
}

export default {
    runScan,
    getDetectionTool,
};
