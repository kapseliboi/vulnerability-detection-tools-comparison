import { DetectionToolFunction } from '../interfaces/types';
import path from 'path';
import util from 'util';
import { exec, spawn } from 'child_process';
import { buildDepTreeFromFiles, PkgTree } from 'snyk-nodejs-lockfile-parser';
import {
    DepDict,
    getPurl,
    getDepDictId,
    getDetectionToolBase,
    getUniqueDepPaths,
    handleErrorsAndPromisify,
    VulnerabilityWithDepName,
    enrichDependenciesWithVulnerabilities,
    getJsDomFromUrl,
    runScanIfFork,
    saveDependencies,
} from './util';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import { saveToDbWithErrorHandling } from '../util';
import { Dependency } from '../entities/dependency';
import { DependencyPath } from '../entities/dependencyPath';
import { Package } from '../entities/package';
import { ToolExecution } from '../entities/toolExecution';
import perfHooks from 'perf_hooks';
import { Vulnerability } from '../entities/vulnerability';
import config from '../config';
import { ManualReview } from '../entities/manualReview';
const execAsync = util.promisify(exec);
const performance = perfHooks.performance;

const readFile = util.promisify(fs.readFile);
const TOOL_NAME = 'npm';

interface NpmListRootObject {
    version: string;
    name: string;
    dependencies: NpmListDependencyObject
}
interface NpmListDependencyObject {
    [name: string]: {
        version?: string;
        resolved?: string;
        dependencies?: NpmListDependencyObject;
    }
}

interface NpmAuditVulnerability {
    name: string;
    severity: string;
    via: {
        source: number;
        name: string;
        dependency: string;
        title: string;
        url: string;
        severity: string;
        range: string;
    }[] | string;
    effects: string[];
    range: string;
    nodes: string[];
    fixAvailable: boolean;
}

interface NpmAuditObject {
    auditReportVersion: number;
    vulnerabilities: {
        [name: string]: NpmAuditVulnerability;
    };
    metadata: {
        vulnerabilities: {
          info: number;
          low: number;
          moderate: number;
          high: number;
          critical: number;
          total: number;
        },
        dependencies: {
          prod: number;
          dev: number;
          optional: number;
          peer: number;
          peerOptional: number;
          total: number;
        }
    }
}

async function getDetectionTool() {
    const version = (await execAsync('npm -v')).stdout.trim();
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool) => {
    let cmd = ':';
    const entityManager = getManager();
    const depFilePaths: string[] = [];
    const vulnFilePaths: string[] = [];
    const npmRawResultsPath = path.join(resultsPath, 'npmAuditRaw');
    ensureDirExists(npmRawResultsPath);
    for (let i = 0; i < lockfileDirs.length; ++i) {
        const npmAuditDepsPath = path.join(npmRawResultsPath, `npmAuditDeps${i}.json`);
        const npmAuditVulnPath = path.join(npmRawResultsPath, `npmAuditVuln${i}.json`);
        depFilePaths.push(npmAuditDepsPath);
        vulnFilePaths.push(npmAuditVulnPath);
        const dir = lockfileDirs[i];
        cmd = `${cmd}; cd ${dir}; npm ls -a --json > ${npmAuditDepsPath} || true; npm audit --json > ${npmAuditVulnPath} || true`;
    }
    const start = performance.now();
    const child = spawn(cmd, { cwd: projectPath, shell: true });
    await handleErrorsAndPromisify(child, project, tool, entityManager);
    const end = performance.now();
    console.log(`${TOOL_NAME} - Reading results from disk`);
    const depPromises: Promise<Buffer>[] = [];
    const auditPromises: Promise<Buffer>[] = [];
    for (let i = 0; i < lockfileDirs.length; ++i) {
        depPromises.push(readFile(depFilePaths[i]));
        auditPromises.push(readFile(vulnFilePaths[i]));
    }
    let depObjects: NpmListRootObject[];
    let vulnObjects: NpmAuditObject[];
    try {
        depObjects = (await Promise.all(depPromises)).map((val) => JSON.parse(val.toString()));
        vulnObjects = (await Promise.all(auditPromises)).map((val) => JSON.parse(val.toString()));
    } catch (err) {
        const projectError = entityManager.create(ProjectError, {
            phase: 'DEPS/VULN',
            project,
            detectionTool: tool,
            message: 'Failed to read npm list and audit generated files',
        });
        await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        throw err;
    }

    /* npm ls only lists installed dependencies but npm audit uses all dependencies found in the lockfile as the basis for vulnerability analysis.
    This is why we need to get dependency trees which are 100% based on the lockfile as well. Most likely we would be okay by just using the
    dependency trees instead of the npm ls but for now we'll use both */
    const depTrees = await getDepTreesFromLockfileDirs(lockfileDirs);

    console.log(`${TOOL_NAME} - Getting and saving tool execution data to database`);

    const counts = getScanCounts(vulnObjects);

    const toolExecutionWithoutId = entityManager.create(ToolExecution, {
        durationMs: end - start,
        exitCode: 0,
        project,
        tool,
        ...counts,
    });

    const toolExecution = await entityManager.save(ToolExecution, toolExecutionWithoutId);

    console.log(`${TOOL_NAME} - Extracting dependencies from dependency data`);
    let dependencies = await getDependencies(depObjects, depTrees, entityManager, toolExecution);
    console.log(`${TOOL_NAME} - Extracting vulnerability data from results`);
    let vulns = await getVulnerabilities(vulnObjects, entityManager, toolExecution);
    console.log(`${TOOL_NAME} - Saving ${vulns.length} vulnerabilities to database`);
    vulns = await entityManager.save(Vulnerability, vulns, { chunk: 5000 });
    console.log(`${TOOL_NAME} - Matching dependencies with vulnerabilities`);
    const unmatchedVulnerabilities = enrichDependenciesWithVulnerabilities(dependencies, vulns);
    await createManualReviewsForUnmatchedVulnerabilities(unmatchedVulnerabilities, entityManager, toolExecution);

    console.log(`${TOOL_NAME} - Saving ${dependencies.length} dependencies and links to vulnerabilities to database`);
    dependencies = await saveDependencies(dependencies, entityManager);

    const depPaths = getUniqueDepPaths(dependencies);
    console.log(`${TOOL_NAME} - saving ${depPaths.length} dependency paths to database`);
    await entityManager.save(DependencyPath, depPaths, { chunk: 5000 });

    if (!config.SAVE_TOOL_RESULTS_TO_FILES) {
        fs.rmSync(npmRawResultsPath, { recursive: true });
    }
}

function getScanCounts(vulnObjs: NpmAuditObject[]) {
    let dependencyCount = 0;
    let vulnerabilityCount = 0;
    for (const vulnObj of vulnObjs) {
        dependencyCount += vulnObj.metadata.dependencies.total;
        vulnerabilityCount += vulnObj.metadata.vulnerabilities.total;
    }
    return {
        dependencyCount,
        vulnerabilityCount,
    };
}

function ensureDirExists(dir: string) {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
}

async function getDependencies(
    depObjects: NpmListRootObject[],
    depTrees: PkgTree[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const depDict: DepDict = {};
    for (const depObj of depObjects) {
        const currentPath = [getDepDictId(depObj.name, depObj.version)];
        const deps = depObj.dependencies;
        addDependenciesToDepDict(
            deps,
            depDict,
            currentPath,
            entityManager,
            toolExecution,
        );
    }

    // This will result in duplicate dependency paths
    for (const depTree of depTrees) {
        if (!depTree.name || !depTree.version) {
            console.log(`${TOOL_NAME} - Found a lockfile without name or version when analyzing project ${toolExecution.project.name}. This is a non-issue if no vulnerabilities were found in the missing dependencies`);
            const mRev = entityManager.create(ManualReview, {
                toolExecution,
                reason: 'NPM lockfile without name or version',
            });
            await entityManager.save(ManualReview, mRev);
            continue;
        }
        const currentPath = [getDepDictId(depTree.name, depTree.version)];
        addDependenciesToDepDict(
            depTree.dependencies,
            depDict,
            currentPath,
            entityManager,
            toolExecution,
        );
    }

    return _.sortBy(
        _.values(depDict),
        [(dep) => dep.package.name, 'version'],
    );
}

function addDependenciesToDepDict(
    depObj: NpmListDependencyObject | PkgTree['dependencies'],
    depDict: DepDict,
    currentPath: string[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    for (const key in depObj) {
        const dep = depObj[key];
        if (!dep.version) {
            continue;
        }
        const dictId = getDepDictId(key, dep.version);
        const clonedCurrentPath = _.clone(currentPath);
        clonedCurrentPath.push(dictId);

        const depPath = entityManager.create(DependencyPath, {
            path: clonedCurrentPath.join(','),
        });

        if (depDict[dictId]) {
            depDict[dictId].dependencyPaths.push(depPath);
        } else {
            const pkg = entityManager.create(Package, {
                name: key,
            });
            const dependency = entityManager.create(Dependency, {
                package: pkg,
                purl: getPurl(key, dep.version),
                version: dep.version,
                vulnerabilities: [],
                dependencyPaths: [depPath],
                toolExecution,
            });
            depDict[dictId] = dependency;
        }

        if (dep.dependencies) {
            addDependenciesToDepDict(
                dep.dependencies,
                depDict,
                clonedCurrentPath,
                entityManager,
                toolExecution,
            );
        }
    }
}

function getDepTreesFromLockfileDirs(lockfileDirs: string[]) {
    const pkgTreePromises: Promise<PkgTree>[] = [];
    for (const dir of lockfileDirs) {
        pkgTreePromises.push(buildDepTreeFromFiles(dir, 'package.json', 'package-lock.json', true));
    }
    return Promise.all(pkgTreePromises);
}

async function getVulnerabilities(
    vulnObjects: NpmAuditObject[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const arr: VulnerabilityWithDepName[] = [];
    for (const vulnObj of vulnObjects) {
        for (const key in vulnObj.vulnerabilities) {
            const npmVuln = vulnObj.vulnerabilities[key];
            for (const via of npmVuln.via) {
                if (
                    typeof via === 'object' &&
                    !arr.find((vul) => vul.internalId === via.source.toString())
                ) {
                    const vulnerability = {
                        ...entityManager.create(Vulnerability, {
                            ...(await getCveAndGhsa(via.url)),
                            description: via.title,
                            internalId: via.source.toString(),
                            npmId: via.source.toString(),
                            toolExecution,
                            source: 'NPM',
                            severity: via.severity,
                        }),
                        vulnerableVersionRange: via.range,
                        name: via.name,
                    };
                    arr.push(vulnerability);
                }
            }
        }
    }
    return _.sortBy(_.uniqBy(arr, 'internalId'), ['name']);
}

async function getCveAndGhsa(url: string) {
    const dom = await getJsDomFromUrl(url, TOOL_NAME);
    const nodeList = dom.window.document.querySelectorAll<HTMLAnchorElement>(
        'h2+div.markdown > ul > li > a'
    );
    const cveRegex = /CVE-\d{4}-\d{4,}/;
    const ghsaRegex = /GHSA-\w+-\w+-\w+/;
    let cve: string | undefined = undefined;
    let ghsaId: string | undefined = undefined;
    for (let i = 0; i < nodeList.length; ++i) {
        const node = nodeList[i];
        if (node.textContent === 'CVE') {
            const cveMatch = node.href.match(cveRegex);
            if (cveMatch && !cve) {
                cve = cveMatch[0];
            }
        } else if (node.textContent === 'GitHub Advisory') {
            const ghsaMatch = node.href.match(ghsaRegex);
            if (ghsaMatch && ! ghsaId) {
                ghsaId = ghsaMatch[0];
            }
        }
    }
    return {
        cve,
        ghsaId,
    };
}

async function createManualReviewsForUnmatchedVulnerabilities(
    vulns: VulnerabilityWithDepName[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const manualReviews: ManualReview[] = [];
    for (const vuln of vulns) {
        console.log(`${TOOL_NAME} - Found vulnerability without a corresponding dependency: ${JSON.stringify(vuln)}`);
        const manualReview = entityManager.create(ManualReview, {
            data: JSON.stringify(vuln),
            toolExecution,
            reason: `Couldn't link vulnerability to a dependency. This is most likely caused by unmet optional dependencies`,
        });
        manualReviews.push(manualReview);
    }
    await entityManager.save(ManualReview, manualReviews);
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
}

runScanIfFork(runScan);
