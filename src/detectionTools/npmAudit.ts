import { DetectionToolFunction } from '../interfaces/types';
import path from 'path';
import util from 'util';
import { execSync, spawn } from 'child_process';
import { getDefaultPurl, getDetectionToolBase, handleErrorsAndPromisify } from './util';
import fs from 'fs';
import semver from 'semver';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import { saveToDbWithErrorHandling } from '../util';
import { Dependency } from '../entities/dependency';
import { DependencyPath } from '../entities/dependencyPath';
import { Package } from '../entities/package';
import { ToolExecution } from '../entities/toolExecution';
import perfHooks from 'perf_hooks';
import { Vulnerability } from '../entities/vulnerability';
import axios from 'axios';
import parse5 from 'parse5';
import xmlserializer from 'xmlserializer';
import xmldom from 'xmldom';
const performance = perfHooks.performance;

const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const TOOL_NAME = 'npm';

interface NpmListRootObject {
    version: string;
    name: string;
    dependencies: NpmListDependencyObject
}
interface NpmListDependencyObject {
    [name: string]: {
        version: string;
        resolved?: string;
        dependencies?: NpmListDependencyObject;
    }
}

interface OldDependency {
    name: string;
    version: string;
    resolved: string;
}

interface NpmAuditVulnerability {
    name: string;
    severity: string;
    via: {
        source: number;
        name: string;
        dependency: string;
        title: string;
        url: string;
        severity: string;
        range: string;
    }[] | string;
    effects: string[];
    range: string;
    nodes: string[];
    fixAvailable: boolean;
}

interface NpmAuditVulnerabilityWithVersion extends NpmAuditVulnerability {
    versions?: string[];
}

interface NpmAuditObject {
    auditReportVersion: number;
    vulnerabilities: {
        [name: string]: NpmAuditVulnerability;
    };
    metadata: {
        vulnerabilities: {
          info: number;
          low: number;
          moderate: number;
          high: number;
          critical: number;
          total: number;        },
        dependencies: {
          prod: number;
          dev: number;
          optional: number;
          peer: number;
          peerOptional: number;
          total: number;
        }
    }
}

async function getDetectionTool() {
    const version = execSync('npm -v').toString().trim();
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs, tool) => {
    let cmd = ':';
    const entityManager = getManager();
    const depFilePaths: string[] = [];
    const vulnFilePaths: string[] = [];
    const npmRawResultsPath = path.join(resultsPath, 'npmAuditRaw');
    ensureDirExists(npmRawResultsPath);
    for (let i = 0; i < packageJsonDirs.length; ++i) {
        const npmAuditDepsPath = path.join(npmRawResultsPath, `npmAuditDeps${i}.json`);
        const npmAuditVulnPath = path.join(npmRawResultsPath, `npmAuditVuln${i}.json`);
        depFilePaths.push(npmAuditDepsPath);
        vulnFilePaths.push(npmAuditVulnPath);
        const dir = packageJsonDirs[i];
        cmd = `${cmd}; cd ${dir}; npm ls -a --json > ${npmAuditDepsPath} || true; npm audit --json > ${npmAuditVulnPath} || true`;
    }
    const start = performance.now();
    const child = spawn(cmd, { cwd: projectPath, shell: true });
    await handleErrorsAndPromisify(child, project, tool);
    const end = performance.now();
    const depPromises: Promise<Buffer>[] = [];
    const auditPromises: Promise<Buffer>[] = [];
    for (let i = 0; i < packageJsonDirs.length; ++i) {
        depPromises.push(readFile(depFilePaths[i]));
        auditPromises.push(readFile(vulnFilePaths[i]));
    }
    let depObjects: NpmListRootObject[];
    let vulnObjects: NpmAuditObject[];
    try {
        depObjects = (await Promise.all(depPromises)).map((val) => JSON.parse(val.toString()));
        vulnObjects = (await Promise.all(auditPromises)).map((val) => JSON.parse(val.toString()));
    } catch (err) {
        const projectError = entityManager.create(ProjectError, {
            phase: 'DEPS/VULN',
            project,
            detectionTool: tool,
            message: 'Failed to read npm list and audit generated files',
        });
        await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        throw err;
    }

    const counts = getScanCounts(vulnObjects);

    const toolExecution = entityManager.create(ToolExecution, {
        durationMs: end - start,
        exitCode: 0,
        project,
        tool,
        ...counts,
    });

    const depDict = mergeDependenciesAndConvertToArray(depObjects, entityManager, toolExecution);
    const mergedVulns = mergeVulnerabilitiesAndConvertToArray(vulnObjects);
    await writeFile(path.join(resultsPath, 'npmAuditDeps.json'), JSON.stringify(mergedDeps, null, 2));
    await writeFile(path.join(resultsPath, 'npmAuditVulnTest.json'), JSON.stringify(mergedVulns, null, 2));
    console.log(`${TOOL_NAME} - Enriching vulnerabilities with version information`);
    const vulnsWithVersionInfo = enrichVulnerabilitiesWithVersionInfo(mergedDeps, mergedVulns);
    console.log(`${TOOL_NAME} - Writing final results to disk`);
    await writeFile(path.join(resultsPath, 'npmAuditVuln.json'), JSON.stringify(vulnsWithVersionInfo, null, 2));
}

function getScanCounts(vulnObjs: NpmAuditObject[]) {
    let dependencyCount = 0;
    let vulnerabilityCount = 0;
    for (const vulnObj of vulnObjs) {
        dependencyCount += vulnObj.metadata.dependencies.total;
        vulnerabilityCount += vulnObj.metadata.vulnerabilities.total;
    }
    return {
        dependencyCount,
        vulnerabilityCount,
    };
}

function ensureDirExists(dir: string) {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
}

interface DepDict {
    [id: string]: Dependency;
}

function getDepDictId(name: string, version: string) {
    return `${name}@${version}`;
}


function mergeDependenciesAndConvertToArray(depObjects: NpmListRootObject[], entityManager: EntityManager, toolExecution: ToolExecution) {
    const depDict: DepDict = {};
    for (const depObj of depObjects) {
        const currentPath = [getDepDictId(depObj.name, depObj.version)];
        const deps = depObj.dependencies;
        addDependenciesToArray(deps, depDict, currentPath, entityManager, toolExecution);
    }
    return depDict;
    return _.sortBy(
        _.uniqWith(depArray, (a, b) => a.name === b.name && a.version === b.version && a.resolved === b.resolved),
        ['name', 'version'],
    );
}

function addDependenciesToArray(depObj: NpmListDependencyObject, depDict: DepDict, currentPath: string[], entityManager: EntityManager, toolExecution: ToolExecution) {
    for (const key in depObj) {
        const dep = depObj[key];
        const dictId = getDepDictId(key, dep.version);
        const clonedCurrentPath = _.clone(currentPath);
        clonedCurrentPath.push(dictId);

        const depPath = entityManager.create(DependencyPath, {
            path: clonedCurrentPath.join(',');
        });

        if (depDict[dictId]) {
            depDict[dictId].dependencyPaths.push(depPath);
        } else {
            const pkg = entityManager.create(Package, {
                name: key,
            });
            const dependency = entityManager.create(Dependency, {
                package: pkg,
                purl: getDefaultPurl(key, dep.version),
                version: dep.version,
                vulnerabilities: [],
                dependencyPaths: [depPath],
            });
            depDict[dictId] = dependency;
        }

        if (dep.dependencies) {
            addDependenciesToArray(dep.dependencies, depDict, clonedCurrentPath, entityManager, toolExecution);
        }
    }
}

async function mergeVulnerabilitiesAndConvertToArray(vulnObjects: NpmAuditObject[], entityManager: EntityManager, toolExecution: ToolExecution) {
    const arr: Vulnerability[] = [];
    for (const vulnObj of vulnObjects) {
        for (const key in vulnObj.vulnerabilities) {
            const npmVuln = vulnObj.vulnerabilities[key];
            let vulnerableVersionRange = npmVuln.range;
            let internalId = undefined;
            let description = undefined;
            let cve = undefined;
            if (npmVuln.via.length === 1 && typeof npmVuln.via[0] === 'object') {
                const npmInfo = npmVuln.via[0];
                vulnerableVersionRange = npmInfo.range;
                internalId = npmInfo.source.toString();
                description = npmInfo.title;
                cve = await getCve(npmInfo.url);
            }
            const vulnerability = entityManager.create(Vulnerability, {
                cve,
                description,
                toolExecution,
                internalId,
                severity: npmVuln.severity,
                source: 'NPM',
                vulnerableVersionRange,
            });
            arr.push(vulnerability);
        }
    }
    return _.sortBy(arr, ['name']);
}

async function getCve(url: string) {
    const res = await axios.get(url);
    const parsedHtml = parse5.parse(res.data);
    const xmlSerializedHtml = xmlserializer.serializeToString(parsedHtml);
    const doc = new xmldom.DOMParser({ errorHandler: {
        warning: (w) => { return; },
        error: (err) => console.log(err),
        fatalError: (err) => console.log(err),
    }}).parseFromString(xmlSerializedHtml);
    const nodeList = doc.querySelectorAll('h2+div.markdown > ul > li > a');
    const cveRegex = /CVE-\d{4}-\d{4,}/;
    for (let i = 0; i < nodeList.length; ++i) {
        const node = nodeList[i];
        if (node.textContent === 'CVE') {
            const cveMatch = node.baseURI.match(cveRegex);
            if (cveMatch) {
                return cveMatch[0];
            }
        }
    }
    return undefined;
}

function enrichVulnerabilitiesWithVersionInfo(deps: OldDependency[], vulns: NpmAuditVulnerabilityWithVersion[]) {
    let i = 0;
    let k = 0;
    let multipleVulnerabilitiesInSameDep = false;
    let depIndexForMultipleVulnsInSameDep = 0;
    while (i < deps.length && k < vulns.length) {
        const vuln = vulns[k];
        const dep = deps[i];
        if (vuln.name === dep.name) {
            if (semver.satisfies(dep.version, vuln.range)) {
                if (vuln.versions) {
                    vuln.versions.push(dep.version);
                } else {
                    vuln.versions = [dep.version];
                }
            }
            ++i;
        } else if (dep.name > vuln.name) {
            if (!vuln.versions?.length) {
                throw new Error(`Npm audit version information missing for vulnerability ${JSON.stringify(vuln)} when dep ${JSON.stringify(dep)}`);
            }
            if (multipleVulnerabilitiesInSameDep) {
                multipleVulnerabilitiesInSameDep = false;
                i = depIndexForMultipleVulnsInSameDep;
            }
            ++k;
            if (k < vulns.length - 1 && vulns[k].name === vulns[k + 1].name) {
                multipleVulnerabilitiesInSameDep = true;
                depIndexForMultipleVulnsInSameDep = i;
            }
        } else {
            ++i;
        }
    }
    return vulns;
}

export default {
    runScan,
    getDetectionTool,
}
