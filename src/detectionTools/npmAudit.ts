import { DetectionToolFunction } from '../interfaces/types';
import path from 'path';
import util from 'util';
import { exec, spawn } from 'child_process';
import {
    DepDict,
    getPurl,
    getDepDictId,
    getDetectionToolBase,
    getUniqueDepPaths,
    handleErrorsAndPromisify,
    VulnerabilityWithDepName,
    enrichDependenciesWithVulnerabilities,
    getJsDomFromUrl,
    runScanIfFork,
    saveDependencies,
    getHashFromUrl,
} from './util';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import { saveToDbWithErrorHandling } from '../util';
import { Dependency } from '../entities/dependency';
import { DependencyPath } from '../entities/dependencyPath';
import { Package } from '../entities/package';
import { ToolExecution } from '../entities/toolExecution';
import perfHooks from 'perf_hooks';
import { Vulnerability } from '../entities/vulnerability';
import config from '../config';
import { ManualReview } from '../entities/manualReview';
const execAsync = util.promisify(exec);
const performance = perfHooks.performance;

const readFile = util.promisify(fs.readFile);
const TOOL_NAME = 'npm';

interface NpmListRootObject {
    version: string;
    name: string;
    dependencies: NpmListDependencyObject
}
interface NpmListDependencyObject {
    [name: string]: {
        version?: string;
        resolved?: string;
        dependencies?: NpmListDependencyObject;
    }
}

interface NpmAuditVulnerability {
    name: string;
    severity: string;
    via: {
        source: number;
        name: string;
        dependency: string;
        title: string;
        url: string;
        severity: string;
        range: string;
    }[] | string;
    effects: string[];
    range: string;
    nodes: string[];
    fixAvailable: boolean;
}

interface NpmAuditObject {
    auditReportVersion: number;
    vulnerabilities: {
        [name: string]: NpmAuditVulnerability;
    };
    metadata: {
        vulnerabilities: {
          info: number;
          low: number;
          moderate: number;
          high: number;
          critical: number;
          total: number;
        },
        dependencies: {
          prod: number;
          dev: number;
          optional: number;
          peer: number;
          peerOptional: number;
          total: number;
        }
    }
}

async function getDetectionTool() {
    const version = (await execAsync('npm -v')).stdout.trim();
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool, useResultFiles) => {
    let cmd = ':';
    const entityManager = getManager();
    const depFilePaths: string[] = [];
    const vulnFilePaths: string[] = [];
    const npmRawResultsPath = path.join(resultsPath, 'npmAuditRaw');
    ensureDirExists(npmRawResultsPath);
    for (let i = 0; i < lockfileDirs.length; ++i) {
        const npmAuditDepsPath = path.join(npmRawResultsPath, `npmAuditDeps${i}.json`);
        const npmAuditVulnPath = path.join(npmRawResultsPath, `npmAuditVuln${i}.json`);
        depFilePaths.push(npmAuditDepsPath);
        vulnFilePaths.push(npmAuditVulnPath);
        const dir = lockfileDirs[i];
        cmd = `${cmd}; cd ${dir}; npm ls -a --json --package-lock-only > ${npmAuditDepsPath} || true; npm audit --json > ${npmAuditVulnPath} || true`;
    }
    const start = performance.now();
    if (!useResultFiles) {
        const child = spawn(cmd, { cwd: projectPath, shell: true });
        await handleErrorsAndPromisify(child, project, tool, entityManager);
    }
    const end = performance.now();
    console.log(`${TOOL_NAME} - Reading results from disk`);
    const depPromises: Promise<Buffer>[] = [];
    const auditPromises: Promise<Buffer>[] = [];
    for (let i = 0; i < lockfileDirs.length; ++i) {
        depPromises.push(readFile(depFilePaths[i]));
        auditPromises.push(readFile(vulnFilePaths[i]));
    }
    let depObjects: NpmListRootObject[];
    let vulnObjects: NpmAuditObject[];
    try {
        depObjects = (await Promise.all(depPromises)).map((val) => JSON.parse(val.toString()));
        vulnObjects = (await Promise.all(auditPromises)).map((val) => JSON.parse(val.toString()));
    } catch (err) {
        const projectError = entityManager.create(ProjectError, {
            phase: 'DEPS/VULN',
            project,
            detectionTool: tool,
            message: 'Failed to read npm list and audit generated files',
        });
        await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        throw err;
    }

    console.log(`${TOOL_NAME} - Getting and saving tool execution data to database`);
    const counts = getScanCounts(vulnObjects);
    const toolExecutionWithoutId = entityManager.create(ToolExecution, {
        durationMs: end - start,
        exitCode: 0,
        project,
        tool,
        ...counts,
    });
    const toolExecution = await entityManager.save(ToolExecution, toolExecutionWithoutId);

    console.log(`${TOOL_NAME} - Extracting dependencies from dependency data`);
    let dependencies = await getDependencies(depObjects, entityManager, toolExecution);
    console.log(`${TOOL_NAME} - Extracting vulnerability data from results`);
    let vulns = await getVulnerabilities(vulnObjects, entityManager, toolExecution);
    console.log(`${TOOL_NAME} - Saving ${vulns.length} vulnerabilities to database`);
    vulns = await entityManager.save(Vulnerability, vulns, { chunk: 5000 });
    console.log(`${TOOL_NAME} - Matching dependencies with vulnerabilities`);
    const unmatchedVulnerabilities = enrichDependenciesWithVulnerabilities(dependencies, vulns);
    await createManualReviewsForUnmatchedVulnerabilities(unmatchedVulnerabilities, entityManager, toolExecution);

    console.log(`${TOOL_NAME} - Saving ${dependencies.length} dependencies and links to vulnerabilities to database`);
    dependencies = await saveDependencies(dependencies, entityManager);

    const depPaths = getUniqueDepPaths(dependencies);
    console.log(`${TOOL_NAME} - saving ${depPaths.length} dependency paths to database`);
    await entityManager.save(DependencyPath, depPaths, { chunk: 5000 });

    if (!config.SAVE_TOOL_RESULTS_TO_FILES) {
        fs.rmSync(npmRawResultsPath, { recursive: true });
    }
}

function getScanCounts(vulnObjs: NpmAuditObject[]) {
    let dependencyCount = 0;
    let vulnerabilityCount = 0;
    for (const vulnObj of vulnObjs) {
        dependencyCount += vulnObj.metadata.dependencies.total;
        vulnerabilityCount += vulnObj.metadata.vulnerabilities.total;
    }
    return {
        dependencyCount,
        vulnerabilityCount,
    };
}

function ensureDirExists(dir: string) {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
}

async function getDependencies(
    depObjects: NpmListRootObject[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const depDict: DepDict = {};
    let counter = 0;
    for (const depObj of depObjects) {
        ++counter;
        const currentPath = [getDepDictId(depObj.name || counter.toString(), depObj.version || '*')];
        const deps = depObj.dependencies;
        addDependenciesToDepDict(
            deps,
            depDict,
            currentPath,
            entityManager,
            toolExecution,
        );
    }

    return _.sortBy(
        _.values(depDict),
        [(dep) => dep.package.name, 'version'],
    );
}

function addDependenciesToDepDict(
    depObj: NpmListDependencyObject,
    depDict: DepDict,
    currentPath: string[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    for (const key in depObj) {
        const dep = depObj[key];
        let version: string;
        if (!dep.version) {
            if (!dep.resolved) {
                continue;
            }
            const hashFromVersion = getHashFromUrl(dep.resolved);
            version = hashFromVersion || dep.resolved;
            
        } else {
            version = dep.version;
        }
        const dictId = getDepDictId(key, version);
        const clonedCurrentPath = _.clone(currentPath);
        clonedCurrentPath.push(dictId);

        const depPath = entityManager.create(DependencyPath, {
            path: clonedCurrentPath.join(','),
        });

        if (depDict[dictId]) {
            depDict[dictId].dependencyPaths.push(depPath);
        } else {
            const pkg = entityManager.create(Package, {
                name: key,
            });
            const dependency = entityManager.create(Dependency, {
                package: pkg,
                purl: getPurl(key, version),
                version,
                vulnerabilities: [],
                dependencyPaths: [depPath],
                toolExecution,
            });
            depDict[dictId] = dependency;
        }

        if (dep.dependencies) {
            addDependenciesToDepDict(
                dep.dependencies,
                depDict,
                clonedCurrentPath,
                entityManager,
                toolExecution,
            );
        }
    }
}

async function getVulnerabilities(
    vulnObjects: NpmAuditObject[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const arr: VulnerabilityWithDepName[] = [];
    for (const vulnObj of vulnObjects) {
        for (const key in vulnObj.vulnerabilities) {
            const npmVuln = vulnObj.vulnerabilities[key];
            for (const via of npmVuln.via) {
                if (
                    typeof via === 'object' &&
                    !arr.find((vul) => vul.internalId === via.source.toString())
                ) {
                    const vulnerability = {
                        ...entityManager.create(Vulnerability, {
                            ...(await getCveGhsaCweAndCvss(via.url)),
                            description: via.title,
                            internalId: via.source.toString(),
                            npmId: via.source.toString(),
                            toolExecution,
                            source: 'NPM',
                            severity: via.severity,
                        }),
                        vulnerableVersionRange: via.range,
                        name: via.name,
                    };
                    arr.push(vulnerability);
                }
            }
        }
    }
    return _.sortBy(_.uniqBy(arr, 'internalId'), ['name']);
}

async function getCveGhsaCweAndCvss(url: string) {
    const dom = await getJsDomFromUrl(url, TOOL_NAME);
    const child = dom.window.document.querySelector<HTMLDivElement>('div.js-repository-advisory-details');
    if (!child) {
        return {};
    }
    const infoContainer = child.parentElement;
    const children = infoContainer?.children;
    if (!children) {
        return {};
    }
    const returnVal: Pick<Vulnerability, 'cvssScore' | 'cvssVector' | 'cvssVersion' | 'cwe' | 'cve' | 'ghsaId'> = {};
    const ghsaRegex = /GHSA-\w+-\w+-\w+/;
    const ghsaMatch = url.match(ghsaRegex);
    returnVal.ghsaId = ghsaMatch ? ghsaMatch[0] : undefined;
    const cvssVersionRegex = /^CVSS:(\d\.\d)/;
    for (let i = 0; i < children.length; ++i) {
        const childTexts = children[i].textContent?.trim().split('\n').map((text) => text.trim()).filter((text) => text.length);
        if (!childTexts || !childTexts.length) {
            continue;
        }
        const type = childTexts[0];
        if (type === 'CVE ID') {
            returnVal.cve = childTexts[1];
        } else if (type === 'CWEs') {
            returnVal.cwe = childTexts[1];
        } else if (type === 'CVSS Score') {
            returnVal.cvssScore = parseFloat(childTexts[1].split(' ')[0]);
            returnVal.cvssVector = childTexts[2];
            const cvssVersionMatch = returnVal.cvssVector.match(cvssVersionRegex);
            returnVal.cvssVersion = cvssVersionMatch ? cvssVersionMatch[1] : undefined;
        }
    }
    return returnVal;
}

async function createManualReviewsForUnmatchedVulnerabilities(
    vulns: VulnerabilityWithDepName[],
    entityManager: EntityManager,
    toolExecution: ToolExecution,
) {
    const manualReviews: ManualReview[] = [];
    for (const vuln of vulns) {
        console.log(`${TOOL_NAME} - Found vulnerability without a corresponding dependency: ${JSON.stringify(vuln)}`);
        const manualReview = entityManager.create(ManualReview, {
            data: JSON.stringify(vuln),
            toolExecution,
            reason: `Couldn't link vulnerability to a dependency. This is most likely caused by unmet optional dependencies`,
        });
        manualReviews.push(manualReview);
    }
    await entityManager.save(ManualReview, manualReviews);
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
}

runScanIfFork(runScan);
