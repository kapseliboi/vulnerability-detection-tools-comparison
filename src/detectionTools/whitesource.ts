import { DetectionToolFunction, GitHubApiIssue, GitHubApiIssuesResponse, Package } from '../interfaces/types';
import { gql } from 'graphql-request';
import { getGitHubGraphQlClient, saveToDbWithErrorHandling } from '../util';
import { EntityManager, getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import escapeStringRegexp from 'escape-string-regexp';
import { Project } from '../entities/project';
import axios from 'axios';
import xmldom from 'xmldom';
import parse5 from 'parse5';
import xmlserializer from 'xmlserializer';
import fs from 'fs';
import path from 'path';

const TOOL_NAME = 'WhiteSource Bolt';

const func: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs) => {
    const client = getGitHubGraphQlClient();
    const [owner, repo] = project.forkedName.split('/');
    const entityManager = getManager();
    let moreResults = true;
    let cursor = undefined;
    let nodes: GitHubApiIssuesResponse['search']['nodes'] = [];
    console.log(`Querying GitHub API for whitesource bolt issues`);
    while (moreResults) {
        const query = gql`
        query {
            search(query: "repo:${owner}/${repo} author:app/whitesource-bolt-for-github", type: ISSUE, first: 100${cursor ? ', after: "' + cursor + '"' : ''}) {
                nodes {
                    ... on Issue {
                        author {
                            login
                        }
                        bodyText
                        body
                        url
                    }
                }
                pageInfo {
                    endCursor
                    hasNextPage
                }
            }
        }`;
        const res: GitHubApiIssuesResponse = await client.request(query);
        nodes = nodes.concat(res.search.nodes);
        moreResults = res.search.pageInfo.hasNextPage;
        cursor = res.search.pageInfo.endCursor;
    }

    let results: any[] = [];

    for (const node of nodes) {
        if (!('bodyText' in node)) {
            continue;
        }
        const cve = getCveIdentifier(node.bodyText);
        if (!cve) {
            console.log(`Vulnerability doesn't have a CVE: ${node.url}`);
        }

        const severity = getSeverity(node.bodyText);
        if (!severity) {
            console.log(`Vulnerability doesn't have a severity rating ${node.url}`);
            throw new Error('Missing severity');
        }

        const cvss = getCvssScore(node.bodyText);
        if (!cvss) {
            console.log(`Vulnerability doesn't have a cvss score ${node.url}`);
        }

        const vulnerableLibraries = getVulnerableLibraries(node, entityManager, project);
        if (vulnerableLibraries.length === 0) {
            console.log(`Failed to extract package information from whitesource bolt issue ${node.url}`);
            const projectError = entityManager.create(ProjectError, {
                project: project,
                phase: 'DEPS/VULN',
                message: `Failed to extract package information from whitesource bolt issue ${node.url}`,
            });
            saveToDbWithErrorHandling(entityManager, ProjectError, projectError, `Failed to save error to database about a failure to extract package information from whitesource bolt issue ${node.url}`);
            continue;
        }

        const cwe = await getCwe(node, entityManager, project);
        if (!cwe) {
            console.log(`No CWE for ${node.url}`);
        }

        results = results.concat(vulnerableLibraries.map((lib) => ({
            cwe: cwe,
            cve: cve,
            cvss,
            severity,
            name: lib.name,
            version: lib.version,
        })));
    }
    fs.writeFileSync(path.join(resultsPath, 'whitesource.json'), JSON.stringify(results, null, 2));
}

function getCveIdentifier(bodyText: string): string | undefined {
    const cveRegex = /^CVE-\d{4}-\d{4,}/;
    const cveMatch = bodyText.match(cveRegex);
    return cveMatch ? cveMatch[0] : undefined;
}

function getSeverity(bodyText: string) {
    const severityRegex = /- (Low|Medium|High|Critical) Severity Vulnerability/;
    const severityMatch = bodyText.match(severityRegex);
    return severityMatch ? severityMatch[1] : undefined;
}

function getCvssScore(bodyText: string) {
    const cvssScoreRegex = /CVSS (\d+\.?\d*) Score Details \((\d+\.?\d*)\)/;
    const cvssScoreMatch = bodyText.match(cvssScoreRegex);
    return cvssScoreMatch ? { cvssVersion: cvssScoreMatch[1], score: cvssScoreMatch[2] } : undefined;
}

async function getCwe(issue: GitHubApiIssue, entityManager: EntityManager, project: Project) {
    const whiteSourceVulnDbUrlRegex = /href=(https:\/\/vuln.whitesourcesoftware.com\/vulnerability\/[\w-]+)/;

    const whiteSourceVulnDbUrlMatches = issue.body.match(whiteSourceVulnDbUrlRegex);
    if (!whiteSourceVulnDbUrlMatches || whiteSourceVulnDbUrlMatches.length < 2 || !whiteSourceVulnDbUrlMatches[1]) {
        return undefined;
    }
    const whiteSourceVulnDbUrl = whiteSourceVulnDbUrlMatches[1];
    const vulnDbHtml = await axios.get(whiteSourceVulnDbUrl);
    const parsedHtml = parse5.parse(vulnDbHtml.data);
    const xmlSerializedHtml = xmlserializer.serializeToString(parsedHtml);
    const doc = new xmldom.DOMParser({ errorHandler: {
        warning: (w) => { return; },
        error: (err) => console.log(err),
        fatalError: (err) => console.log(err),
    }}).parseFromString(xmlSerializedHtml);
    const elems = doc.getElementsByClassName('col-xl-4');
    for (let i = 0; i < elems.length; ++i) {
        const el = elems[i];
        if (el.tagName.toLowerCase() === 'a' && el.textContent !== 'NVD-CWE-noinfo') {
            return el.textContent || undefined;
        }
    }
    return undefined;
}

function getVulnerableLibraries(issue: GitHubApiIssue, entityManager: EntityManager, project: Project): Package[] {
    const vulnerableLibrariesStringRegex = /^ (?:Vulnerable Libraries|Vulnerable Library) - ([\w-\d\. ,]+)$/m;
    const vulnerableStringMatch = issue.bodyText.match(vulnerableLibrariesStringRegex);
    if (!vulnerableStringMatch) {
        return [];
    }
    const text = vulnerableStringMatch[1];

    // Source: https://semver.org/
    const semverRegex = /(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?/;

    const vulnerablePackages: Package[] = [];
    const rawPackageTexts = text.split(', ');
    
    for (const rawPackageText of rawPackageTexts) {
        const packageAndVersion = rawPackageText.replace(/\.tgz$/, '');
        const matches = packageAndVersion.match(semverRegex);
        if (!matches || matches.length === 0) {
            console.log(`Failed to extract version information from whitesource bolt issue ${issue.url}`);
            const projectError = entityManager.create(ProjectError, {
                project: project,
                phase: 'DEPS/VULN',
                message: `Failed to extract version information from whitesource bolt issue ${issue.url}`,
            });
            saveToDbWithErrorHandling(entityManager, ProjectError, projectError, `Failed to save error to database about a failure to extract version information from whitesource bolt issue ${issue.url}`);
            continue;
        }
        const version = matches[0];
        const packageName = packageAndVersion.replace(new RegExp(`-${escapeStringRegexp(version)}$`), '');
        const pkg = {
            name: packageName,
            version,
        };
        vulnerablePackages.push(pkg);
    }
    return vulnerablePackages;
}

export default func;
