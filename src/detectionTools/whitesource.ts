import { DetectionToolFunction, GitHubApiIssue, GitHubApiIssuesResponse } from '../interfaces/types';
import { gql } from 'graphql-request';
import { getGitHubGraphQlClient, saveToDbWithErrorHandling } from '../util';
import { EntityManager, getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import escapeStringRegexp from 'escape-string-regexp';
import { Project } from '../entities/project';
import axios from 'axios';
import xmldom from 'xmldom';
import parse5 from 'parse5';
import xmlserializer from 'xmlserializer';
import { DepDict, getDepDictId, getDetectionToolBase, getPurl, getUniqueDepPaths } from './util';
import { DetectionTool } from '../entities/detectionTool';
import { DependencyPath } from '../entities/dependencyPath';
import { Dependency } from '../entities/dependency';
import { ToolExecution } from '../entities/toolExecution';
import { Package } from '../entities/package';
import { Vulnerability } from '../entities/vulnerability';
import _ from 'lodash';

const TOOL_NAME = 'WhiteSource Bolt';

async function getDetectionTool() {
    // No version information available for this tool so default to 1.0.0
    const version = '1.0.0';
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool) => {
    const entityManager = getManager(TOOL_NAME);
    const nodes = await getIssueNodes(project);
    const toolExecWithoutId = entityManager.create(ToolExecution, {
        dependencyCount: 0,
        durationMs: 0,
        exitCode: 0,
        project,
        tool,
        vulnerabilityCount: nodes.length,
    });
    const toolExec = await entityManager.save(ToolExecution, toolExecWithoutId);
    let deps = await saveVulnerabilitiesAndGetDeps(nodes, entityManager, toolExec);
    
    console.log(`${TOOL_NAME} - saving dependencies to database and linking with vulnerabilities`);
    deps = await entityManager.save(Dependency, deps, { chunk: 10000 });

    console.log(`${TOOL_NAME} - saving vulnerable dependency paths`);
    const depPaths = getUniqueDepPaths(deps);
    await entityManager.save(DependencyPath, depPaths, { chunk: 10000 });
}

async function getIssueNodes(project: Project) {
    const client = getGitHubGraphQlClient();
    const [owner, repo] = project.forkedName.split('/');
    let moreResults = true;
    let cursor = undefined;
    let nodes: GitHubApiIssuesResponse['search']['nodes'] = [];
    console.log(`Querying GitHub API for whitesource bolt issues`);
    while (moreResults) {
        const query = gql`
        query {
            search(query: "repo:${owner}/${repo} author:app/whitesource-bolt-for-github", type: ISSUE, first: 100${cursor ? ', after: "' + cursor + '"' : ''}) {
                nodes {
                    ... on Issue {
                        author {
                            login
                        }
                        bodyText
                        body
                        url
                    }
                }
                pageInfo {
                    endCursor
                    hasNextPage
                }
            }
        }`;
        const res: GitHubApiIssuesResponse = await client.request(query);
        nodes = nodes.concat(res.search.nodes);
        moreResults = res.search.pageInfo.hasNextPage;
        cursor = res.search.pageInfo.endCursor;
    }
    return nodes.filter((node): node is GitHubApiIssue => 'bodyText' in node);
}

async function saveVulnerabilitiesAndGetDeps(nodes: GitHubApiIssue[], entityManager: EntityManager, toolExecution: ToolExecution) {
    const depDict: DepDict = {};
    let vulnerabilities: Vulnerability[] = [];
    for (const node of nodes) {
        vulnerabilities.push(await createVulnerability(node, entityManager, toolExecution));
    }
    console.log(`${TOOL_NAME} - Saving vulnerabilities to database`);
    vulnerabilities = await entityManager.save(Vulnerability, vulnerabilities);
    let i = 0;
    for (const node of nodes) {
        const vulnerability = vulnerabilities[i];

        const vulnerableLibraries = getVulnerableLibraries(node, entityManager, toolExecution.project, toolExecution.tool);
        if (vulnerableLibraries.length === 0) {
            console.log(`Failed to extract package information from whitesource bolt issue ${node.url}`);
            const projectError = entityManager.create(ProjectError, {
                project: toolExecution.project,
                phase: 'DEPS/VULN',
                detectionTool: toolExecution.tool,
                message: `Failed to extract package information from whitesource bolt issue ${node.url}`,
            });
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
            continue;
        }

        const dependencyHierarchyRegex = /^Dependency Hierarchy:\n\n(.+?) \(Vulnerable Library\)/gms;
        for (const vulnLib of vulnerableLibraries) {
            const id = getDepDictId(vulnLib.name, vulnLib.version);
            if (!depDict[id]) {
                const pkg = entityManager.create(Package, {
                    name: vulnLib.name,
                });
                const dep = entityManager.create(Dependency, {
                    package: pkg,
                    toolExecution,
                    purl: getPurl(vulnLib.name, vulnLib.version),
                    version: vulnLib.version,
                    vulnerabilities: [vulnerability],
                    dependencyPaths: [],
                });
                depDict[id] = dep;
            } else if (!depDict[id].vulnerabilities.find((vuln) => vulnerability.internalId === vuln.internalId)) {
                depDict[id].vulnerabilities.push(vulnerability);
            }

            const depPath = getVulnerableDepPath(dependencyHierarchyRegex, node.bodyText, entityManager);
            depDict[id].dependencyPaths.push(depPath);
        }
        ++i;
    }
    return _.values(depDict);
}

async function createVulnerability(issue: GitHubApiIssue, entityManager: EntityManager, toolExecution: ToolExecution) {
    const cve = getCveIdentifier(issue.bodyText);
    const internalId = cve || getWsId(issue.bodyText);
    const severity = getSeverity(issue.bodyText);
    const cvss = getCvssScore(issue.bodyText);
    const description = getDescription(issue.bodyText);
    const cwe = await getCwe(issue);
    return entityManager.create(Vulnerability, {
        cve,
        internalId,
        severity,
        cwe,
        cvssScore: cvss?.score,
        cvssVersion: cvss?.cvssVersion,
        description,
        source: 'WhiteSource',
        toolExecution,
    });
}

function getCveIdentifier(bodyText: string): string | undefined {
    const cveRegex = /^CVE-\d{4}-\d{4,}/;
    const cveMatch = bodyText.match(cveRegex);
    return cveMatch ? cveMatch[0] : undefined;
}

function getWsId(bodyText: string) {
    const wsRegex = /^WS-\d{4}-\d{1,}/;
    const wsMatch = bodyText.match(wsRegex);
    return wsMatch ? wsMatch[0] : undefined;
}

function getSeverity(bodyText: string) {
    const severityRegex = /- (Low|Medium|High|Critical) Severity Vulnerability/;
    const severityMatch = bodyText.match(severityRegex);
    return severityMatch ? severityMatch[1] : undefined;
}

function getCvssScore(bodyText: string) {
    const cvssScoreRegex = /CVSS (\d+\.?\d*) Score Details \((\d+\.?\d*)\)/;
    const cvssScoreMatch = bodyText.match(cvssScoreRegex);
    return cvssScoreMatch ? { cvssVersion: cvssScoreMatch[1], score: parseFloat(cvssScoreMatch[2]) } : undefined;
}

function getDescription(bodyText: string) {
    const descriptionRegex = /Vulnerability Details[\n\s]+(.+?)\n/ms;
    const descriptionMatch = bodyText.match(descriptionRegex);
    if (descriptionMatch) {
        return descriptionMatch[1];
    }
    return undefined;
}

async function getCwe(issue: GitHubApiIssue) {
    const whiteSourceVulnDbUrlRegex = /href=(https:\/\/vuln.whitesourcesoftware.com\/vulnerability\/[\w-]+)/;

    const whiteSourceVulnDbUrlMatches = issue.body.match(whiteSourceVulnDbUrlRegex);
    if (!whiteSourceVulnDbUrlMatches || whiteSourceVulnDbUrlMatches.length < 2 || !whiteSourceVulnDbUrlMatches[1]) {
        return undefined;
    }
    const whiteSourceVulnDbUrl = whiteSourceVulnDbUrlMatches[1];
    const vulnDbHtml = await axios.get(whiteSourceVulnDbUrl);
    const parsedHtml = parse5.parse(vulnDbHtml.data);
    const xmlSerializedHtml = xmlserializer.serializeToString(parsedHtml);
    const doc = new xmldom.DOMParser({ errorHandler: {
        warning: (w) => { return; },
        error: (err) => console.log(err),
        fatalError: (err) => console.log(err),
    }}).parseFromString(xmlSerializedHtml);
    const elems = doc.getElementsByClassName('col-xl-4');
    for (let i = 0; i < elems.length; ++i) {
        const el = elems[i];
        if (el.tagName.toLowerCase() === 'a') {
            return el.textContent || undefined;
        }
    }
    return undefined;
}

function getVulnerableLibraries(issue: GitHubApiIssue, entityManager: EntityManager, project: Project, tool: DetectionTool) {
    const vulnerableLibrariesStringRegex = /^ (?:Vulnerable Libraries|Vulnerable Library) - ([\w-\d\. ,]+)$/m;
    const vulnerableStringMatch = issue.bodyText.match(vulnerableLibrariesStringRegex);
    if (!vulnerableStringMatch) {
        return [];
    }
    const text = vulnerableStringMatch[1];

    const vulnerablePackages = [];
    const rawPackageTexts = text.split(', ');
    
    for (const rawPackageText of rawPackageTexts) {
        const pkg = getNameAndVersionFromTgzFormat(rawPackageText);
        if (!pkg) {
            console.log(`Failed to extract version information from whitesource bolt issue ${issue.url}`);
            const projectError = entityManager.create(ProjectError, {
                project: project,
                phase: 'DEPS/VULN',
                detectionTool: tool,
                message: `Failed to extract version information from whitesource bolt issue ${issue.url}`,
            });
            saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
            continue;
        }
        vulnerablePackages.push(pkg);
    }
    return vulnerablePackages;
}

function getNameAndVersionFromTgzFormat(tgzFormatString: string) {
    // Source: https://semver.org/
    const semverRegex = /(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?/;
    const packageAndVersion = tgzFormatString.replace(/\.tgz$/, '');
    const matches = packageAndVersion.match(semverRegex);
    if (!matches || matches.length === 0) {
        return undefined;
    }
    const version = matches[0];
    const packageName = packageAndVersion.replace(new RegExp(`-${escapeStringRegexp(version)}$`), '');
    return {
        name: packageName,
        version,
    };
}

function getVulnerableDepPath(depHierarchyRegex: RegExp, bodyText: string, entityManager: EntityManager) {
    const match = depHierarchyRegex.exec(bodyText);
    if (!match) {
        throw new Error(`${TOOL_NAME} - vulnerable dependencies and dependency hierarchy don't match ${bodyText}`);
    }
    const libraryString = match[1];
    return extractDependencyPathFromLibraryString(libraryString, entityManager);
}

function extractDependencyPathFromLibraryString(libraryString: string, entityManager: EntityManager) {
    const libraries = libraryString
        .split('\n')
        .filter((str) => str)
        .map((library, i, arr) => {
            if (i === 0 && arr.length > 1) {
                library = library.substr(0, library.indexOf(' (Root Library)'));
            } else if (i === arr.length - 1) {
                library = library.split(' ')[1];
            }
            const pkg = getNameAndVersionFromTgzFormat(library);
            if (!pkg) {
                throw new Error(`${TOOL_NAME} - Couldn't extract dependency path from "${libraryString}"`);
            }
            return `${pkg.name}@${pkg.version}`;
        });
    return entityManager.create(DependencyPath, {
        path: libraries.join(','),
    });
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
};
