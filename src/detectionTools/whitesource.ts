import { DetectionToolFunction, GitHubApiIssue, GitHubApiIssuesResponse } from '../interfaces/types';
import { gql } from 'graphql-request';
import { doGitHubGraphQlRequestWithRetry, getGitHubGraphQlClient } from '../util';
import { EntityManager, getManager } from 'typeorm';
import escapeStringRegexp from 'escape-string-regexp';
import { Project } from '../entities/project';
import { DepDict, getDepDictId, getDetectionToolBase, getPurl, getUniqueDepPaths, getXmlDomFromUrl, runScanIfFork, saveDependencies } from './util';
import { DetectionTool } from '../entities/detectionTool';
import { DependencyPath } from '../entities/dependencyPath';
import { Dependency } from '../entities/dependency';
import { ToolExecution } from '../entities/toolExecution';
import { Package } from '../entities/package';
import { Vulnerability } from '../entities/vulnerability';
import _ from 'lodash';
import { ManualReview } from '../entities/manualReview';
import semver from 'semver';

const TOOL_NAME = 'WhiteSource Bolt';

async function getDetectionTool() {
    // No version information available for this tool so default to 1.0.0
    const version = '1.0.0';
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool) => {
    const entityManager = getManager();
    console.log(`${TOOL_NAME} - Querying GitHub API for whitesource bolt issues`);
    const nodes = await getIssueNodes(project);

    console.log(`${TOOL_NAME} - Saving tool execution information`);
    const toolExecWithoutId = entityManager.create(ToolExecution, {
        dependencyCount: 0,
        durationMs: 0,
        exitCode: 0,
        project,
        tool,
        vulnerabilityCount: nodes.length,
    });
    const toolExec = await entityManager.save(ToolExecution, toolExecWithoutId);
    console.log(`${TOOL_NAME} - extract data from GitHub issues`);
    let deps = await getDepsWithVulnsAndDepPaths(nodes, entityManager, toolExec);
    
    console.log(`${TOOL_NAME} - saving dependencies and vulnerabilities to database`);
    deps = await saveDependencies(deps, entityManager);

    console.log(`${TOOL_NAME} - saving vulnerable dependency paths`);
    const depPaths = getUniqueDepPaths(deps);
    await entityManager.save(DependencyPath, depPaths, { chunk: 5000 });
}

async function getIssueNodes(project: Project) {
    const client = getGitHubGraphQlClient();
    const [owner, repo] = project.forkedName.split('/');
    let moreResults = true;
    let cursor = undefined;
    let nodes: GitHubApiIssuesResponse['search']['nodes'] = [];
    while (moreResults) {
        const query = gql`
        query {
            search(query: "repo:${owner}/${repo} author:app/whitesource-bolt-for-github", type: ISSUE, first: 100${cursor ? ', after: "' + cursor + '"' : ''}) {
                nodes {
                    ... on Issue {
                        author {
                            login
                        }
                        bodyText
                        body
                        url
                        title
                    }
                }
                pageInfo {
                    endCursor
                    hasNextPage
                }
            }
        }`;
        const res: GitHubApiIssuesResponse = await doGitHubGraphQlRequestWithRetry(client, query, 10);
        nodes = nodes.concat(res.search.nodes);
        moreResults = res.search.pageInfo.hasNextPage;
        cursor = res.search.pageInfo.endCursor;
    }
    return nodes.filter((node): node is GitHubApiIssue => 'bodyText' in node);
}

async function getDepsWithVulnsAndDepPaths(nodes: GitHubApiIssue[], entityManager: EntityManager, toolExecution: ToolExecution) {
    const depDict: DepDict = {};
    for (const node of nodes) {
        if (isOldIssue(node)) {
            await processOldIssue(node, depDict, entityManager, toolExecution);
        } else {
            await processNewIssue(node, depDict, entityManager, toolExecution)
        }
    }
    return _.values(depDict);
}

function isOldIssue(node: GitHubApiIssue) {
    if (node.title.includes(' detected in ')) {
        return true;
    }
    return false;
}

async function processOldIssue(node: GitHubApiIssue, depDict: DepDict, entityManager: EntityManager, toolExecution: ToolExecution) {
    const vulnerability = await createVulnerability(node, entityManager, toolExecution);

    const vulnerableLibraries = getVulnerableLibraries(node, entityManager, toolExecution.project, toolExecution.tool);
    if (vulnerableLibraries.length === 0) {
        console.log(`Failed to extract package information from whitesource bolt issue automatically ${node.url}. Creating a manual review.`);
        const mRev = entityManager.create(ManualReview, {
            toolExecution,
            reason: `${TOOL_NAME} - Failed to extract package information`,
            data: `${vulnerability.internalId} - ${node.url}`,
        });
        await entityManager.save(ManualReview, mRev);
        return;
    }

    for (const vulnLib of vulnerableLibraries) {
        handleDepDictAdding(vulnLib, vulnerability, node, depDict, entityManager, toolExecution);
    }
}

async function processNewIssue(issue: GitHubApiIssue, depDict: DepDict, entityManager: EntityManager, toolExecution: ToolExecution) {
    const startingPointRegex = /[^\S\r\n]*CVE[^\S\r\n]*\n[^\S\r\n]*Severity[^\S\r\n]*\n[^\S\r\n]*CVSS[^\S\r\n]*\n[^\S\r\n]*Dependency[^\S\r\n]*\n[^\S\r\n]*Type[^\S\r\n]*\n[^\S\r\n]*Fixed in[^\S\r\n]*\n[^\S\r\n]*Remediation Available[^\S\r\n]*/g;
    const startingPointMatch = startingPointRegex.exec(issue.bodyText);
    if (!startingPointMatch) {
        return;
    }
    const startIndex = startingPointRegex.lastIndex;

    const endingPointRegex = /^Details$\n/gm;
    const endingPointMatch = endingPointRegex.exec(issue.bodyText);
    if (!endingPointMatch) {
        return;
    }
    const endIndex = endingPointMatch.index;
    const vulnerabilityInfos = issue.bodyText.substring(startIndex, endIndex)
        .trim()
        .split('\n\n')
        .map((vulnInfo) =>
            vulnInfo.split('\n')
                .filter((row) => row.length)
                .map((row) => row.trim())
        );

    for (let i = 0; i < vulnerabilityInfos.length; ++i) {
        const vulnInfo = vulnerabilityInfos[i];
        if (vulnInfo.length !== 7) {
            const errorTxt = `${TOOL_NAME} - Can't handle issue ${issue.url}. Wrong number of details. Expected 7 but got ${vulnInfo.length}`
            console.log(errorTxt);
            throw new Error(errorTxt)
        }
        const vulnerableDepInfo = getDepNameAndVersion(vulnInfo[3]);
        const vulnerableDepInfos = [];
        const vulnId = vulnInfo[0];
        if (!vulnerableDepInfo) {
            let multipleFound = false;
            if (vulnInfo[3].toLowerCase().trim() === 'multiple') {
                console.log(`${TOOL_NAME} - Encountered multiple dependencies corresponding to the same vulnerability`);
                const multipleDepRegexStr = `^ *${escapeStringRegexp(vulnId)} *\nVulnerable Libraries - (.*)$`;
                const multipleDepRegex = new RegExp(multipleDepRegexStr, 'm');
                const match = issue.bodyText.match(multipleDepRegex);
                if (match) {
                    multipleFound = true;
                    const depStrings = match[1].split(',').map((val) => val.trim());
                    for (const dep of depStrings) {
                        const info = getDepNameAndVersion(dep);
                        if (!info) {
                            multipleFound = false;
                            break;
                        }
                        vulnerableDepInfos.push(info);
                    }
                }
            }
            if (!multipleFound) {
                console.log(`Failed to extract package information from whitesource bolt issue automatically ${issue.url}. Creating a manual review.`);
                const mRev = entityManager.create(ManualReview, {
                    toolExecution,
                    reason: `${TOOL_NAME} - Failed to extract package information`,
                    data: `${vulnId} - ${issue.url}`,
                });
                await entityManager.save(ManualReview, mRev);
                continue;
            }
        }

        const cve = getCveIdentifier(vulnId);
        const description = getDescription(issue.bodyText, i);
        const severity = vulnInfo[1];
        const cvssScore = parseFloat(vulnInfo[2]);
        const fixedIn = vulnInfo[5];
        const vulnerableVersionRange = semver.valid(fixedIn) ? `<${fixedIn}` : undefined;
        const cwe = await getCwe(issue, i);
        const vulnerability = entityManager.create(Vulnerability, {
            internalId: vulnId,
            cve,
            description,
            severity,
            cvssScore,
            vulnerableVersionRange,
            cwe,
            source: 'WhiteSource',
            toolExecution,
        });
        if (vulnerableDepInfo) {
            handleDepDictAdding(vulnerableDepInfo, vulnerability, issue, depDict, entityManager, toolExecution)
        } else {
            vulnerableDepInfos.forEach((depInf) => {
                handleDepDictAdding(depInf, vulnerability, issue, depDict, entityManager, toolExecution)
            });
        }
    }
}

async function createVulnerability(issue: GitHubApiIssue, entityManager: EntityManager, toolExecution: ToolExecution) {
    const cve = getCveIdentifier(issue.bodyText);
    const internalId = cve || getWsId(issue.bodyText);
    const severity = getSeverity(issue.bodyText);
    const cvss = getCvssScore(issue.bodyText);
    const description = getDescription(issue.bodyText);
    const cwe = await getCwe(issue);
    return entityManager.create(Vulnerability, {
        cve,
        internalId,
        severity,
        cwe,
        cvssScore: cvss?.score,
        cvssVersion: cvss?.cvssVersion,
        description,
        source: 'WhiteSource',
        toolExecution,
    });
}

function getCveIdentifier(bodyText: string): string | undefined {
    const cveRegex = /^CVE-\d{4}-\d{4,}/gm;
    const cveMatch = bodyText.match(cveRegex);
    return cveMatch ? cveMatch[0] : undefined;
}

function getWsId(bodyText: string) {
    const wsRegex = /^WS-\d{4}-\d{1,}/gm;
    const wsMatch = bodyText.match(wsRegex);
    return wsMatch ? wsMatch[0] : undefined;
}

function getSeverity(bodyText: string) {
    const severityRegex = /- (Low|Medium|High|Critical) Severity Vulnerability/;
    const severityMatch = bodyText.match(severityRegex);
    return severityMatch ? severityMatch[1] : undefined;
}

function getCvssScore(bodyText: string) {
    const cvssScoreRegex = /CVSS (\d+\.?\d*) Score Details \((\d+\.?\d*)\)/;
    const cvssScoreMatch = bodyText.match(cvssScoreRegex);
    return cvssScoreMatch ? { cvssVersion: cvssScoreMatch[1], score: parseFloat(cvssScoreMatch[2]) } : undefined;
}

function getDescription(bodyText: string, index: number = 0) {
    const descriptionRegex = /Vulnerability Details[\n\s]+(.+?)\n/g;
    return getCaptureGroupOfGlobalRegexByMatchIndex(descriptionRegex, bodyText, index);
}

function getCaptureGroupOfGlobalRegexByMatchIndex(regex: RegExp, text: string, index: number) {
    let i = 0;
    let matches: RegExpExecArray | null = null;
    while (matches = regex.exec(text)) {
        if (index === i) {
            return matches[1];
        }
        ++i;
    }
    return undefined;
}

async function getCwe(issue: GitHubApiIssue, index: number = 0) {
    const whiteSourceVulnDbUrlRegex = /href=(https:\/\/vuln.whitesourcesoftware.com\/vulnerability\/[\w-]+)/g;
    const whiteSourceVulnDbUrl = getCaptureGroupOfGlobalRegexByMatchIndex(whiteSourceVulnDbUrlRegex, issue.body, index);
    if (!whiteSourceVulnDbUrl) {
        return undefined;
    }
    const dom = await getXmlDomFromUrl(whiteSourceVulnDbUrl, TOOL_NAME);
    const elems = dom.getElementsByClassName('col-xl-4');
    for (let i = 0; i < elems.length; ++i) {
        const el = elems[i];
        if (el.tagName.toLowerCase() === 'a') {
            return el.textContent || undefined;
        }
    }
    return undefined;
}

function getVulnerableLibraries(issue: GitHubApiIssue, entityManager: EntityManager, project: Project, tool: DetectionTool) {
    const vulnerableLibrariesStringRegex = /^ ?(?:Vulnerable Libraries|Vulnerable Library) - (.+)$/m;
    const vulnerableStringMatch = issue.bodyText.match(vulnerableLibrariesStringRegex);
    if (!vulnerableStringMatch) {
        return [];
    }
    const text = vulnerableStringMatch[1];

    const vulnerablePackages = [];
    const rawPackageTexts = text.split(', ');
    
    for (const rawPackageText of rawPackageTexts) {
        const pkg = getDepNameAndVersion(rawPackageText);
        if (!pkg) {
            continue;
        }
        vulnerablePackages.push(pkg);
    }
    return vulnerablePackages;
}

function getDepNameAndVersion(text: string) {
    // Source: https://semver.org/
    const semverRegex = /(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?/;
    const packageAndVersion = text.replace(/\.tgz$/, '');
    const matches = semverRegex.exec(packageAndVersion);
    if (!matches || matches.length === 0) {
        console.log(`${TOOL_NAME} - Couldn't match ${packageAndVersion}`);
        return undefined;
    }
    const version = packageAndVersion.substr(matches.index);
    const packageName = packageAndVersion.replace(new RegExp(`(?:-?|\:+)${escapeStringRegexp(version)}$`), '');
    return {
        name: packageName,
        version,
    };
}

function handleDepDictAdding(
    vulnerableDep: { name: string; version: string },
    vulnerability: Vulnerability,
    issue: GitHubApiIssue,
    depDict: DepDict,
    entityManager: EntityManager,
    toolExecution: ToolExecution,
    index: number = 0,
) {
    const id = getDepDictId(vulnerableDep.name, vulnerableDep.version);
    if (!depDict[id]) {
        const dep = createNewDependency(vulnerableDep, entityManager, toolExecution);
        // Pushing the vulnerability into dep afterwards prevents copying of the vulnerability object
        // which would otherwise prevent saving the many-to-many relationship using cascade
        dep.vulnerabilities.push(vulnerability);
        depDict[id] = dep;
    } else if (!depDict[id].vulnerabilities.find((vuln) => vulnerability.internalId === vuln.internalId)) {
        depDict[id].vulnerabilities.push(vulnerability);
    }

    processVulnerableDepPathAndDependencies(issue.bodyText, depDict, entityManager, toolExecution, index);
}

function createNewDependency(vulnerableDep: { name: string; version: string }, entityManager: EntityManager, toolExecution: ToolExecution) {
    const pkg = entityManager.create(Package, {
        name: vulnerableDep.name,
    });
    return entityManager.create(Dependency, {
        package: pkg,
        toolExecution,
        purl: getPurl(vulnerableDep.name, vulnerableDep.version),
        version: vulnerableDep.version,
        vulnerabilities: [],
        dependencyPaths: [],
    });
}

function processVulnerableDepPathAndDependencies(
    bodyText: string,
    depDict: DepDict,
    entityManager: EntityManager,
    toolExecution: ToolExecution,
    index: number,
) {
    const depHierarchyRegex = /^Dependency Hierarchy:\n\n(.+?) \(Vulnerable Library\)/gms;
    const libraryString = getCaptureGroupOfGlobalRegexByMatchIndex(depHierarchyRegex, bodyText, index);
    if (!libraryString) {
        return;
    }
    const depInfos = extractDependencyInfoFromLibraryString(libraryString, entityManager);
    let currentPath = '';
    for (const depInfo of depInfos) {
        const id = getDepDictId(depInfo.name, depInfo.version);
        currentPath = `${currentPath}${currentPath.length ? ',' : ''}${depInfo.name}@${depInfo.version}`;
        const depPath = entityManager.create(DependencyPath, { path: currentPath });
        if (!depDict[id]) {
            const dep = createNewDependency(depInfo, entityManager, toolExecution);
            // Pushing the vulnerability into dep afterwards prevents copying of the vulnerability object
            // which would otherwise prevent saving the many-to-many relationship using cascade
            dep.dependencyPaths.push(depPath);
            depDict[id] = dep;
        } else {
            depDict[id].dependencyPaths.push(depPath);
        }
    }
}

function extractDependencyInfoFromLibraryString(libraryString: string, entityManager: EntityManager) {
    return libraryString
        .split('\n')
        .filter((str) => str)
        .map((library, i, arr) => {
            if (i === 0 && arr.length > 1) {
                library = library.substr(0, library.indexOf(' (Root Library)'));
            } else if (i === arr.length - 1) {
                library = library.split(' ')[1];
            }
            const pkg = getDepNameAndVersion(library);
            if (!pkg) {
                throw new Error(`${TOOL_NAME} - Couldn't extract dependency path from "${libraryString}"`);
            }
            return pkg;
        });
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
};

runScanIfFork(runScan);
