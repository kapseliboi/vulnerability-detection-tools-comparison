import axios, { AxiosInstance, AxiosResponse } from 'axios';
import xmldom from 'xmldom';
import parse5 from 'parse5';
import xmlserializer from 'xmlserializer';
import jsdom from 'jsdom';
import { ChildProcess } from 'child_process';
import _ from 'lodash';
import toughCookie from 'tough-cookie';
import axiosCookieJarSupport from 'axios-cookiejar-support';
import semver from 'semver';
import { ConnectionOptions, createConnection, EntityManager, getConnectionOptions, getManager } from 'typeorm';
import { Dependency } from '../entities/dependency';
import { DetectionTool } from '../entities/detectionTool';
import { Project } from '../entities/project';
import { ProjectError } from '../entities/projectError';
import { Vulnerability } from '../entities/vulnerability';
import { saveToDbWithErrorHandling, sleep } from '../util';
import config from '../config';
import { DetectionToolFunction } from '../interfaces/types';

export function handleErrorsAndPromisify(childProc: ChildProcess, project: Project, tool: DetectionTool, entityManager: EntityManager) {
    return new Promise<number>((resolve, reject) => {
        childProc.on('exit', async (code, signal) => {
            if (code === 0 ) {
                console.log(`Command deps/vuln analysis completed successfully for project "${project.name} ${project.commitHash}" with tool ${tool.name}`);
                resolve(code);
            } else {
                const projectError = entityManager.create(ProjectError, {
                    project,
                    phase: 'DEPS/VULN',
                    detectionTool: tool,
                    message: `Error code ${code} and signal ${signal}`,
                });
                console.log(`Error while running deps/vuln analysis for project "${project.name} ${project.commitHash}" with tool ${tool.name}. Saving error to database`);
                await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
                reject(code);
            }
        });

        childProc.on('error', async (err) => {
            const projectError = entityManager.create(ProjectError, {
                project,
                phase: 'DEPS/VULN',
                detectionTool: tool,
                message: err.message,
            });
    
            console.log(`Error while running deps/vuln analysis for project "${project.name} ${project.commitHash}" with tool ${tool.name}. Saving error to database`);
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
            reject();
        });
    });

}

export function getOssIndexClient() {
    const cookieJar = new toughCookie.CookieJar();
    const axiosCookieClient = axios.create({
        withCredentials: true,
        headers: {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Upgrade-Insecure-Requests": "1",
        },
    });
    axiosCookieJarSupport(axiosCookieClient);
    axiosCookieClient.defaults.jar = cookieJar;
    return axiosCookieClient;
}

export async function ensureOssIndexWebPageLoggedIn(ossIndexClient: AxiosInstance, toolName: string) {
    try {
        ossIndexClient.defaults.headers['Referer'] = 'https://ossindex.sonatype.org/';
        const dom = await getXmlDomFromUrl('https://ossindex.sonatype.org/user/signin', toolName, ossIndexClient);
        console.log(`${toolName} - Sonatype not logged in. Logging in now`);
        const form = dom.getElementById('signin-form');
        let csrf: string;
        for (let i = 0; i < form!.childNodes.length; ++i) {
            const child = form!.childNodes[i];
            if (child.nodeName === 'input' &&
                (child as HTMLElement).attributes.getNamedItem('name')?.value === 'csrf-token'
            ) {
                csrf = (child as HTMLElement).attributes.getNamedItem('value')!.value;
                break;
            }
        }
        const urlSearchParams = new URLSearchParams();
        urlSearchParams.append('email', config.SONATYPE_OSSINDEX_EMAIL);
        urlSearchParams.append('password', config.SONATYPE_OSSINDEX_PASSWORD);
        urlSearchParams.append('csrf-token', csrf!);

        await sleep(2000);
        await ossIndexClient.post(
            'https://ossindex.sonatype.org/user/signin',
            urlSearchParams,
            {
                headers: {
                    'Origin': 'https://ossindex.sonatype.org',
                    'Referer': 'https://ossindex.sonatype.org/user/signin',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            },
        );
    } catch(err) {
        if (!axios.isAxiosError(err) || err.response?.status !== 403) {
            throw err;
        }
    }
}

export async function getNpmIdFromOssIndexUrl(url: string, ossIndexClient: AxiosInstance, toolName: string) {
    const dom = await getXmlDomFromUrl(url, toolName, ossIndexClient);
    const elems = dom.getElementsByClassName('analytics-external-vulnerability-refs');
    const npmUrlRegex = /^https:\/\/(?:www\.)?npmjs\.com\/advisories\/(\d+)/;
    for (let i = 0; i < elems.length; ++i) {
        const elem = elems[i];
        if (elem.nodeName.toLowerCase() !== 'a') {
            continue;
        }
        const npmMatch = elem.getAttribute('href')?.match(npmUrlRegex);
        if (npmMatch) {
            return npmMatch[1];
        }
    }
    return undefined;
}

export async function getDetectionToolBase(toolName: string, version: string) {
    const entityManager = getManager();
    const tool = await entityManager.findOne(DetectionTool, { where: { name: toolName, version }});
    if (!tool) {
        const newTool = entityManager.create(DetectionTool, {
            name: toolName,
            version,
        });
        return entityManager.save(newTool);
    }
    return tool;
}

async function initDbConnection() {
    const connectionOptions = await getConnectionOptions();
    Object.assign<ConnectionOptions, Partial<ConnectionOptions>>(connectionOptions, {
        entities: config.usingTsNode ? ['src/entities/**/*.ts'] : ['build/entities/**/*.js'],
        migrations: config.usingTsNode ? ['src/migrations/**/*.ts'] : ['build/migrations/**/*.js'],
        synchronize: false,
        migrationsRun: false,
    });

    await createConnection(connectionOptions);
}

export function runScanIfFork(runScan: DetectionToolFunction) {

    if (process.send !== undefined) {
        process.on('message', async (msg: Parameters<DetectionToolFunction>) => {
            const tool = msg[4];
            await initDbConnection();
            await runScan(...msg);
            console.log(`${tool.name} executed successfully`);
            process.exit(0);
        });
    }
}

export function getPurl(name: string, version: string, packageManager: string = 'npm') {
    return `pkg:${packageManager.toLowerCase()}/${decodeURIComponent(name)}@${version}`;
}

export interface VulnerabilityWithDepName extends Vulnerability {
    name: string;
    vulnerableVersionRange: string;
}

export function getUniqueDepPaths(dependencies: Dependency[]) {
    return _.uniqBy(
        _.flatMap(
            dependencies,
            (dep) => dep.dependencyPaths.map(
                (depPath) => ({
                    ...depPath,
                    dependency: dep,
                }),
            ),
        ),
        'path',
    );
}

export async function getXmlDomFromUrl(url: string, toolName: string, axiosClient: AxiosInstance = axios) {
    const res = await getRateLimitedUrl(url, toolName, axiosClient);
    const parsedHtml = parse5.parse(res.data);
    const xmlSerializedHtml = xmlserializer.serializeToString(parsedHtml);
    return new xmldom.DOMParser({ errorHandler: {
        warning: (w) => { return; },
        error: (err) => console.log(err),
        fatalError: (err) => console.log(err),
    }}).parseFromString(xmlSerializedHtml);
}

export async function getJsDomFromUrl(url: string, toolName: string, axiosClient: AxiosInstance = axios) {
    const res = await getRateLimitedUrl(url, toolName, axiosClient);
    return new jsdom.JSDOM(res.data);
}

export async function getRateLimitedUrl(url: string, toolName: string, axiosClient: AxiosInstance) {
    let retry = true;
    let rateLimitCounter = 0;
    let res: AxiosResponse<any>;
    while (retry) {
        try {
            res = await axiosClient.get(url);
            await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000);
            retry = false;
        } catch(err) {
            if (!axios.isAxiosError(err) || err.response?.status !== 429) {
                throw err;
            }
            ++rateLimitCounter;
            console.log(`${toolName} - hit a rate limit when fetching extra information for OSSINDEX vulnerability. Rate limit hit ${rateLimitCounter} times in a row without success`);
            const rateLimitMultiplier = 15*rateLimitCounter;
            await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000 * rateLimitMultiplier);
        }
    }
    return res!;
}

export interface DepDict {
    [id: string]: Dependency;
}

export interface VulnDict {
    [id: string]: Vulnerability;
}

export function getDepDictId(name: string, version: string) {
    return `${name}@${version}`;
}

export function enrichDependenciesWithVulnerabilities(deps: Dependency[], vulns: VulnerabilityWithDepName[]) {
    let i = 0;
    let k = 0;
    let multipleVulnerabilitiesInSameDep = false;
    let depIndexForMultipleVulnsInSameDep = 0;
    let foundDependencyForVulnerability = false;
    while (i < deps.length && k < vulns.length) {
        const vuln = vulns[k];
        const dep = deps[i];
        if (vuln.name === dep.package.name) {
            if (semver.satisfies(dep.version, vuln.vulnerableVersionRange)) {
                foundDependencyForVulnerability = true;
                dep.vulnerabilities.push(_.omit(vuln, 'name'));
            }
            ++i;
        } else if (dep.package.name > vuln.name) {
            if (!foundDependencyForVulnerability) {
                throw new Error(`Version information missing for vulnerability ${JSON.stringify(vuln)} when dep ${JSON.stringify(dep)}`);
            }
            if (multipleVulnerabilitiesInSameDep) {
                multipleVulnerabilitiesInSameDep = false;
                i = depIndexForMultipleVulnsInSameDep;
            }
            foundDependencyForVulnerability = false;
            ++k;
            if (k < vulns.length - 1 && vulns[k].name === vulns[k + 1].name) {
                multipleVulnerabilitiesInSameDep = true;
                depIndexForMultipleVulnsInSameDep = i;
            }
        } else {
            ++i;
        }
    }
}
