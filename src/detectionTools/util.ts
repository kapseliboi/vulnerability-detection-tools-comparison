import { ChildProcess } from 'child_process';
import _ from 'lodash';
import semver from 'semver';
import { EntityManager, getManager } from 'typeorm';
import { Dependency } from '../entities/dependency';
import { DetectionTool } from '../entities/detectionTool';
import { Project } from '../entities/project';
import { ProjectError } from '../entities/projectError';
import { Vulnerability } from '../entities/vulnerability';
import { saveToDbWithErrorHandling } from '../util';

export function handleErrorsAndPromisify(childProc: ChildProcess, project: Project, tool: DetectionTool, entityManager: EntityManager) {
    return new Promise<number>((resolve, reject) => {
        childProc.on('exit', async (code, signal) => {
            if (code === 0 ) {
                console.log(`Command deps/vuln analysis completed successfully for project "${project.name} ${project.commitHash}" with tool ${tool.name}`);
                resolve(code);
            } else {
                const projectError = entityManager.create(ProjectError, {
                    project,
                    phase: 'DEPS/VULN',
                    detectionTool: tool,
                    message: `Error code ${code} and signal ${signal}`,
                });
                console.log(`Error while running deps/vuln analysis for project "${project.name} ${project.commitHash}" with tool ${tool.name}. Saving error to database`);
                await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
                reject(code);
            }
        });

        childProc.on('error', async (err) => {
            const projectError = entityManager.create(ProjectError, {
                project,
                phase: 'DEPS/VULN',
                detectionTool: tool,
                message: err.message,
            });
    
            console.log(`Error while running deps/vuln analysis for project "${project.name} ${project.commitHash}" with tool ${tool.name}. Saving error to database`);
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
            reject();
        });
    });

}

export async function getDetectionToolBase(toolName: string, version: string) {
    const entityManager = getManager(toolName);
    const tool = await entityManager.findOne(DetectionTool, { where: { name: toolName, version }});
    if (!tool) {
        const newTool = entityManager.create(DetectionTool, {
            name: toolName,
            version,
        });
        return entityManager.save(newTool);
    }
    return tool;
}

export function getPurl(name: string, version: string, packageManager: string = 'npm') {
    return `pkg:${packageManager.toLowerCase()}/${decodeURIComponent(name)}@${version}`;
}

export interface VulnerabilityWithDepName extends Vulnerability {
    name: string;
    vulnerableVersionRange: string;
}

export function getUniqueDepPaths(dependencies: Dependency[]) {
    return _.uniqBy(
        _.flatMap(
            dependencies,
            (dep) => dep.dependencyPaths.map(
                (depPath) => ({
                    ...depPath,
                    dependency: dep,
                }),
            ),
        ),
        'path',
    );
}

export interface DepDict {
    [id: string]: Dependency;
}

export function getDepDictId(name: string, version: string) {
    return `${name}@${version}`;
}

export function enrichDependenciesWithVulnerabilities(deps: Dependency[], vulns: VulnerabilityWithDepName[]) {
    let i = 0;
    let k = 0;
    let multipleVulnerabilitiesInSameDep = false;
    let depIndexForMultipleVulnsInSameDep = 0;
    let foundDependencyForVulnerability = false;
    while (i < deps.length && k < vulns.length) {
        const vuln = vulns[k];
        const dep = deps[i];
        if (vuln.name === dep.package.name) {
            if (semver.satisfies(dep.version, vuln.vulnerableVersionRange)) {
                foundDependencyForVulnerability = true;
                dep.vulnerabilities.push(_.omit(vuln, 'name'));
            }
            ++i;
        } else if (dep.package.name > vuln.name) {
            if (!foundDependencyForVulnerability) {
                throw new Error(`Npm audit version information missing for vulnerability ${JSON.stringify(vuln)} when dep ${JSON.stringify(dep)}`);
            }
            if (multipleVulnerabilitiesInSameDep) {
                multipleVulnerabilitiesInSameDep = false;
                i = depIndexForMultipleVulnsInSameDep;
            }
            foundDependencyForVulnerability = false;
            ++k;
            if (k < vulns.length - 1 && vulns[k].name === vulns[k + 1].name) {
                multipleVulnerabilitiesInSameDep = true;
                depIndexForMultipleVulnsInSameDep = i;
            }
        } else {
            ++i;
        }
    }
}
