import axios, { AxiosInstance, AxiosResponse } from 'axios';
import xmldom from 'xmldom';
import parse5 from 'parse5';
import xmlserializer from 'xmlserializer';
import jsdom from 'jsdom';
import { ChildProcess } from 'child_process';
import _ from 'lodash';
import semver from 'semver';
import { ConnectionOptions, createConnection, EntityManager, getConnectionOptions, getManager } from 'typeorm';
import { Dependency } from '../entities/dependency';
import { DetectionTool } from '../entities/detectionTool';
import { Project } from '../entities/project';
import { ProjectError } from '../entities/projectError';
import { Vulnerability } from '../entities/vulnerability';
import { saveToDbWithErrorHandling, sleep } from '../util';
import config from '../config';
import { DetectionToolFunction } from '../interfaces/types';
import { Package } from '../entities/package';

export const NpmUrlRegex = /https:\/\/(?:www\.)?npmjs\.com\/advisories\/(\d+)/;

export function handleErrorsAndPromisify(childProc: ChildProcess, project: Project, tool: DetectionTool, entityManager: EntityManager) {
    return new Promise<number>((resolve, reject) => {
        childProc.on('exit', async (code, signal) => {
            if (code === 0 ) {
                console.log(`Command deps/vuln analysis completed successfully for project "${project.name} ${project.commitHash}" with tool ${tool.name}`);
                resolve(code);
            } else {
                const projectError = entityManager.create(ProjectError, {
                    project,
                    phase: 'DEPS/VULN',
                    detectionTool: tool,
                    message: `Error code ${code} and signal ${signal}`,
                });
                console.log(`Error while running deps/vuln analysis for project "${project.name} ${project.commitHash}" with tool ${tool.name}. Saving error to database`);
                await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
                reject(code);
            }
        });

        childProc.on('error', async (err) => {
            const projectError = entityManager.create(ProjectError, {
                project,
                phase: 'DEPS/VULN',
                detectionTool: tool,
                message: err.message,
            });
    
            console.log(`Error while running deps/vuln analysis for project "${project.name} ${project.commitHash}" with tool ${tool.name}. Saving error to database`);
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
            reject();
        });
    });

}

export async function saveDependencies(dependencies: Dependency[], entityManager: EntityManager) {
    return entityManager.transaction(async (trManager) => {
        // We have to save packages separately because primary key is not auto generated and concurrent queries will fail due to this
        // TypeORM save feature is very naive. It first selects all packages and after that inserts based on the data in the select query
        // If anything adds a duplicate package before the insert then the query will fail. This prevents that.
        await trManager
            .createQueryBuilder()
            .insert()
            .into(Package)
            .values(
                _.uniqBy(
                    dependencies.map((dep) => dep.package),
                    'name',
                ),
            )
            .onConflict(`("name") DO NOTHING`)
            .execute();
        return trManager.save(Dependency, dependencies, { chunk: 5000 });
    });
}

export async function getDetectionToolBase(toolName: string, version: string) {
    const entityManager = getManager();
    const tool = await entityManager.findOne(DetectionTool, { where: { name: toolName, version }});
    if (!tool) {
        const newTool = entityManager.create(DetectionTool, {
            name: toolName,
            version,
        });
        return entityManager.save(newTool);
    }
    return tool;
}

async function initDbConnection() {
    const connectionOptions = await getConnectionOptions();
    Object.assign<ConnectionOptions, Partial<ConnectionOptions>>(connectionOptions, {
        entities: config.usingTsNode ? ['src/entities/**/*.ts'] : ['build/entities/**/*.js'],
        migrations: config.usingTsNode ? ['src/migrations/**/*.ts'] : ['build/migrations/**/*.js'],
        synchronize: false,
        migrationsRun: false,
    });

    await createConnection(connectionOptions);
}

export function runScanIfFork(runScan: DetectionToolFunction) {

    if (process.send !== undefined) {
        process.on('message', async (msg: Parameters<DetectionToolFunction>) => {
            const tool = msg[4];
            await initDbConnection();
            await runScan(...msg);
            console.log(`${tool.name} executed successfully`);
            process.exit(0);
        });
    }
}

export function getHashFromUrl(url: string) {
    const hashRegex = /#(\w)+$/;
    const res = url.match(hashRegex);
    if (res) {
        return res[1];
    }
    return undefined;
}

export function getPurl(name: string, version: string, packageManager: string = 'npm') {
    return `pkg:${packageManager.toLowerCase()}/${decodeURIComponent(name)}@${version}`;
}

export interface VulnerabilityWithDepName extends Vulnerability {
    name: string;
    vulnerableVersionRange: string;
}

export function getUniqueDepPaths(dependencies: Dependency[]) {
    return _.uniqBy(
        _.flatMap(
            dependencies,
            (dep) => dep.dependencyPaths.map(
                (depPath) => ({
                    ...depPath,
                    dependency: dep,
                }),
            ),
        ),
        'path',
    );
}

export async function getXmlDomFromUrl(url: string, toolName: string, axiosClient: AxiosInstance = axios) {
    const res = await getRateLimitedUrl(url, toolName, axiosClient);
    const parsedHtml = parse5.parse(res.data);
    const xmlSerializedHtml = xmlserializer.serializeToString(parsedHtml);
    return new xmldom.DOMParser({ errorHandler: {
        warning: (w) => { return; },
        error: (err) => console.log(err),
        fatalError: (err) => console.log(err),
    }}).parseFromString(xmlSerializedHtml);
}

export async function getJsDomFromUrl(url: string, toolName: string, axiosClient: AxiosInstance = axios) {
    const res = await getRateLimitedUrl(url, toolName, axiosClient);
    return new jsdom.JSDOM(res.data);
}

export async function getRateLimitedUrl(url: string, toolName: string, axiosClient: AxiosInstance) {
    let retry = true;
    let rateLimitCounter = 0;
    let res: AxiosResponse<any>;
    while (retry) {
        try {
            res = await axiosClient.get(url);
            await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000);
            retry = false;
        } catch(err) {
            if (!axios.isAxiosError(err) || err.response?.status !== 429) {
                throw err;
            }
            ++rateLimitCounter;
            console.log(`${toolName} - hit a rate limit when fetching extra information for vulnerability from ${url}. Rate limit hit ${rateLimitCounter} times in a row without success`);
            const rateLimitMultiplier = 15*rateLimitCounter;
            await sleep(config.URL_FETCHING_RATE_LIMIT_SECONDS * 1000 * rateLimitMultiplier);
        }
    }
    return res!;
}

export interface DepDict {
    [id: string]: Dependency;
}

export interface VulnDict {
    [id: string]: Vulnerability;
}

export function getDepDictId(name: string, version: string) {
    return `${name}@${version}`;
}

function checkMultipleVulnerabilitiesInSameDep(vulns: VulnerabilityWithDepName[], currentVulnsIndex: number) {
    if (currentVulnsIndex < vulns.length - 1 &&
        vulns[currentVulnsIndex].name === vulns[currentVulnsIndex + 1].name) {
        return true;
    }
    return false;
}

export function enrichDependenciesWithVulnerabilities(deps: Dependency[], vulns: VulnerabilityWithDepName[]) {
    let i = 0;
    let k = 0;
    let multipleVulnerabilitiesInSameDep = checkMultipleVulnerabilitiesInSameDep(vulns, k);
    let depIndexForMultipleVulnsInSameDep = 0;
    let foundDependencyForVulnerability = false;
    const unmatchedVulnerabilities: VulnerabilityWithDepName[] = [];
    while (i < deps.length && k < vulns.length) {
        const vuln = vulns[k];
        const dep = deps[i];
        if (vuln.name === dep.package.name) {
            if (semver.satisfies(dep.version, vuln.vulnerableVersionRange)) {
                foundDependencyForVulnerability = true;
                dep.vulnerabilities.push(_.omit(vuln, 'name'));
            }
            ++i;
        } else if (dep.package.name > vuln.name) {
            if (!foundDependencyForVulnerability) {
                unmatchedVulnerabilities.push(vuln);
            }
            if (multipleVulnerabilitiesInSameDep) {
                multipleVulnerabilitiesInSameDep = false;
                i = depIndexForMultipleVulnsInSameDep;
            }
            foundDependencyForVulnerability = false;
            ++k;
            if (checkMultipleVulnerabilitiesInSameDep(vulns, k)) {
                multipleVulnerabilitiesInSameDep = true;
                depIndexForMultipleVulnsInSameDep = i;
            }
        } else {
            ++i;
        }
    }
    return unmatchedVulnerabilities;
}
