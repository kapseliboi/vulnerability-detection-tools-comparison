import { execSync, spawn } from 'child_process';
import { DetectionToolFunction } from '../interfaces/types';
import { getDetectionToolBase, handleErrorsAndPromisify } from './util';
import path from 'path';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ManualReview } from '../entities/manualReview';
import { Project } from '../entities/project';
import { DetectionTool } from '../entities/detectionTool';
import { Dependency } from '../entities/dependency';
import { Package } from '../entities/package';
import { DependencyPath } from '../entities/dependencyPath';
import { Vulnerability } from '../entities/vulnerability';
import semver from 'semver';
import { ProjectError } from '../entities/projectError';

const TOOL_NAME = 'Dependency-Check';

interface DcResultObject {
    reportSchema: string;
    scanInfo: {
        engineVersion: string;
        dataSource: {
            name: string;
            timestamp: string;
        }[];
        analysisExceptions?: {
            exception: {
                message: string;
                stackTrace: string[];
                cause: {
                    message: string;
                    stackTrace: string[];
                }
            }
        }[];
    }
    projectInfo: {
        name: string;
        reportDate: string;
        credits: {
            [source: string]: string;
        }
    }
    dependencies: DcDependency[];
}

interface DcDependencyBase {
    isVirtual: boolean;
    fileName: string;
    filePath: string;
    md5: string;
    sha1: string;
    sha256: string;
}

interface DcRelatedDependency extends DcDependencyBase {
    packageIds?: {
        id: string;
    }[];
}

interface DcEvidence {
    type: string;
    confidence: DcConfidence;
    source: string;
    name: string;
    value: string;
}

type DcConfidence = 'LOW' | 'MEDIUM' | 'HIGH' | 'HIGHEST';

interface DcVulnerability {
    source: string;
    name: string;
    unscored?: string;

    severity: string;
    cwes: string[];
    description: string;
    notes: string;
    references: {
        source: string;
        url?: string;
        name: string;
    }[];
    vulnerableSoftware: {
        software: {
            id: string;
            vulnerabilityIdMatched?: string;
            versionStartIncluding?: string;
            versionEndExcluding?: string;
        }
    }[];
    cvssv2?: {
        score: number;
        accessVector: string;
        accessComplexity: string;
        authenticationr: string;
        confidentialImpact: string;
        integrityImpact: string;
        availabilityImpact: string;
        severity: string;
        version: string;
        exploitabilityScore: string;
        impactScore: string;
    };
    cvssv3?: {
        baseScore: number;
        attackVector: string;
        attackComplexity: string;
        privilegesRequired: string;
        userInteraction: string;
        scope: string;
        confidentialityImpact: string;
        integrityImpact: string;
        availabilityImpact: string;
        baseSeverity: string;
        exploitabilityScore: string;
        impactScore: string;
        version: string;
    }
}

interface DcDependency extends DcDependencyBase {
    relatedDependencies?: DcRelatedDependency[];
    projectReferences?: string[];
    evidenceCollected: {
        vendorEvidence: DcEvidence[];
        productEvidence: DcEvidence[];
        versionEvidence: DcEvidence[];
    };
    packages?: {
        id: string;
        confidence: DcConfidence;
    }[];
    vulnerabilityIds?: {
        id: string;
        confidence: DcConfidence;
        url: string;
    }[];
    vulnerabilities?: DcVulnerability[];
}

const enum DependencySuitability {
    accepted,
    rejected,
    manualReview,
}

interface VulnerabilityDict {
    [id: string]: Vulnerability;
}

async function getDetectionTool() {
    const versionOutput = execSync('dependency-check.sh -v').toString().trim();
    const versionArray = versionOutput.split(' ');
    const version = versionArray[versionArray.length - 1];
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs, tool) => {
    const cmd = `dependency-check.sh --prettyPrint --project ${project.name} -o ${resultsPath} -f JSON -f HTML -s .`;
    const child = spawn(cmd, { cwd: projectPath, shell: true });
    await handleErrorsAndPromisify(child, project, tool);
    console.log(`Reading ${TOOL_NAME} results from disk`);
    const resultFile = path.join(resultsPath, 'dependency-check-report.json');
    const res: DcResultObject = JSON.parse(fs.readFileSync(resultFile).toString());
    const entityManager = getManager();
    console.log(`Saving ${TOOL_NAME} results to database`);
    await saveResultsToDb(res.dependencies, project, tool, entityManager);
    if (res.scanInfo.analysisExceptions && res.scanInfo.analysisExceptions.length > 0) {
        const projErr = entityManager.create(ProjectError, {
            detectionTool: tool,
            project,
            phase: 'DEPS/VULN',
            message: `Analysis reported errors ${JSON.stringify(res.scanInfo.analysisExceptions)}`,
        });
        await entityManager.save(ProjectError, projErr);
    }
}

async function saveResultsToDb(dependencies: DcDependency[], project: Project, tool: DetectionTool, entityManager: EntityManager) {
    const manualReviews: ManualReview[] = [];
    const vulnerabilityDict: VulnerabilityDict = {};
    const dbDependencies: Dependency[] = [];
    for (const dep of dependencies) {
        switch (isDependency(dep)) {
            case DependencySuitability.accepted: {
                const pkg = entityManager.create(Package, {
                    name: dep.evidenceCollected.productEvidence[0].value,
                });
                const version = dep.evidenceCollected.versionEvidence[0].value;
                const purl = getPurl(dep) || 'NO_PURL';
                // Report can contain duplicates, filtering them
                if (dbDependencies.find(
                    (dbDep) => dbDep.package.name === pkg.name && dbDep.version === version && dbDep.purl === purl
                    
                )) {
                    continue;
                }
                const dependency = entityManager.create(Dependency, {
                    project,
                    tool,
                    package: pkg,
                    version,
                    purl,
                });
                const dependencyPaths = getDependencyPaths(dep, entityManager, dependency);
                dependency.dependencyPaths = dependencyPaths;
                const vulnerabilities = getVulnerabilities(dep, entityManager, dependency, vulnerabilityDict, project, tool);
                dependency.vulnerabilities = vulnerabilities;
                dbDependencies.push(dependency);
                break;
            }
            case DependencySuitability.manualReview: {
                console.log(`Unclear dependency. Adding to database for manual review`);
                const mRev = entityManager.create(ManualReview, {
                    project,
                    tool,
                    reason: 'Too many productEvidences and versionEvidences',
                    data: JSON.stringify(dep),
                });
                manualReviews.push(mRev);
                break;
            }
            default: {
                continue;
            }
        }
    }

    await entityManager.save(Dependency, dbDependencies);
    await entityManager.save(ManualReview, manualReviews);
}

function getVulnerabilities(dep: DcDependency, entityManager: EntityManager, dependency: Dependency, vulnDict: VulnerabilityDict, project: Project, tool: DetectionTool) {
    const vulnerabilities: Vulnerability[] = [];
    const dcVulnerabilities = dep.vulnerabilities || [];
    for (const vuln of dcVulnerabilities) {
        const id = vuln.source + vuln.name;
        if (!vulnDict[id]) {
            vulnDict[id] = createVulnerability(entityManager, vuln, project, tool, dependency);
        }
        vulnerabilities.push(vulnDict[id]);
    }
    return vulnerabilities;
}

function createVulnerability(entityManager: EntityManager, vuln: DcVulnerability, project: Project, tool: DetectionTool, dependency: Dependency) {
    const cve = getCve(vuln);
    const cwe = getCwe(vuln);
    const cvssObj = getCvss(vuln);
    const vulnerableVersionRange = getVulnerableVersionRange(vuln, dependency);
    return entityManager.create(Vulnerability, {
        cve,
        description: vuln.description,
        cwe,
        project,
        tool,
        severity: vuln.severity.toLowerCase(),
        ...cvssObj,
        vulnerableVersionRange,
    });
}

function getVulnerableVersionRange(vuln: DcVulnerability, dependency: Dependency) {
    // Slightly modified from here: https://stackoverflow.com/questions/37298968/regex-to-match-cpe-2-3/49588527
    // Added capturing of correct groups
    const rangeRegex = /cpe:2\.3:[aho](?::(?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+)(?::((?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+))(?::((?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+))(?::((?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+))(?::(?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+){6}$/;
    let totalRange = '';
    for (const vulnSoft of vuln.vulnerableSoftware) {
        const match = vulnSoft.software.id.match(rangeRegex);
        if (!match) {
            continue;
        }
        const name = match[1];
        if (name !== dependency.package.name) {
            continue;
        }
        const range = match[2].replace(/\|\\\|/g, '||').replace(/\\(?!=)/g, ' ').replace(/\\/g, '').trim();
        let addedRange = '';
        if (range === '*') {
            if (vulnSoft.software.versionStartIncluding) {
                addedRange += `>=${vulnSoft.software.versionStartIncluding}`;
            }
            if (vulnSoft.software.versionEndExcluding) {
                addedRange += ` <${vulnSoft.software.versionEndExcluding}`;
            }
        } else if (semver.validRange(range)) {
            addedRange = range;
        } else {
            console.log(`Unable to parse vulnerable range from ${match[0]}`);
        }
        const update = match[3];
        if (update !== '*') {
            if (semver.valid(addedRange)) {
                addedRange += `-${update}`;
            } else {
                console.log(`Couldn't add this vulnerability range ${JSON.stringify(vulnSoft)}`);
                continue;
            }
        }
        if (totalRange) {
            totalRange += ` || ${addedRange.trim()}`;
        } else {
            totalRange = addedRange.trim();
        }
    }
    return totalRange || undefined;
}

function getCvss(vuln: DcVulnerability) {
    if (vuln.cvssv3) {
        return {
            cvssScore: vuln.cvssv3.baseScore,
            cvssVersion: vuln.cvssv3.version,
        };
    } else if (vuln.cvssv2) {
        return {
            cvssScore: vuln.cvssv2.score,
            cvssVersion: vuln.cvssv2.version,
        };
    } else {
        return {};
    }
}

function getCwe(vuln: DcVulnerability) {
    if (vuln.cwes.length === 1) {
        return vuln.cwes[0];
    } else if (vuln.cwes.length > 1) {
        console.log(`Vulnerability contains multiple CWEs ${JSON.stringify(vuln)}`);
        return vuln.cwes[0];
    }
    return undefined;
}

function getCve(vuln: DcVulnerability) {
    const cveRegex = /CVE-\d{4}-\d{4,}/;
    const cveMatch = vuln.name.match(cveRegex);
    if (cveMatch) {
        return cveMatch[0];
    }
    if (vuln.source === 'NPM') {
        const cves: string[] = [];
        for (const reference of vuln.references) {
            const match = reference.name.match(cveRegex);
            if (match) {
                cves.push(match[0]);
            }
        }
        const uniqCves = _.uniq(cves);
        if (uniqCves.length > 1) {
            console.log(`Vulnerability contains multiple CVEs ${JSON.stringify(uniqCves)} ${JSON.stringify(vuln)}`);
            return uniqCves[0];
        } else if (uniqCves.length === 1) {
            return uniqCves[0];
        }
    }
    return undefined;
}

function getPurl(dep: DcDependency) {
    if (dep.packages?.length === 1) {
        return dep.packages[0].id;
    }
    return undefined;
}

function getDependencyPaths(dep: DcDependency, entityManager: EntityManager, dependency: Dependency) {
    const relatedDeps = dep.relatedDependencies || [];
    const dependencyPaths: DependencyPath[] = [
        entityManager.create(DependencyPath, {
            path: dep.filePath,
            dependency,
        }),
    ];
    for (const depPath of relatedDeps) {
        dependencyPaths.push(
            entityManager.create(DependencyPath, {
                path: depPath.filePath,
                dependency,
        }));
    }
    return dependencyPaths;
}

function isDependency(dep: DcDependency) {
    if (dep.evidenceCollected.productEvidence.length && dep.evidenceCollected.versionEvidence.length) {
        if (dep.evidenceCollected.productEvidence.length > 1 || dep.evidenceCollected.versionEvidence.length > 1) {
            return DependencySuitability.manualReview;
        } else {
            return DependencySuitability.accepted;
        }
    }
    return DependencySuitability.rejected;
}

export default {
    getDetectionTool,
    runScan,
};
