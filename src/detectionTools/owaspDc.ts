import { execSync, spawn } from 'child_process';
import { DetectionToolFunction } from '../interfaces/types';
import { getDetectionToolBase, getUniqueDepPaths, handleErrorsAndPromisify } from './util';
import path from 'path';
import fs from 'fs';
import _ from 'lodash';
import { EntityManager, getManager } from 'typeorm';
import { ManualReview } from '../entities/manualReview';
import { Dependency } from '../entities/dependency';
import { Package } from '../entities/package';
import { DependencyPath } from '../entities/dependencyPath';
import { Vulnerability } from '../entities/vulnerability';
import semver from 'semver';
import { ProjectError } from '../entities/projectError';
import { ToolExecution } from '../entities/toolExecution';
import perfHooks from 'perf_hooks';
const performance = perfHooks.performance;

const TOOL_NAME = 'Dependency-Check';

interface DcResultObject {
    reportSchema: string;
    scanInfo: {
        engineVersion: string;
        dataSource: {
            name: string;
            timestamp: string;
        }[];
        analysisExceptions?: {
            exception: {
                message: string;
                stackTrace: string[];
                cause: {
                    message: string;
                    stackTrace: string[];
                }
            }
        }[];
    }
    projectInfo: {
        name: string;
        reportDate: string;
        credits: {
            [source: string]: string;
        }
    }
    dependencies: DcDependency[];
}

interface DcDependencyBase {
    isVirtual: boolean;
    fileName: string;
    filePath: string;
    md5: string;
    sha1: string;
    sha256: string;
}

interface DcRelatedDependency extends DcDependencyBase {
    packageIds?: {
        id: string;
    }[];
}

interface DcEvidence {
    type: string;
    confidence: DcConfidence;
    source: string;
    name: string;
    value: string;
}

type DcConfidence = 'LOW' | 'MEDIUM' | 'HIGH' | 'HIGHEST';

interface DcVulnerability {
    source: string;
    name: string;
    unscored?: string;

    severity: string;
    cwes: string[];
    description: string;
    notes: string;
    references: {
        source: string;
        url?: string;
        name: string;
    }[];
    vulnerableSoftware: {
        software: {
            id: string;
            vulnerabilityIdMatched?: string;
            versionStartIncluding?: string;
            versionEndExcluding?: string;
        }
    }[];
    cvssv2?: {
        score: number;
        accessVector: string;
        accessComplexity: string;
        authenticationr: string;
        confidentialImpact: string;
        integrityImpact: string;
        availabilityImpact: string;
        severity: string;
        version: string;
        exploitabilityScore: string;
        impactScore: string;
    };
    cvssv3?: {
        baseScore: number;
        attackVector: string;
        attackComplexity: string;
        privilegesRequired: string;
        userInteraction: string;
        scope: string;
        confidentialityImpact: string;
        integrityImpact: string;
        availabilityImpact: string;
        baseSeverity: string;
        exploitabilityScore: string;
        impactScore: string;
        version: string;
    }
}

interface DcDependency extends DcDependencyBase {
    relatedDependencies?: DcRelatedDependency[];
    projectReferences?: string[];
    evidenceCollected: {
        vendorEvidence: DcEvidence[];
        productEvidence: DcEvidence[];
        versionEvidence: DcEvidence[];
    };
    packages?: {
        id: string;
        confidence: DcConfidence;
    }[];
    vulnerabilityIds?: {
        id: string;
        confidence: DcConfidence;
        url: string;
    }[];
    vulnerabilities?: DcVulnerability[];
}

const enum DependencySuitability {
    accepted,
    rejected,
    manualReview,
}

interface VulnerabilityDict {
    [id: string]: Vulnerability;
}

async function getDetectionTool() {
    const versionOutput = execSync('dependency-check.sh -v').toString().trim();
    const versionArray = versionOutput.split(' ');
    const version = versionArray[versionArray.length - 1];
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs, tool) => {
    const entityManager = getManager(TOOL_NAME);
    const cmd = `dependency-check.sh --prettyPrint --project ${project.name} -o ${resultsPath} -f JSON -f HTML -s .`;
    const start = performance.now();
    const child = spawn(cmd, { cwd: projectPath, shell: true });
    let exitCode: number;
    try {
        exitCode = await handleErrorsAndPromisify(child, project, tool, entityManager);
    } catch (err) {
        exitCode = 1;
    }
    const end = performance.now();
    console.log(`${TOOL_NAME} - Reading results from disk`);
    const resultFile = path.join(resultsPath, 'dependency-check-report.json');
    const res: DcResultObject = JSON.parse(fs.readFileSync(resultFile).toString());
    const dependencyCount = res.dependencies.length;
    const vulnerabilityCount = res.dependencies.reduce(
        (accumulator, currentValue) => accumulator + (currentValue.vulnerabilities?.length || 0),
        0,
    );
    const executionWithoutId = entityManager.create(ToolExecution, {
        dependencyCount,
        vulnerabilityCount,
        durationMs: end - start,
        exitCode,
        errorData: exitCode ? JSON.stringify(res.scanInfo.analysisExceptions) : undefined,
        project,
        tool,
    });

    const execution = await entityManager.save(ToolExecution, executionWithoutId);
    
    console.log(`${TOOL_NAME} - Saving results to database`);
    await saveResultsToDb(res.dependencies, execution, entityManager);
    if (res.scanInfo.analysisExceptions && res.scanInfo.analysisExceptions.length > 0) {
        const projErr = entityManager.create(ProjectError, {
            detectionTool: tool,
            project,
            phase: 'DEPS/VULN',
            message: `Analysis reported errors ${JSON.stringify(res.scanInfo.analysisExceptions)}`,
        });
        await entityManager.save(ProjectError, projErr);
    }
}

async function saveResultsToDb(dependencies: DcDependency[], toolExecution: ToolExecution, entityManager: EntityManager) {
    const manualReviews: ManualReview[] = [];
    const vulnerabilityDict: VulnerabilityDict = {};
    let dbDependencies: Dependency[] = [];
    for (const dep of dependencies) {
        switch (isDependency(dep)) {
            case DependencySuitability.accepted: {
                const pkg = entityManager.create(Package, {
                    name: dep.evidenceCollected.productEvidence[0].value,
                });
                const version = dep.evidenceCollected.versionEvidence[0].value;
                const purl = getPurl(dep) || 'NO_PURL';

                const dependency = entityManager.create(Dependency, {
                    toolExecution,
                    package: pkg,
                    version,
                    purl,
                });
                const vulnerabilities = getVulnerabilities(dep, entityManager, dependency, vulnerabilityDict, toolExecution);
                const dependencyPaths = getDependencyPaths(dep, pkg.name, version, entityManager);
                // Report can contain duplicates, filtering them
                // This is done here due to the possibility that the duplicate contains vulnerability dependency path information
                const duplicate = dbDependencies.find(
                    (dbDep) => dbDep.package.name === pkg.name && dbDep.version === version && dbDep.purl === purl
                );
                if (duplicate) {
                    if (vulnerabilities.length) {
                        duplicate.vulnerabilities = _.uniqBy(
                            duplicate.vulnerabilities.concat(vulnerabilities),
                            ['source', 'internalId'],
                        );
                        duplicate.dependencyPaths = duplicate.dependencyPaths.concat(dependencyPaths);
                    }
                    continue;
                } else {
                    dependency.vulnerabilities = vulnerabilities;
                dependency.dependencyPaths = dependencyPaths;
                }
                dbDependencies.push(dependency);
                break;
            }
            case DependencySuitability.manualReview: {
                console.log(`${TOOL_NAME} - Unclear dependency. Adding to database for manual review`);
                const mRev = entityManager.create(ManualReview, {
                    toolExecution,
                    reason: 'Too many productEvidences and versionEvidences',
                    data: JSON.stringify(dep),
                });
                manualReviews.push(mRev);
                break;
            }
            default: {
                continue;
            }
        }
    }

    dbDependencies = await entityManager.save(Dependency, dbDependencies);
    const depPaths = getUniqueDepPaths(dbDependencies);
    await entityManager.save(DependencyPath, depPaths);
    await entityManager.save(ManualReview, manualReviews);
}

function getVulnerabilities(dep: DcDependency, entityManager: EntityManager, dependency: Dependency, vulnDict: VulnerabilityDict, toolExecution: ToolExecution) {
    const vulnerabilities: Vulnerability[] = [];
    const dcVulnerabilities = dep.vulnerabilities || [];
    for (const vuln of dcVulnerabilities) {
        const id = vuln.source + vuln.name;
        if (!vulnDict[id]) {
            vulnDict[id] = createVulnerability(entityManager, vuln, toolExecution, dependency);
        }
        vulnerabilities.push(vulnDict[id]);
    }
    return vulnerabilities;
}

function createVulnerability(entityManager: EntityManager, vuln: DcVulnerability, toolExecution: ToolExecution, dependency: Dependency) {
    const cve = getCve(vuln);
    const cwe = getCwe(vuln);
    const npmId = getNpmId(vuln);
    const ghsaId = getGhsaId(vuln);
    const cvssObj = getCvss(vuln);
    const vulnerableVersionRange = getVulnerableVersionRange(vuln, dependency);
    return entityManager.create(Vulnerability, {
        cve,
        description: vuln.description,
        cwe,
        source: vuln.source,
        npmId,
        ghsaId,
        internalId: vuln.name,
        toolExecution,
        severity: vuln.severity.toLowerCase(),
        ...cvssObj,
        vulnerableVersionRange,
    });
}

function getGhsaId(vuln: DcVulnerability) {
    const ghsaRegex = /GHSA-\w+-\w+-\w+/;
    for (const reference of vuln.references) {
        const match = reference.name.match(ghsaRegex);
        if (match) {
            return match[0];
        }
    }
    return undefined;
}

function getNpmId(vuln: DcVulnerability) {
    if (vuln.source === 'NPM') {
        return vuln.name;
    }
    return undefined;
}

function getVulnerableVersionRange(vuln: DcVulnerability, dependency: Dependency) {
    // Slightly modified from here: https://stackoverflow.com/questions/37298968/regex-to-match-cpe-2-3/49588527
    // Added capturing of correct groups
    const rangeRegex = /cpe:2\.3:[aho](?::(?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+)(?::((?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+))(?::((?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+))(?::((?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+))(?::(?:[a-zA-Z0-9!"#$%&'()*+,\\\-_.\/;<=>?@\[\]^`{|}~]|\\:)+){6}$/;
    let totalRange = '';
    for (const vulnSoft of vuln.vulnerableSoftware) {
        const match = vulnSoft.software.id.match(rangeRegex);
        if (!match) {
            continue;
        }
        const name = match[1];
        if (name !== dependency.package.name) {
            continue;
        }
        const range = match[2].replace(/\|\\\|/g, '||').replace(/\\(?!=)/g, ' ').replace(/\\/g, '').trim();
        let addedRange = '';
        if (range === '*') {
            if (vulnSoft.software.versionStartIncluding) {
                addedRange += `>=${vulnSoft.software.versionStartIncluding}`;
            }
            if (vulnSoft.software.versionEndExcluding) {
                addedRange += ` <${vulnSoft.software.versionEndExcluding}`;
            }
        } else if (semver.validRange(range)) {
            addedRange = range;
        } else {
            console.log(`${TOOL_NAME} - Unable to parse vulnerable range from ${match[0]}`);
        }
        const update = match[3];
        if (update !== '*') {
            if (semver.valid(addedRange)) {
                addedRange += `-${update}`;
            } else {
                console.log(`${TOOL_NAME} - Couldn't add this vulnerability range ${JSON.stringify(vulnSoft)}`);
                continue;
            }
        }
        if (totalRange) {
            totalRange += ` || ${addedRange.trim()}`;
        } else {
            totalRange = addedRange.trim();
        }
    }
    return totalRange || undefined;
}

function getCvss(vuln: DcVulnerability) {
    if (vuln.cvssv3) {
        return {
            cvssScore: vuln.cvssv3.baseScore,
            cvssVersion: vuln.cvssv3.version,
        };
    } else if (vuln.cvssv2) {
        return {
            cvssScore: vuln.cvssv2.score,
            cvssVersion: vuln.cvssv2.version,
        };
    } else {
        return {};
    }
}

function getCwe(vuln: DcVulnerability) {
    if (vuln.cwes.length === 1) {
        return vuln.cwes[0];
    } else if (vuln.cwes.length > 1) {
        console.log(`${TOOL_NAME} - Vulnerability contains multiple CWEs ${JSON.stringify(vuln)}`);
        return vuln.cwes[0];
    }
    return undefined;
}

function getCve(vuln: DcVulnerability) {
    const cveRegex = /CVE-\d{4}-\d{4,}/;
    const cveMatch = vuln.name.match(cveRegex);
    if (cveMatch) {
        return cveMatch[0];
    }
        const cves: string[] = [];
        for (const reference of vuln.references) {
            const match = reference.name.match(cveRegex);
            if (match) {
                cves.push(match[0]);
            }
        }
        const uniqCves = _.uniq(cves);
        if (uniqCves.length > 1) {
            console.log(`${TOOL_NAME} - Vulnerability contains multiple CVEs ${JSON.stringify(uniqCves)} ${JSON.stringify(vuln)}`);
            return uniqCves[0];
        } else if (uniqCves.length === 1) {
            return uniqCves[0];
        }
    return undefined;
}

function getPurl(dep: DcDependency) {
    if (dep.packages?.length === 1) {
        return dep.packages[0].id;
    }
    return undefined;
}

function getDependencyPaths(dep: DcDependency, name: string, version: string, entityManager: EntityManager) {
    const projectReferences = dep.projectReferences || [];
    const dependencyPaths: DependencyPath[] = [];
    for (const ref of projectReferences) {
        // Slightly altered semver regex from https://semver.org/
        const semverRegex = new RegExp(/(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)(?:-(?:(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?:[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?(\/)/, 'gd');
        let resArr;
        let modifiedRef = ref;
        while((resArr = semverRegex.exec(ref) as any) !== null) {
            const slashIndex = resArr.indices[1][1];
            modifiedRef = ref.substr(0, slashIndex) + ',' + ref.substr(slashIndex + 1);
        }
        modifiedRef = modifiedRef.replace(/:/g, '@');
        modifiedRef = `${modifiedRef},${name}@${version}`;
        dependencyPaths.push(
            entityManager.create(DependencyPath, {
                path: modifiedRef,
        }));
    }
    return dependencyPaths;
}

function isDependency(dep: DcDependency) {
    if (dep.evidenceCollected.productEvidence.length && dep.evidenceCollected.versionEvidence.length) {
        if (dep.evidenceCollected.productEvidence.length > 1 || dep.evidenceCollected.versionEvidence.length > 1) {
            return DependencySuitability.manualReview;
        } else {
            return DependencySuitability.accepted;
        }
    }
    return DependencySuitability.rejected;
}

export default {
    getDetectionTool,
    runScan,
    TOOL_NAME,
};
