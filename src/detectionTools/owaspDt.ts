import { DetectionToolFunction } from '../interfaces/types';
import { getMergedCycloneDxBom, saveToDbWithErrorHandling, sleep } from '../util';
import fs from 'fs';
import path from 'path';
import axios from 'axios';
import config from '../config';
import { Project } from '../entities/project';
import { getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import FormData from 'form-data';
import { getDetectionToolBase } from './util';

const TOOL_NAME = 'Dependency-Track';
const axiosInstance = axios.create({
    baseURL: config.OWASP_DT_API_URL,
    headers: {
        'X-Api-Key': config.OWASP_DT_API_KEY,
    },
});

async function getDetectionTool() {
    const res = await axiosInstance.get('/version');
    const version = res.data.version;
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, packageJsonDirs, tool) => {
    const bom = await getMergedCycloneDxBom(packageJsonDirs);
    const bomJSON = bom.toJSON();
    const entityManager = getManager();
    let owaspDtProject: LookupProjectResponse;
    try {
        owaspDtProject = await createProject(project);
    } catch (err) {
        if (axios.isAxiosError(err)) {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `Failed to create owasp dt project code ${err.code}, message ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        } else {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `${TOOL_NAME} - Failed to create owasp dt project message: ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        }
        return;
    }

    let vulnerabilities: any;
    try {
        vulnerabilities = await getVulnerabilitiesForProject(bomJSON, owaspDtProject.uuid);
    } catch(err) {
        if (axios.isAxiosError(err)) {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `${TOOL_NAME} - Failed to get vulnerabilities for owasp dt project code ${err.response?.status}, message ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        } else {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `${TOOL_NAME} - Failed to get vulnerabilities for owasp dt project message: ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        }
        return;
    }
    fs.writeFileSync(path.join(resultsPath, 'owaspDtDep.json'), bomJSON);
    fs.writeFileSync(path.join(resultsPath, 'owaspDtVuln.json'), JSON.stringify(vulnerabilities, null, 2));
    
}

export default {
    runScan,
    getDetectionTool,
};

interface CreateProjectResponse {
    name: string;
    classifier: string;
    uuid: string;
    properties: any[];
    tags: any[];
    active: boolean;
}

async function createProject(project: Project): Promise<LookupProjectResponse> {
    try {
        const res = await axiosInstance.put<CreateProjectResponse>('/project', {
            name: project.name,
            classifier: "APPLICATION",
            active: true,
            tags: []
        });
        return res.data;
    } catch(err) {
        if (axios.isAxiosError(err)) {
            // If project already exists
            if (err.response?.status === 409) {
                console.log('Project already exists on DT server, finding it');
                return findProject(project);
            }
        }
        throw err;
    }
}

interface LookupProjectResponse {
    name: string;
    classifier: string;
    uuid: string;
    active: boolean;
}

async function findProject(project: Project) {
    const res = await axiosInstance.get<LookupProjectResponse>('/project/lookup', { params: { name: project.name }});
    return res.data;
}

interface BomPostResponse {
    token: string;
}

async function getVulnerabilitiesForProject(bomJSON: string, projectUuid: string) {
    const formData = new FormData();
    formData.append('project', projectUuid);
    formData.append('bom', bomJSON);
    console.log('Sending BOM to DT server');
    const res = await axiosInstance.post<BomPostResponse>(
        '/bom',
        formData,
        { headers: { 'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`} },
    );
    
    let scanInProgress = true;
    console.log('Polling DT server for vulnerability results');
    while (scanInProgress) {
        await sleep(2000);
        scanInProgress = await checkVulnerabilityScanningStatus(res.data.token);
    }
    console.log('Retrieving vulnerability results from DT server');
    const vulnRes = await axiosInstance.get(`/vulnerability/project/${projectUuid}`);
    return vulnRes.data;
}

interface TokenProcessingResponse {
    processing: boolean;
}

async function checkVulnerabilityScanningStatus(token: string) {
    const res = await axiosInstance.get<TokenProcessingResponse>(`/bom/token/${token}`);
    return res.data.processing;
}
