import { DetectionToolFunction } from '../interfaces/types';
import { checkPromisesForErrors, saveToDbWithErrorHandling, sleep } from '../util';
import fs from 'fs';
import path from 'path';
import axios from 'axios';
import config from '../config';
import { Project } from '../entities/project';
import { EntityManager, getManager } from 'typeorm';
import { ProjectError } from '../entities/projectError';
import FormData from 'form-data';
import {
    ensureOssIndexWebPageLoggedIn,
    getDetectionToolBase,
    getNpmIdFromOssIndexUrl,
    getOssIndexClient,
} from './util';
import _ from 'lodash';
import { DetectionTool } from '../entities/detectionTool';
import perfHooks from 'perf_hooks';
import { ToolExecution } from '../entities/toolExecution';
import { Dependency } from '../entities/dependency';
import { Package } from '../entities/package';
import { Vulnerability } from '../entities/vulnerability';
const performance = perfHooks.performance;
const cycloneDxBom = require('@cyclonedx/bom');

const ossIndexClient = getOssIndexClient();

interface CycloneDxComponent {
    type: string;
    "bom-ref": string;
    name: string;
    version: string;
    description: string;
    licenses?: {
        license: {
          id: string;
        }
    }[];
    purl: string;
    externalReferences?: {
        type: string;
        url: string;
    }[];
}
interface CycloneDxBom {
    bomFormat: string;
    specVersion: string;
    serialNumber?: string;
    version: number;
    metadata: {
        timestamp: string;
        tools: {
            vendor: string;
            name: string;
            version: string;
        }[];
        component: CycloneDxComponent;
    };
    components: CycloneDxComponent[];
}

interface DtComponent {
    name: string;
    version: string;
    classifier: string;
    purl: string;
    purlCoordinates: string;
    description: string;
    resolvedLicense?: {
        uuid: string;
        name: string;
        licenseId: string;
        isOsiApproved: boolean;
        isFsfLibre: boolean;
        isDeprecatedLicenseId: boolean;
    };
    project: {
        name: string;
        classifier: string;
        uuid: string;
        lastBomImport: number;
        lastBomImportFormat: string;
        lastInheritedRiskScore: number;
        active: boolean;
    };
    lastInheritedRiskScore: number;
    uuid: string;
    usedBy: number;
    isInternal: boolean;
}

interface DtVulnerability {
    vulnId: string;
    source: string;
    title: string;
    subTitle?: string;
    description: string;
    recommendation?: string;
    credits?: string;
    created?: number;
    published?: number;
    updated?: number;
    vulnerableVersions?: string;
    patchedVersions?: string;
    references: string;
    cwe?: {
      cweId: number;
      name: string;
    };
    cvssV2BaseScore?: number;
    cvssV2ImpactSubScore?: number;
    cvssV2ExploitabilitySubScore?: number;
    cvssV2Vector?: string;
    cvssV3BaseScore?: number;
    cvssV3ImpactSubScore?: number;
    cvssV3ExploitabilitySubScore?: number;
    cvssV3Vector?: string;
    severity: string;
    components: DtComponent[];
    uuid: string;
    affectedProjectCount: number;
}

const TOOL_NAME = 'Dependency-Track';
const axiosInstance = axios.create({
    baseURL: `${config.OWASP_DT_API_URL}/${config.OWASP_DT_API_VERSION}`,
    headers: {
        'X-Api-Key': config.OWASP_DT_API_KEY,
    },
});

async function getDetectionTool() {
    const res = await axiosInstance.get(`${config.OWASP_DT_API_URL}/version`);
    const version = res.data.version;
    return getDetectionToolBase(TOOL_NAME, version);
}

const runScan: DetectionToolFunction = async (project, projectPath, resultsPath, lockfileDirs, tool) => {
    console.log(`${TOOL_NAME} - Get BOM`);
    const { bom, dependencyCount } = await getMergedCycloneDxBom(lockfileDirs);
    const bomJSON = bom.toJSON();
    const bomObj: CycloneDxBom = JSON.parse(bomJSON);
    const entityManager = getManager(TOOL_NAME);
    const owaspDtProject = await getDtProject(project, entityManager, tool);
    const start = performance.now();
    const dtVulns = await getDtVulnerabilities(bomJSON, owaspDtProject.uuid, project, tool, entityManager);
    const end = performance.now();

    const toolExec = entityManager.create(ToolExecution, {
        durationMs: end - start,
        exitCode: 0,
        dependencyCount,
        project,
        tool,
        vulnerabilityCount: dtVulns.length,
    });

    const toolExecution = await entityManager.save(ToolExecution, toolExec);

    const uniqueDtVulns = mergeDtVulnComponents(dtVulns);
    const dependencies = getDependencies(bomObj, toolExecution, entityManager);

    console.log(`${TOOL_NAME} - Ensure logged in on Sonatype OSS Index website`);
    await ensureOssIndexWebPageLoggedIn(ossIndexClient, TOOL_NAME);

    await enrichDependenciesWithVulnerabilities(uniqueDtVulns, dependencies, toolExecution, entityManager);
    console.log(`${TOOL_NAME} - saving results to database`);
    await entityManager.save(Dependency, dependencies, { chunk: 10000 });

    console.log(`${TOOL_NAME} - backing up data to files`);
    fs.writeFileSync(path.join(resultsPath, 'owaspDtDep.json'), bomJSON);
    fs.writeFileSync(path.join(resultsPath, 'owaspDtVuln.json'), JSON.stringify(dtVulns, null, 2));
    
}

export default {
    runScan,
    getDetectionTool,
    TOOL_NAME,
};

function mergeDtVulnComponents(dtVulns: DtVulnerability[]) {
    dtVulns.sort((a, b) => {
        if (a.uuid > b.uuid) {
            return 1;
        } else if (a.uuid < b.uuid) {
            return -1;
        } else {
            return 0;
        }
    });
    const dtVulnsUnique: DtVulnerability[] = [];
    let k = -1;
    for (let i = 0; i < dtVulns.length; ++i) {
        if (i === 0) {
            dtVulnsUnique.push(dtVulns[i]);
            ++k;
        } else {
            if (dtVulnsUnique[k].uuid === dtVulns[i].uuid) {
                dtVulnsUnique[k].components = dtVulnsUnique[k].components.concat(dtVulns[i].components);
            } else {
                ++k;
                dtVulnsUnique[k] = dtVulns[i];
            }
        }
    }
    return dtVulnsUnique;
}

async function enrichDependenciesWithVulnerabilities(
    dtVulnerabilities: DtVulnerability[],
    dependencies: Dependency[],
    toolExec: ToolExecution,
    entityManager: EntityManager,
) {
    for (const dtVuln of dtVulnerabilities) {
        const vulnerability = await createVulnerability(dtVuln, entityManager, toolExec);

        if (!dtVuln.components || !dtVuln.components.length) {
            throw new Error(`${TOOL_NAME} - Vulnerability missing affected component ${JSON.stringify(dtVuln)}`);
        }
        for (const dep of dtVuln.components) {
            const dependency = dependencies.find((dbDep) => dbDep.purl === dep.purl);
            if (!dependency) {
                console.log(`${TOOL_NAME} - Couldn't map vulnerability's component back to dependency`);
                throw new Error(`Should have found corresponding dependency to match the dependency inside vulnerability`);
            }
            if (dependency.vulnerabilities) {
                dependency.vulnerabilities.push(vulnerability);
            } else {
                dependency.vulnerabilities = [vulnerability];
            }
        }
    }
}

function getGhsaId(dtVuln: DtVulnerability) {
    const ghsaRegex = /GHSA-\w+-\w+-\w+/;
    const match = dtVuln.references.match(ghsaRegex);
    if (match) {
        return match[0];
    }
    return undefined;
}

async function getNpmId(dtVuln: DtVulnerability) {
    if (dtVuln.source === 'NPM') {
        return dtVuln.vulnId;
    } else if (dtVuln.source === 'OSSINDEX') {
        const sonatypeUrlRegex = /\((https:\/\/ossindex\.sonatype\.org\/vulnerability\/.+?)\)/;
        const match = dtVuln.references.match(sonatypeUrlRegex);
        if (match) {
            const url = match[1].split('?')[0];
            return getNpmIdFromOssIndexUrl(url, ossIndexClient, TOOL_NAME);
        }
    }
    return undefined;
}

function getCvssInfo(dtVuln: DtVulnerability) {
    if (dtVuln.cvssV3BaseScore !== undefined) {
        const cvssVersionRegex = /^CVSS:(\d\.\d)/;
        const cvssVersionMatch = dtVuln.cvssV3Vector?.match(cvssVersionRegex);
        return {
            cvssScore: dtVuln.cvssV3BaseScore,
            cvssVector: dtVuln.cvssV3Vector,
            cvssVersion: cvssVersionMatch ? cvssVersionMatch[1] : undefined,
        };
    } else if (dtVuln.cvssV2BaseScore !== undefined) {
        return {
            cvssScore: dtVuln.cvssV2BaseScore,
            cvssVector: dtVuln.cvssV2Vector,
            cvssVersion: '2.0',
        };
    } else {
        return {};
    }
}

function getCve(vuln: DtVulnerability) {
    const cveRegex = /CVE-\d{4}-\d{4,}/;
    const cveMatch = vuln.vulnId.match(cveRegex);
    if (cveMatch) {
        return cveMatch[0];
    }

    const cveRefMatch = vuln.references.match(cveRegex);
    if (cveRefMatch) {
        return cveRefMatch[0];
    }
    return undefined;
}

function getDependencies(bom: CycloneDxBom, toolExec: ToolExecution, entityManager: EntityManager) {
    const dependencies: Dependency[] = [];
    for (const dep of bom.components) {
        dependencies.push(entityManager.create(Dependency, {
            package: entityManager.create(Package, { name: dep.name }),
            purl: dep.purl,
            toolExecution: toolExec,
            version: dep.version,
        }));
    }
    return dependencies;
}

async function getDtProject(project: Project, entityManager: EntityManager, tool: DetectionTool) {
    try {
        return await createProject(project);
    } catch (err) {
        if (axios.isAxiosError(err)) {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `Failed to create owasp dt project code ${err.code}, message ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        } else {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `${TOOL_NAME} - Failed to create owasp dt project message: ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        }
        throw err;
    }
}

interface CreateProjectResponse {
    name: string;
    classifier: string;
    uuid: string;
    properties: any[];
    tags: any[];
    active: boolean;
}

async function createProject(project: Project): Promise<LookupProjectResponse> {
    try {
        const res = await axiosInstance.put<CreateProjectResponse>('/project', {
            name: project.name,
            classifier: "APPLICATION",
            active: true,
            tags: []
        });
        return res.data;
    } catch(err) {
        if (axios.isAxiosError(err)) {
            // If project already exists
            if (err.response?.status === 409) {
                console.log(`${TOOL_NAME} - Project already exists on DT server, finding it`);
                return findProject(project);
            }
        }
        throw err;
    }
}

interface LookupProjectResponse {
    name: string;
    classifier: string;
    uuid: string;
    active: boolean;
}

async function findProject(project: Project) {
    const res = await axiosInstance.get<LookupProjectResponse>('/project/lookup', { params: { name: project.name }});
    return res.data;
}

interface BomPostResponse {
    token: string;
}

async function getDtVulnerabilities(bomJSON: string, projectUuid: string, project: Project, tool: DetectionTool, entityManager: EntityManager) {
    const formData = new FormData();
    formData.append('project', projectUuid);
    formData.append('bom', bomJSON);
    console.log(`${TOOL_NAME} - Sending BOM to DT server`);
    try {
        const res = await axiosInstance.post<BomPostResponse>(
            '/bom',
            formData,
            { headers: { 'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`} },
        );
        
        let scanInProgress = true;
        console.log(`${TOOL_NAME} - Polling DT server for vulnerability results`);
        while (scanInProgress) {
            await sleep(2000);
            scanInProgress = await checkVulnerabilityScanningStatus(res.data.token);
        }
        console.log(`${TOOL_NAME} - Retrieving vulnerability results from DT server`);
        const vulnRes = await axiosInstance.get<DtVulnerability[]>(`/vulnerability/project/${projectUuid}`);
        return vulnRes.data;
    } catch(err) {
        if (axios.isAxiosError(err)) {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `${TOOL_NAME} - Failed to get vulnerabilities for owasp dt project code ${err.response?.status}, message ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        } else {
            const projectError = entityManager.create(ProjectError, {
                phase: 'DEPS/VULN',
                message: `${TOOL_NAME} - Failed to get vulnerabilities for owasp dt project message: ${err.message}`,
                project,
                detectionTool: tool,
            });
            console.log(JSON.stringify(projectError));
            await saveToDbWithErrorHandling(entityManager, ProjectError, projectError);
        }
        throw err;
    }
}

async function createVulnerability(dtVuln: DtVulnerability, entityManager: EntityManager, toolExecution: ToolExecution) {
    return entityManager.create(Vulnerability, {
        cve: getCve(dtVuln),
        cwe: dtVuln.cwe?.cweId.toString(),
        ...getCvssInfo(dtVuln),
        description: dtVuln.description,
        npmId: await getNpmId(dtVuln),
        ghsaId: getGhsaId(dtVuln),
        internalId: dtVuln.vulnId,
        source: dtVuln.source,
        severity: dtVuln.severity,
        toolExecution,
        vulnerableVersionRange: dtVuln.vulnerableVersions,
    });
}

interface TokenProcessingResponse {
    processing: boolean;
}

async function checkVulnerabilityScanningStatus(token: string) {
    const res = await axiosInstance.get<TokenProcessingResponse>(`/bom/token/${token}`);
    return res.data.processing;
}

async function getMergedCycloneDxBom(lockfileDirs: string[]) {
    // Default cyclonedx/bom options
    const componentType = 'library';
    const includeSerialNumber = true;
    const includeLicenseText = false;
    // We want to include dev dependencies as well
    const readInstalledOptions = { dev: true };
    const componentPromises = [];
    let components: any[] = [];
    let rootBom: any;
    
    for (const lockfileDir of lockfileDirs) {
        componentPromises.push(new Promise<number>((resolve, reject) => {
            cycloneDxBom.createbom(componentType, includeSerialNumber, includeLicenseText, lockfileDir, readInstalledOptions, (err: any, bom: any) => {
                components = components.concat(bom.components);
                // Package JSON dirs originate from a find -command which puts the root package.json dir as last
                // If there is no root package.json then this will just be the last search result
                if (lockfileDir === lockfileDirs[lockfileDirs.length - 1]) {
                    rootBom = bom;
                }
                resolve(bom.components.length);
            });
        }));
    }

    const promises = await Promise.allSettled(componentPromises);
    checkPromisesForErrors(promises);

    const uniqComponents = _.uniqBy(components, (comp) => comp.purl);
    console.log(`${TOOL_NAME} - Found a total of ${components.length} of dependencies of which ${uniqComponents.length} are unique which means that there are ${components.length - uniqComponents.length} duplicate dependencies`);
    rootBom.components = uniqComponents;
    return {
        bom: rootBom,
        dependencyCount: components.length,
    };
}
