import fs from 'fs';
import Path from 'path';
import FindPackageJson from 'find-package-json';
import { execSync } from 'child_process';
import { SelectedProject, SelectedProjectsObject, SelectedProjectWithHash } from './interfaces/types';
import { runDetectionWithAllTools } from './detectionTools';

const TMP_DIR_PATH = Path.join(__dirname, '../tmp');
const FAILED_PROJECTS_FILE = Path.join(__dirname, '../failed.txt');
const RESULTS_PATH = Path.join(__dirname, '../results');

export async function analyze(inputFile: string) {
    const { items: projects }: SelectedProjectsObject = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));
    for (const project of projects) {
        const downloadedProject = downloadProject(project);
        await installDependencies(downloadedProject);
        await detectVulnerabilities(downloadedProject,);
    }
}

function downloadProject(project: SelectedProject): SelectedProjectWithHash {
    // Clear tmp dir
    if (fs.existsSync(TMP_DIR_PATH)) {
        fs.rmdirSync(TMP_DIR_PATH, { recursive: true });
    }

    fs.mkdirSync(TMP_DIR_PATH);

    execSync(`git clone --depth 1 ${project.gitUrl} .`, { cwd: TMP_DIR_PATH });
    const commitHash = execSync('git rev-parse HEAD', { cwd: TMP_DIR_PATH }).toString().trim();
    return {
        ...project,
        commitHash,
    };
}

async function installDependencies(project: SelectedProjectWithHash) {
    let npmCiFailed = true;
    const finder = FindPackageJson(TMP_DIR_PATH);
    let currentPackageJson = finder.next();
    if (!currentPackageJson.filename) {
        throw new Error('No package.json file at all');
    }
    do {
        const dir = currentPackageJson.filename.replace(new RegExp(`package.json$`), '');

        // Check if lock file exists and run npm ci if so. Otherwise run npm install
        if (fs.existsSync(Path.join(dir, 'package-lock.json')) || fs.existsSync(Path.join(dir, 'npm-shrinkwrap.json'))) {
            try {
                execSync('npm ci', { cwd: dir });
                console.log(`Succesfully installed dependencies using npm ci in dir: ${dir}`);
                npmCiFailed = false;
            } catch (err) {
                console.log('npm ci failed with error', err, project, dir);
                console.log('Running npm install instead');
            }
        }

        if (npmCiFailed) {
            try {
                execSync('npm install', { cwd: dir });
                console.log(`Successfully installed dependencies using npm install in dir: ${dir}`);
            } catch (err) {
                console.log('npm install failed with error', err, project, dir);
                logFailedProject(project, `installing dependencies failed with error message: ${err.message}`);
            }
        }
        currentPackageJson = finder.next();
    } while (!currentPackageJson.done);
}

async function detectVulnerabilities(project: SelectedProjectWithHash) {
    runDetectionWithAllTools(project, TMP_DIR_PATH, RESULTS_PATH);
}

function logFailedProject(project: SelectedProjectWithHash, message: string) {
    const data = `${project.name}#${project.commitHash} - ${message}`;
    if (!fs.existsSync(FAILED_PROJECTS_FILE)) {
        fs.writeFileSync(FAILED_PROJECTS_FILE, data);
    } else {
        fs.appendFileSync(FAILED_PROJECTS_FILE, data);
    }
}
