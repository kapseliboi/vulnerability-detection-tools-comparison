import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { createConnection, getConnectionOptions } from 'typeorm';
import { analyze, Options as  CliAnalyzeOptions } from './commands/analyze';
import { select, Options as CliSelectOptions } from './commands/select';
import {
    randomizeSearchResultItemOrder,
    Options as RandOptions,
} from './commands/randomizeSearchResultItemOrder';
import config from './config';

import 'reflect-metadata';

async function initDbConnection() {
    const connectionOptions = await getConnectionOptions();
    Object.assign(connectionOptions, {
        entities: config.usingTsNode ? ['src/entities/**/*.ts'] : ['build/entities/**/*.js'],
        migrations: config.usingTsNode ? ['src/migrations/**/*.ts'] : ['build/migrations/**/*.js'],
    });
    await createConnection(connectionOptions);
}

async function main() {
    console.log('Initializing database connection');
    await initDbConnection();
    console.log('Initialize yargs for parsing commands');
    const _argv = yargs(hideBin(process.argv))
        .command<CliAnalyzeOptions>(
            'analyze',
            'Analyze projects from database or from an input JSON file',
            (analyzeYargs) => {
                analyzeYargs.positional('inputFile', { type: 'string', describe: 'path to project input file' });
                analyzeYargs.options('skip', { type: 'number', describe: 'Skip x amount of projects' });
                analyzeYargs.options('take', { type: 'number', describe: 'Only analyze x amount of projects'});
                analyzeYargs.options('no-download-or-install', { type: 'boolean', default: false, describe: 'Trust that the project is already in the TMP_DIR. This only works for a single project'});
            },
            async (argv) => {
                await analyze({
                    skip: argv.skip,
                    take: argv.take,
                    inputFile: argv.inputFile,
                    noDownloadOrInstall: argv.noDownloadOrInstall,
                });
                process.exit(0);
            })
        .command<CliSelectOptions>(
            'select',
            'Select projects from a JSON file',
            (selectYargs) => {
                selectYargs.option('inputFiles', { type: 'array', describe: 'paths to project input files' })
                    .demandOption('inputFiles');
                selectYargs.option('groupSize', { type: 'number', describe: `If multiple input files then handle projects in groups of this size. Each group will have relative representation of each input file's projects. E.g. if input file A has 50 projects and input file B has 25 projects and groupSize is set to 10 then projects will be analyzed in groups consisting of 7 projects from A and 3 projects from B.`, });
                selectYargs.options('minDepCount', { type: 'number', default: 100, describe: 'Minimum amount of dependencies the project has to have. Default value is 100' });
                selectYargs.options('limit', { type: 'number', default: 0, describe: 'Limit the amount of projects gathered for manual review per input file' });
                selectYargs.options('no-download-or-install', { type: 'boolean', default: false, describe: 'Trust that the project is already in the TMP_DIR. This only works for a single project'});
            },
            async (argv) => {
                await select({
                    inputFiles: argv.inputFiles,
                    minDepCount: argv.minDepCount,
                    noDownloadOrInstall: argv.noDownloadOrInstall,
                    groupSize: argv.groupSize,
                    limit: argv.limit,
                });
                process.exit(0);
            }
        )
        .command<RandOptions>(
            'randomizeSearchResultItemOrder',
            'Randomizes the order of GitHub Search result items within search results and overwrites the supplied files with the new random order',
            (randYargs) => {
                randYargs.option('inputFiles', { type: 'array' });
                randYargs.demandOption('inputFiles');
            },
            async (argv) => {
                await randomizeSearchResultItemOrder({
                    inputFiles: argv.inputFiles,
                });
                process.exit(0);
            }
        )
        .help('h')
        .alias('h', 'help')
        .argv;
}

main();