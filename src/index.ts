import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { createConnection, getConnectionOptions } from 'typeorm';
import { execute, Options as  CliExecuteOptions } from './commands/execute';
import { select, Options as CliSelectOptions } from './commands/select';
import { deleteForks, Options as CliForkDeleteOptions } from './commands/deleteForks';
import { deleteProjects, Options as CliProjectDeleteOptions } from './commands/deleteProjects';
import { deleteToolExecutions, Options as CliToolExecutionDeleteOptions } from './commands/deleteToolExecutions';
import { randomCommit, Options as RandomCommitOptions } from './commands/randomCommit';
import {
    randomizeSearchResultItemOrder,
    Options as RandOptions,
} from './commands/randomizeSearchResultItemOrder';
import config from './config';

import 'reflect-metadata';

interface CliDeleteTypeOptions {
    type: 'project' | 'fork' | 'execution';
}

type CliDeleteOptions = CliDeleteTypeOptions
    & CliForkDeleteOptions
    & CliProjectDeleteOptions
    & CliToolExecutionDeleteOptions;

async function initDbConnection() {
    const connectionOptions = await getConnectionOptions();
    Object.assign(connectionOptions, {
        entities: config.usingTsNode ? ['src/entities/**/*.ts'] : ['build/entities/**/*.js'],
        migrations: config.usingTsNode ? ['src/migrations/**/*.ts'] : ['build/migrations/**/*.js'],
    });
    await createConnection(connectionOptions);
}

async function main() {
    console.log('Initializing database connection');
    await initDbConnection();
    console.log('Initialize yargs for parsing commands');
    const _argv = yargs(hideBin(process.argv))
        .command<CliExecuteOptions>(
            'execute',
            'Execute all vulnerability detection tools for projects from database or from an input JSON file and gather the results into database',
            (executeYargs) => {
                executeYargs.positional('inputFile', { type: 'string', describe: 'path to project input file' });
                executeYargs.options('skip', { type: 'number', describe: 'Skip x amount of projects' });
                executeYargs.options('take', { type: 'number', describe: 'Only execute tools for x amount of projects'});
                executeYargs.options('no-download-or-install', { type: 'boolean', default: false, describe: 'Trust that the project is already in the TMP_DIR. This only works for a single project'});
                executeYargs.options('project', { type: 'string', describe: 'Name of the only project for which the tools are executed' });
                executeYargs.options('use-result-files', { type: 'boolean', default: false, describe: `NOTE: Dependabot and Whitesource are not supported because saving the plain results would be tricky. If this is enabled then vulnerability detection tools won't be run and existing result files are used. If they are not available the program crashes`});
            },
            async (argv) => {
                await execute(argv);
                process.exit(0);
            })
        .command<CliSelectOptions>(
            'select',
            'Select projects from a JSON file',
            (selectYargs) => {
                selectYargs.option('inputFiles', { type: 'array', describe: 'paths to project input files' })
                    .demandOption('inputFiles');
                selectYargs.option('groupSize', { type: 'number', default: 0, describe: `If you have multiple input files and you are not sure if you can analyze all of them specify a group size which will be used when manually selecting the projects. The point of group size is to maintain the relative sizes between input files. E.g. you have inputfile A with 600 projects that pass the automatic filters and inputfile B with 200 projects that also pass the filters but you only want to have 100 projects but you wish that 3/4 of the manually selected projects are from inputfile A and rest from B then specifying a group size of 100 will make it so that manual review offers you projects from inputfile A until you have selected 75 projects and then projects from inputfile B until 25 are chosen. After that a message is printed which shows that the group is now handled and then the next group of the same size will begin.` });
                selectYargs.options('minDepCount', { type: 'number', default: 100, describe: 'Minimum amount of dependencies the project has to have. Default value is 100' });
                selectYargs.options('limit', { type: 'number', default: 0, describe: 'Limit the amount of projects gathered for manual review per input file' });
                selectYargs.options('no-download-or-install', { type: 'boolean', default: false, describe: 'Trust that the project is already in the TMP_DIR. This only works for a single project'});
                selectYargs.options('filteredProjectsFile', { type: 'string', describe: 'Provide a backed up file of automatically filtered projects. The program automatically saves this type of file with name "automaticallyFilteredProjects-${timestamp}.json'});
                selectYargs.options('noForking', { type: 'boolean', default: false, desc: 'Skip forking and forking related checks of projects entirely' });
            },
            async (argv) => {
                await select(argv);
                process.exit(0);
            }
        )
        .command<RandOptions>(
            'randomizeSearchResultItemOrder',
            'Randomizes the order of GitHub Search result items within search results and overwrites the supplied files with the new random order',
            (randYargs) => {
                randYargs.option('inputFiles', { type: 'array' });
                randYargs.demandOption('inputFiles');
            },
            async (argv) => {
                await randomizeSearchResultItemOrder(argv);
                process.exit(0);
            }
        )
        .command<CliDeleteOptions>(
            'delete <type>',
            'Tries to delete specified type of stuff. Currently supports project, toolExecution and fork',
            (deleteYargs) => {
                deleteYargs.positional('type', { type: 'string', choices: ['project', 'fork', 'execution'] });
                deleteYargs.options('after', { type: 'string', desc: 'Only delete forks updated after the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. NOTE: This removes forks from GitHub directly and doesn\'t check the database at all.' });
                deleteYargs.options('before', { type: 'string', desc: 'Only delete forks updated before the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. NOTE: This removes forks from GitHub directly and doesn\'t check the database at all.' });
                deleteYargs.options('project', { type: 'string', desc: 'If deleting a project you can use this option to give the name of the project you want to delete to avoid deleting other projects'});
                deleteYargs.options('toolExecutionId', { type: 'number', desc: 'If deleting a tool execution you can use this option to give the id of the tool execution you want to delete to avoid deleting other executions '});
                deleteYargs.options('copyExecutionDuration', { type: 'boolean', default: false, desc: 'If deleting a tool execution then copy its durationMs to all similar (same project and tool) tool executions'});
                deleteYargs.options('toolId', { type: 'number', desc: 'Tool id to narrow down deletions of tool executions' });
            },
            async (argv) => {
                if (argv.type === 'fork') {
                    await deleteForks(argv);
                } else if (argv.type === 'project') {
                    await deleteProjects(argv);
                } else if (argv.type === 'execution') {
                    await deleteToolExecutions(argv);
                } else {
                    throw new Error(`Unknown type specified for delete: ${argv.type}`);
                }
                process.exit(0);
            }
        )
        .command<RandomCommitOptions>(
            'randomCommit',
            'Pushes a random commmit to all forked projects in the database',
            (randomCommitYargs) => {
                randomCommitYargs.options('skip', { type: 'number', default: 0, describe: 'Skip x amount of projects' });
                randomCommitYargs.options('take', { type: 'number', default: undefined, describe: 'Only push to x amount of projects'});
            },
            async (argv) => {
                await randomCommit(argv);
                process.exit(0);
            },
        )
        .help('h')
        .alias('h', 'help')
        .argv;
}

main();