import { execSync, spawn } from 'child_process';
import { EntityManager, EntityTarget, getManager } from 'typeorm';
import fs from 'fs';
import path from 'path';
import { Project } from './entities/project';
import config from './config';
import { ProjectError } from './entities/projectError';
import { GraphQLClient } from 'graphql-request';
import axios from 'axios';

export function defaultDatabaseErrorHandler<T>(obj: T, err: any) {
    const errMsg = `Error when saving ${JSON.stringify(obj)} to database: ${err && err.message}}`;
    console.error(errMsg);
    throw new Error(errMsg);
}

export async function saveToDbWithErrorHandling<Entity>(
    entityManager: EntityManager,
    type: EntityTarget<Entity>,
    obj: Entity,
) {
    try {
        return await entityManager.save(type, obj);
    } catch (error) {
        defaultDatabaseErrorHandler(obj, error);
    }
    throw new Error('Should not be reached');
}

export function sleep(ms: number) {
    return new Promise((resolve, reject) => setTimeout(resolve, ms));
}

export async function doRequestWithRetry<T>(client: GraphQLClient, query: string) {
    let requestCounter = 0;
    while (true) {
        try {
            ++requestCounter;
            return await client.request<T>(query);
        } catch (err) {
            const sleepTimeSeconds = requestCounter * 2;
            if (err?.response?.errors[0].type === 'NOT_FOUND') {
                throw err;
            }
            if (err?.response.errors[0].message) {
                console.log(`GitHub API request failed with error code ${err.response.errors[0].message}. Retrying in ${sleepTimeSeconds} seconds`);
            } else {
                console.log(`GitHub API request failed. Retrying in ${sleepTimeSeconds} seconds`);
            }
            await sleep(sleepTimeSeconds * 1000);
        }
    }
}

export async function downLoadProjectAndInstallDependencies(
    project: Project,
    useLatestCommit: boolean = false,
    useFork: boolean = false,
    skipDownloadAndInstall: boolean = false,
) {
    const entityManager = getManager();
    if (skipDownloadAndInstall) {
        return findLockfileDirs();
    }
    try {
        downloadProject(project, useLatestCommit, useFork);
    } catch (err) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'DOWNLOAD', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
        );
        return [];
    }

    const lockfileDirs = findLockfileDirs();

    try {
        await installDependencies(project, lockfileDirs);
    } catch (err) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'INSTALL', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
        );
        return [];
    }
    return lockfileDirs;
}

export function downloadProject(project: Project, useLatestCommit: boolean, useFork: boolean) {
    // Clear tmp dir
    if (fs.existsSync(config.TMP_DIR_PATH)) {
        fs.rmSync(config.TMP_DIR_PATH, { recursive: true });
    }

    fs.mkdirSync(config.TMP_DIR_PATH);

    console.log(`Cloning project${useFork ? ' using fork' : ''} ${JSON.stringify(useLatestCommit ? { ...project, commitHash: 'LATEST' } : project, null, 2)}`);
    const gitUrl = useFork ? `${config.GITHUB_URL}/${project.forkedName}` : `${config.GITHUB_URL}/${project.name}`;
    if (useLatestCommit) {
        execSync(`git clone ${gitUrl} .`, { cwd: config.TMP_DIR_PATH });
        project.commitHash = execSync('git rev-parse HEAD', { cwd: config.TMP_DIR_PATH }).toString().trim();
    } else {
        execSync(`git clone ${gitUrl} . && git checkout ${project.commitHash}`, { cwd: config.TMP_DIR_PATH });
    }
}

function findLockfileDirs() {
    const foundLockfilesTxt = execSync(
        String.raw`find "$(pwd)" \( -name "package-lock.json" -o -name "yarn.lock" -o -name "npm-shrinkwrap.json" \) -not -path "*/node_modules/*"`,
        { cwd: config.TMP_DIR_PATH },
        ).toString();
    const foundLockfileDirs = foundLockfilesTxt
        .split('\n')
        .filter((packageJsonDir) => packageJsonDir.length > 0)
        .map((dir) => dir.replace(new RegExp(`package-lock\.json$|yarn\.lock$|npm-shrinkwrap\.json$`), ''));
    if (foundLockfileDirs.length === 0) {
        throw new Error('No package.json file at all');
    }
    return foundLockfileDirs;
}

export const supportedLockfilesRegex = /\/?(?:package-lock\.json|yarn\.lock|npm-shrinkwrap\.json)$/;

export async function installDependencies(project: Project, lockfileDirs: string[]) {
    const installPromises = [];
    for (const dir of lockfileDirs) {
        // Check if lock file exists and run npm ci if so. Otherwise run npm install
        if (fs.existsSync(path.join(dir, 'package-lock.json')) || fs.existsSync(path.join(dir, 'yarn.lock')) || fs.existsSync(path.join(dir, 'npm-shrinkwrap.json'))) {
            console.log('Creating an npm ci promise');
            installPromises.push(promisifyInstallSpawn(
                'npm',
                ['ci', '--ignore-scripts'],
                dir,
                (resolve, reject) => (err) => {
                    console.log('npm ci failed with error', err, project, dir);
                    console.log('Running npm install instead');
                    resolve(promisifyNpmInstall(project, dir));
                },
                (resolve, reject) => (code, signal) => {
                    if (code === 0) {
                        console.log(`Succesfully installed dependencies using npm ci in dir: ${dir}`);
                        resolve();
                    } else {
                        console.log(`Running npm ci in dir: ${dir} failed with code ${code} and signal ${signal}`);
                        reject({ code, signal });
                    }
                },
            ));
        } else {
            installPromises.push(promisifyNpmInstall(project, dir));
        }
    }

    const promises = await Promise.allSettled(installPromises);
    checkPromisesForErrors(promises);
}

export function checkPromisesForErrors(promises: PromiseSettledResult<any>[]) {
    const reasons: any[] = [];
    for (const prom of promises) {
        if (prom.status === 'rejected') {
            reasons.push(prom.reason);
        }
    }
    if (reasons.length) {
        throw new Error(reasons.join('\n'));
    }
}

function promisifyInstallSpawn(
    cmd: string,
    args: string[],
    cwd: string,
    errorHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (err: Error) => void,
    exitHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (code: number | null, signal: NodeJS.Signals | null) => void,
): Promise<void> {
    const childProc = spawn(cmd, args, { cwd });
    return new Promise((resolve, reject) => {
        childProc.on('error', errorHandler(resolve, reject));
        childProc.on('exit', exitHandler(resolve, reject));
    });
}

function promisifyNpmInstall(project: Project, cwd: string) {
    console.log('Creating an npm install promise');
    return promisifyInstallSpawn(
        'npm',
        ['install', '--ignore-scripts'],
        cwd,
        (resolve, reject) => (error) => {
            console.log('npm install failed with error', error, project, cwd);
            reject(error);
        },
        (resolve, reject) => (code, signal) => {
            if (code === 0) {
                console.log(`Succesfully installed dependencies using npm install in dir: ${cwd}`);
                resolve();
            } else {
                console.log(`Running npm install in dir: ${cwd} failed with code ${code} and signal ${signal}`);
                reject({ code, signal });
            }
        },
    );
}

export function getGitHubGraphQlClient() {
    return new GraphQLClient(config.GITHUB_GRAPHQL_API, { headers: {
        Accept: config.GITHUB_GRAPHQL_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        Authorization: `bearer ${config.GITHUB_TOKEN}`,
    }});
}

export function getGitHubRestClient() {
    return axios.create({
        baseURL: config.GITHUB_REST_API,
        headers: {
            Authorization: `bearer ${config.GITHUB_TOKEN}`,
            Accept: config.GITHUB_REST_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        }
    });
}
