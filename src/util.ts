import { execSync, spawn } from 'child_process';
import { EntityManager, EntityTarget, getManager } from 'typeorm';
import fs from 'fs';
import path from 'path';
import { Project } from './entities/project';
import config from './config';
import { ProjectError } from './entities/projectError';
import { GraphQLClient } from 'graphql-request';

export function defaultDatabaseErrorHandler(errorMsg: string) {
    console.error(errorMsg);
    throw new Error(errorMsg);
}

export async function saveToDbWithErrorHandling<Entity>(
    entityManager: EntityManager,
    type: EntityTarget<Entity>,
    obj: Entity,
    errorMessage: string,
) {
    try {
        await entityManager.save(type, obj);
    } catch (error) {
        defaultDatabaseErrorHandler(errorMessage);
    }
}

export async function downLoadProjectAndInstallDependencies(project: Project, useLatestCommit: boolean = false) {
    const entityManager = getManager();
    try {
        downloadProject(project, useLatestCommit);
    } catch (err) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'DOWNLOAD', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
            `Database connection failed while saving a project error to database ${JSON.stringify(projectError)}`,
        );
        return [];
    }

    let packageJsonDirs: string[] = [];
    try {
        packageJsonDirs = await installDependencies(project);
    } catch (err) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'INSTALL', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
            `Database connection failed while saving a project error to database ${JSON.stringify(projectError)}`,
        );
        return [];
    }
    return packageJsonDirs;
}

export function downloadProject(project: Project, useLatestCommit: boolean) {
    // Clear tmp dir
    if (fs.existsSync(config.TMP_DIR_PATH)) {
        fs.rmdirSync(config.TMP_DIR_PATH, { recursive: true });
    }

    fs.mkdirSync(config.TMP_DIR_PATH);

    console.log(`Cloning project ${JSON.stringify(useLatestCommit ? { ...project, commitHash: 'LATEST' } : project, null, 2)}`);
    if (useLatestCommit) {
        execSync(`git clone --depth 1 ${project.gitUrl} .`, { cwd: config.TMP_DIR_PATH });
        project.commitHash = execSync('git rev-parse HEAD', { cwd: config.TMP_DIR_PATH }).toString().trim();
    } else {
        execSync(`git clone ${project.gitUrl} . && git checkout ${project.commitHash} && rm -rf .git`, { cwd: config.TMP_DIR_PATH });
    }
}

export async function installDependencies(project: Project) {
    const foundPackageJsonFilesTxt = execSync('find "$(pwd)" -name package.json -not -path "*/node_modules/*"', { cwd: config.TMP_DIR_PATH }).toString();
    const foundPackageJsonFiles = foundPackageJsonFilesTxt.split('\n').filter((packageJsonDir) => packageJsonDir.length > 0);
    if (foundPackageJsonFiles.length === 0) {
        throw new Error('No package.json file at all');
    }
    const installPromises = [];
    const packageJsonDirs: string[] = [];
    for (const packageDir of foundPackageJsonFiles) {
        const dir = packageDir.replace(new RegExp(`package.json$`), '');
        packageJsonDirs.push(dir);

        // Check if lock file exists and run npm ci if so. Otherwise run npm install
        console.log('CREATING AN INSTALL PROMISE');
        if (fs.existsSync(path.join(dir, 'package-lock.json')) || fs.existsSync(path.join(dir, 'npm-shrinkwrap.json'))) {
            installPromises.push(promisifyInstallSpawn(
                'npm',
                ['ci'],
                dir,
                (resolve, reject) => (err) => {
                    console.log('npm ci failed with error', err, project, dir);
                    console.log('Running npm install instead');
                    resolve(promisifyNpmInstall(project, dir));
                },
                (resolve, reject) => (code, signal) => {
                    if (code === 0) {
                        console.log(`Succesfully installed dependencies using npm ci in dir: ${dir}`);
                        resolve();
                    } else {
                        console.log(`Running npm ci in dir: ${dir} failed with code ${code} and signal ${signal}`);
                        reject({ code, signal });
                    }
                },
            ));
        } else {
            installPromises.push(promisifyNpmInstall(project, dir));
        }
    }

    await Promise.all(installPromises);

    return packageJsonDirs;
}

function promisifyInstallSpawn(
    cmd: string,
    args: string[],
    cwd: string,
    errorHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (err: Error) => void,
    exitHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (code: number | null, signal: NodeJS.Signals | null) => void,
): Promise<void> {
    const childProc = spawn(cmd, args, { cwd });
    childProc.stderr.pipe(process.stderr);
    return new Promise((resolve, reject) => {
        childProc.on('error', errorHandler(resolve, reject));
        childProc.on('exit', exitHandler(resolve, reject));
    });
}

function promisifyNpmInstall(project: Project, cwd: string) {
    return promisifyInstallSpawn(
        'npm',
        ['install'],
        cwd,
        (resolve, reject) => (error) => {
            console.log('npm install failed with error', error, project, cwd);
            reject(error);
        },
        (resolve, reject) => (code, signal) => {
            if (code === 0) {
                console.log(`Succesfully installed dependencies using npm install in dir: ${cwd}`);
                resolve();
            } else {
                console.log(`Running npm install in dir: ${cwd} failed with code ${code} and signal ${signal}`);
                reject({ code, signal });
            }
        },
    );
}

export function getGitHubGraphQlClient() {
    return new GraphQLClient(config.GITHUB_GRAPHQL_API, { headers: {
        Accept: config.GITHUB_GRAPHQL_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        Authorization: `bearer ${config.GITHUB_TOKEN}`,
    }});
}
