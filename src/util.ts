import { exec, spawn } from 'child_process';
import readline from 'readline';
import _ from 'lodash';
import { EntityManager, EntityTarget, getManager } from 'typeorm';
import fs from 'fs';
import path from 'path';
import { Project } from './entities/project';
import config from './config';
import { ProjectError } from './entities/projectError';
import { GraphQLClient } from 'graphql-request';
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { promisify } from 'util';

const execAsync = promisify(exec);
export async function question(q: string) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<string>((resolve) => rl.question(q, (answer) => {
        rl.close();
        resolve(answer);
    }));
}

export async function confirmQuestion(q: string) {
    while (true) {
        const answer = await question(`${q} (y/n): `);
        if (answer === 'y') {
            return true;
        } else if (answer === 'n') {
            return false;
        }
    }
}

export function defaultDatabaseErrorHandler<T>(obj: T, err: any) {
    const errMsg = `Error when saving ${JSON.stringify(obj)} to database: ${err && err.message}}`;
    console.error(errMsg);
    throw new Error(errMsg);
}

export async function saveToDbWithErrorHandling<Entity>(
    entityManager: EntityManager,
    type: EntityTarget<Entity>,
    obj: Entity,
) {
    try {
        return await entityManager.save(type, obj);
    } catch (error) {
        defaultDatabaseErrorHandler(obj, error);
    }
    throw new Error('Should not be reached');
}

export function sleep(ms: number) {
    return new Promise((resolve, reject) => setTimeout(resolve, ms));
}

export async function doGitHubGraphQlRequestWithRetry<T>(client: GraphQLClient, query: string, maxRetries: number = 0) {
    let requestCounter = 0;
    while (true) {
        try {
            ++requestCounter;
            return await client.request<T>(query);
        } catch (err: any) {
            if (maxRetries && requestCounter > maxRetries) {
                throw err;
            }
            const sleepTimeSeconds = requestCounter * 2;
            if (err?.response?.errors[0].type === 'NOT_FOUND') {
                throw err;
            }
            if (err?.response.errors[0].message) {
                console.log(`GitHub API request failed with error code ${err.response.errors[0].message}. Retrying in ${sleepTimeSeconds} seconds`);
            } else {
                console.log(`GitHub API request failed. Retrying in ${sleepTimeSeconds} seconds`);
            }
            await sleep(sleepTimeSeconds * 1000);
        }
    }
}

export async function doAxiosRequestWithRetry<T>(axiosClient: AxiosInstance, requestConfig: AxiosRequestConfig, maxRetries: number = 0) {
    let requestCounter = 0;
    while (true) {
        try {
            ++requestCounter;
            return await axiosClient.request<T>(requestConfig);
        } catch(err) {
            if (maxRetries && requestCounter > maxRetries) {
                throw err;
            }
            const sleepSeconds = config.URL_FETCHING_RATE_LIMIT_SECONDS * requestCounter;
            if (axios.isAxiosError(err)) {
                console.log(`Request ${err.config.method} to ${err.config.baseURL}${err.config.url} failed with status ${err.response?.status}. Retrying in ${sleepSeconds} seconds.`);
            } else {
                console.log(`Request failed for some reason. Retrying in ${sleepSeconds} seconds.`);
            }
            await sleep(sleepSeconds * 1000);
        }
    }
}

export async function downLoadProjectAndInstallDependencies(
    project: Project,
    useLatestCommit: boolean = false,
    useFork: boolean = false,
    skipDownloadAndInstall: boolean = false,
    useSsh: boolean = false,
) {
    const entityManager = getManager();
    if (skipDownloadAndInstall) {
        return findLockfileDirs();
    }
    try {
        await downloadProject(project, useLatestCommit, useFork, useSsh);
    } catch (err: any) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'DOWNLOAD', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
        );
        return [];
    }

    const lockfileDirs = await findLockfileDirs();

    try {
        await installDependencies(project, lockfileDirs);
    } catch (err: any) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'INSTALL', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
        );
        return [];
    }
    return lockfileDirs;
}

export async function deleteRepository(repositoryName: string, client: AxiosInstance) {
    try {
        await client.delete(`/repos/${repositoryName}`);
    } catch(err) {
        if (axios.isAxiosError(err) && err.response?.status === 404) {
            console.log(`Couldn't find fork ${repositoryName}`);
        } else {
            console.log(`Removing fork ${repositoryName} failed`);
        }
    }
}

export async function downloadProject(project: Project, useLatestCommit: boolean, useFork: boolean, useSsh: boolean) {
    // Clear tmp dir
    if (fs.existsSync(config.TMP_DIR_PATH)) {
        fs.rmSync(config.TMP_DIR_PATH, { recursive: true });
    }

    fs.mkdirSync(config.TMP_DIR_PATH);

    console.log(`Cloning project ${project.name}${useFork ? ' using fork' : ''} using commit ${useLatestCommit ? 'LATEST' : project.commitHash }`);
    const gitUrl = `${useSsh ? config.GITHUB_SSH_URL + ':' : config.GITHUB_URL + '/'}${useFork ? project.forkedName : project.name}.git`;
    if (useLatestCommit) {
        await execAsync(`git clone ${gitUrl} .`, { cwd: config.TMP_DIR_PATH });
        project.commitHash = (await execAsync('git rev-parse HEAD', { cwd: config.TMP_DIR_PATH })).stdout.trim();
    } else {
        await execAsync(`git clone ${gitUrl} . && git checkout ${project.commitHash}`, { cwd: config.TMP_DIR_PATH });
    }
}

export async function findLockfileDirs() {
    const foundLockfilesTxt = (await execAsync(
        String.raw`find "$(pwd)" \( -name "package-lock.json" -o -name "npm-shrinkwrap.json" \) -not -path "*/node_modules/*"`,
        { cwd: config.TMP_DIR_PATH },
        )).stdout;
    const dirs = foundLockfilesTxt
        .split('\n')
        .filter((packageJsonDir) => packageJsonDir.length > 0)
        .map((dir) => path.dirname(dir));

    dirs.sort();
    return dirs;
}

export async function findPackageJsonDirs() {
    const foundPackageJsonDirs = (await execAsync(
        String.raw`find "$(pwd)" -name "package.json" -not -path "*/node_modules/*"`,
        { cwd: config.TMP_DIR_PATH },
        )).stdout;
    const dirs = foundPackageJsonDirs
        .split('\n')
        .filter((packageJsonDir) => packageJsonDir.length > 0)
        .map((dir) => path.dirname(dir));

    dirs.sort();
    return dirs;
}

export const supportedLockfilesRegex = /\/?(?:package-lock\.json|npm-shrinkwrap\.json)$/;

export async function installDependencies(project: Project, lockfileDirs: string[]) {
    const installPromises = [];
    for (const dir of lockfileDirs) {
        // Check if lock file exists and run npm ci if so. Otherwise run npm install
        if (fs.existsSync(path.join(dir, 'package-lock.json')) || fs.existsSync(path.join(dir, 'npm-shrinkwrap.json'))) {
            console.log('Creating an npm ci promise');
            installPromises.push(promisifyInstallSpawn(
                'npm',
                ['ci', '--ignore-scripts'],
                dir,
                (resolve, reject) => (err) => {
                    console.log('npm ci failed with error', err, project, dir);
                    console.log('Running npm install instead');
                    resolve(promisifyNpmInstall(project, dir));
                },
                (resolve, reject) => (code, signal) => {
                    if (code === 0) {
                        console.log(`Succesfully installed dependencies using npm ci in dir: ${dir}`);
                        resolve();
                    } else {
                        console.log(`Running npm ci in dir: ${dir} failed with code ${code} and signal ${signal}`);
                        reject({ code, signal });
                    }
                },
            ));
        } else {
            installPromises.push(promisifyNpmInstall(project, dir));
        }
    }

    const promises = await Promise.allSettled(installPromises);
    checkPromisesForErrors(promises);
}

export function checkPromisesForErrors(promises: PromiseSettledResult<any>[]) {
    const reasons: any[] = [];
    for (const prom of promises) {
        if (prom.status === 'rejected') {
            reasons.push(prom.reason);
        }
    }
    if (reasons.length) {
        throw new Error(reasons.join('\n'));
    }
}

function promisifyInstallSpawn(
    cmd: string,
    args: string[],
    cwd: string,
    errorHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (err: Error) => void,
    exitHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (code: number | null, signal: NodeJS.Signals | null) => void,
): Promise<void> {
    const childProc = spawn(cmd, args, { cwd });
    return new Promise((resolve, reject) => {
        childProc.on('error', errorHandler(resolve, reject));
        childProc.on('exit', exitHandler(resolve, reject));
    });
}

function promisifyNpmInstall(project: Project, cwd: string) {
    console.log('Creating an npm install promise');
    return promisifyInstallSpawn(
        'npm',
        ['install', '--ignore-scripts'],
        cwd,
        (resolve, reject) => (error) => {
            console.log('npm install failed with error', error, project, cwd);
            reject(error);
        },
        (resolve, reject) => (code, signal) => {
            if (code === 0) {
                console.log(`Succesfully installed dependencies using npm install in dir: ${cwd}`);
                resolve();
            } else {
                console.log(`Running npm install in dir: ${cwd} failed with code ${code} and signal ${signal}`);
                reject({ code, signal });
            }
        },
    );
}

export function getGitHubGraphQlClient() {
    return new GraphQLClient(config.GITHUB_GRAPHQL_API, { headers: {
        Accept: config.GITHUB_GRAPHQL_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        Authorization: `bearer ${config.GITHUB_TOKEN}`,
    }});
}

export function getGitHubRestClient(axiosRequestConfig: AxiosRequestConfig = {}) {
    return axios.create({
        baseURL: config.GITHUB_REST_API,
        headers: {
            Authorization: `bearer ${config.GITHUB_TOKEN}`,
            Accept: config.GITHUB_REST_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        },
        ...axiosRequestConfig,
    });
}

export function compareFnByProperty<T>(...objPaths: string[]) {
    return function(a: T, b: T): number {
        if (!objPaths.length) {
            return 0;
        }
        const objPath = objPaths[0];
        const aProp = _.get(a, objPath);
        const bProp = _.get(b, objPath);
        if (aProp > bProp) {
            return 1;
        } else if (aProp < bProp) {
            return -1;
        } else {
            objPaths.shift();
            return compareFnByProperty<T>(...objPaths)(a, b);
        }
    }
}

export interface AgreementData {
    total: number;
    agreed: number;
}

export interface PerProjectResults {
    [projectName: string]: {
        [toolName: string]: {
            [toolName: string]: AgreementData;
        }
    }
}

export interface AgreementsBetweenTools {
    [toolName: string]: {
        [comparedToolName: string]: AgreementData[];
    }
}

export function calculateAgreement(agreementData: AgreementData) {
    if (agreementData.total === 0) {
        return 1;
    }
    return agreementData.agreed/agreementData.total;
}

export function calculateTotalAgreement(agreementData: AgreementData[]) {
    const data = agreementData.reduce((prev, cur) => ({
            agreed: prev.agreed + cur.agreed,
            total: prev.total + cur.total,
    }), { agreed: 0, total: 0 });
    return calculateAgreement(data);
}

export function calculateMedianAgreement(agreementData: AgreementData[]) {
    const data = agreementData.map((agreement) => calculateAgreement(agreement)).sort((a, b) => a - b);
    const lengthHalved = data.length/2;
    if (Number.isInteger(lengthHalved)) {
        return (data[lengthHalved - 1] + data[lengthHalved])/2;
    } else {
        return data[Math.ceil(lengthHalved)];
    }
}
