import { execSync, spawn } from 'child_process';
import { EntityManager, EntityTarget, getManager } from 'typeorm';
import fs from 'fs';
import path from 'path';
import { Project } from './entities/project';
import config from './config';
import { ProjectError } from './entities/projectError';
import { GraphQLClient } from 'graphql-request';
import _ from 'lodash';
import axios from 'axios';
const cycloneDxBom = require('@cyclonedx/bom');

export function defaultDatabaseErrorHandler(errorMsg: string) {
    console.error(errorMsg);
    throw new Error(errorMsg);
}

export async function saveToDbWithErrorHandling<Entity>(
    entityManager: EntityManager,
    type: EntityTarget<Entity>,
    obj: Entity,
    errorMessage: string,
) {
    try {
        await entityManager.save(type, obj);
    } catch (error) {
        defaultDatabaseErrorHandler(errorMessage);
    }
}

export async function downLoadProjectAndInstallDependencies(project: Project, useLatestCommit: boolean = false, useFork: boolean = false) {
    const entityManager = getManager();
    try {
        downloadProject(project, useLatestCommit, useFork);
    } catch (err) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'DOWNLOAD', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
            `Database connection failed while saving a project error to database ${JSON.stringify(projectError)}`,
        );
        return [];
    }

    let packageJsonDirs: string[] = [];
    try {
        packageJsonDirs = await installDependencies(project);
    } catch (err) {
        const projectError = entityManager.create(ProjectError, { project, phase: 'INSTALL', message: err.message || '' });
        await saveToDbWithErrorHandling(
            entityManager,
            ProjectError,
            projectError,
            `Database connection failed while saving a project error to database ${JSON.stringify(projectError)}`,
        );
        return [];
    }
    return packageJsonDirs;
}

export function downloadProject(project: Project, useLatestCommit: boolean, useFork: boolean) {
    // Clear tmp dir
    if (fs.existsSync(config.TMP_DIR_PATH)) {
        fs.rmdirSync(config.TMP_DIR_PATH, { recursive: true });
    }

    fs.mkdirSync(config.TMP_DIR_PATH);

    console.log(`Cloning project${useFork ? ' using fork' : ''} ${JSON.stringify(useLatestCommit ? { ...project, commitHash: 'LATEST' } : project, null, 2)}`);
    const gitUrl = useFork ? `${config.GITHUB_URL}/${project.forkedName}` : `${config.GITHUB_URL}/${project.name}`;
    if (useLatestCommit) {
        execSync(`git clone ${gitUrl} .`, { cwd: config.TMP_DIR_PATH });
        project.commitHash = execSync('git rev-parse HEAD', { cwd: config.TMP_DIR_PATH }).toString().trim();
    } else {
        execSync(`git clone ${gitUrl} . && git checkout ${project.commitHash}`, { cwd: config.TMP_DIR_PATH });
    }
}

export async function installDependencies(project: Project) {
    const foundPackageJsonFilesTxt = execSync('find "$(pwd)" -name package.json -not -path "*/node_modules/*"', { cwd: config.TMP_DIR_PATH }).toString();
    const foundPackageJsonFiles = foundPackageJsonFilesTxt.split('\n').filter((packageJsonDir) => packageJsonDir.length > 0);
    if (foundPackageJsonFiles.length === 0) {
        throw new Error('No package.json file at all');
    }
    const installPromises = [];
    const packageJsonDirs: string[] = [];
    for (const packageDir of foundPackageJsonFiles) {
        const dir = packageDir.replace(new RegExp(`package.json$`), '');
        packageJsonDirs.push(dir);

        // Check if lock file exists and run npm ci if so. Otherwise run npm install
        console.log('CREATING AN INSTALL PROMISE');
        if (fs.existsSync(path.join(dir, 'package-lock.json')) || fs.existsSync(path.join(dir, 'npm-shrinkwrap.json'))) {
            installPromises.push(promisifyInstallSpawn(
                'npm',
                ['ci'],
                dir,
                (resolve, reject) => (err) => {
                    console.log('npm ci failed with error', err, project, dir);
                    console.log('Running npm install instead');
                    resolve(promisifyNpmInstall(project, dir));
                },
                (resolve, reject) => (code, signal) => {
                    if (code === 0) {
                        console.log(`Succesfully installed dependencies using npm ci in dir: ${dir}`);
                        resolve();
                    } else {
                        console.log(`Running npm ci in dir: ${dir} failed with code ${code} and signal ${signal}`);
                        reject({ code, signal });
                    }
                },
            ));
        } else {
            installPromises.push(promisifyNpmInstall(project, dir));
        }
    }

    await Promise.allSettled(installPromises);

    return packageJsonDirs;
}

function promisifyInstallSpawn(
    cmd: string,
    args: string[],
    cwd: string,
    errorHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (err: Error) => void,
    exitHandler: (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => (code: number | null, signal: NodeJS.Signals | null) => void,
): Promise<void> {
    const childProc = spawn(cmd, args, { cwd });
    childProc.stderr.pipe(process.stderr);
    return new Promise((resolve, reject) => {
        childProc.on('error', errorHandler(resolve, reject));
        childProc.on('exit', exitHandler(resolve, reject));
    });
}

function promisifyNpmInstall(project: Project, cwd: string) {
    return promisifyInstallSpawn(
        'npm',
        ['install'],
        cwd,
        (resolve, reject) => (error) => {
            console.log('npm install failed with error', error, project, cwd);
            reject(error);
        },
        (resolve, reject) => (code, signal) => {
            if (code === 0) {
                console.log(`Succesfully installed dependencies using npm install in dir: ${cwd}`);
                resolve();
            } else {
                console.log(`Running npm install in dir: ${cwd} failed with code ${code} and signal ${signal}`);
                reject({ code, signal });
            }
        },
    );
}

export function getGitHubGraphQlClient() {
    return new GraphQLClient(config.GITHUB_GRAPHQL_API, { headers: {
        Accept: config.GITHUB_GRAPHQL_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        Authorization: `bearer ${config.GITHUB_TOKEN}`,
    }});
}

export function getGitHubRestClient() {
    return axios.create({
        baseURL: config.GITHUB_REST_API,
        headers: {
            Authorization: `bearer ${config.GITHUB_TOKEN}`,
            Accept: config.GITHUB_REST_API_SECURITY_PREVIEW_ACCEPT_HEADER,
        }
    });
}

export async function getMergedCycloneDxBom(packageJsonDirs: string[]) {
    // Default cyclonedx/bom options
    const componentType = 'library';
    const includeSerialNumber = true;
    const includeLicenseText = false;
    // We want to include dev dependencies as well
    const readInstalledOptions = { dev: true };
    const componentPromises = [];
    let components: any[] = [];
    let totalComponentCount = 0;
    let rootBom: any;
    
    for (const packageJsonDir of packageJsonDirs) {
        componentPromises.push(new Promise<void>((resolve, reject) => {
            cycloneDxBom.createbom(componentType, includeSerialNumber, includeLicenseText, packageJsonDir, readInstalledOptions, (err: any, bom: any) => {
                components = components.concat(bom.components);
                totalComponentCount += bom.components.length;
                // Package JSON dirs originate from a find -command which puts the root package.json dir as last
                // If there is no root package.json then this will just be the last search result
                if (packageJsonDir === packageJsonDirs[packageJsonDirs.length - 1]) {
                    rootBom = bom;
                }
                resolve();
            });
        }));
    }

    await Promise.allSettled(componentPromises);
    const uniqComponents = _.uniqBy(components, (comp) => comp.purl);
    console.log(`Found a total of ${totalComponentCount} of dependencies of which ${uniqComponents.length} are unique which means that there are ${totalComponentCount - uniqComponents.length} duplicate dependencies`);
    rootBom.components = uniqComponents;
    return rootBom;
}
