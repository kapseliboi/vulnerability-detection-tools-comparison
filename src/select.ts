import fs from 'fs';
import _ from 'lodash';
import config from './config';
import { getManager } from 'typeorm';
import { Project } from './entities/project';
import { CliSelectOptions, GitHubSearchObject } from './interfaces/types';
import { downLoadProjectAndInstallDependencies, saveToDbWithErrorHandling } from './util';
import { createInterface } from 'readline';
import { execSync } from 'child_process';

const cycloneDxBom = require('@cyclonedx/bom');

export async function select(options: CliSelectOptions) {
    const { items: projects }: GitHubSearchObject = JSON.parse(fs.readFileSync(options.inputFile, 'utf-8'));
    const entityManager = getManager();
    for (const proj of projects) {
        const project = entityManager.create(Project, {
            name: proj.name,
            forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
            commitHash: proj.lastCommitSHA,
        });

        const USE_LATEST_COMMIT = true;
        const packageJsonDirs = await downLoadProjectAndInstallDependencies(project, USE_LATEST_COMMIT);

        if (!options.minDepCount || await checkMinDepCount(options.minDepCount, packageJsonDirs)) {
            if (!await getUsersManualConfirmation(project)) {
                continue;
            }
            console.log('Forking project');
            forkProject(project);
            console.log('Enabling dependabot for forked project');
            enableDependabotForForkedProject(project);
            console.log('Enable whitesource bolt for forked project');
            enableWhiteSourceBoltForForkedProject(project);
            console.log('Saving project to dataset');
            await saveToDbWithErrorHandling(entityManager, Project, project, `Saving a valid project to database failed. Project: ${JSON.stringify(project)}`);
        } else {
            console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${options.minDepCount}`);
        }
    }
    console.log('Select operation completed');
}

async function checkMinDepCount(minDepCount: number, packageJsonDirs: string[]) {
    // Default cyclonedx/bom options
    const componentType = 'library';
    const includeSerialNumber = true;
    const includeLicenseText = false;
    // We want to include dev dependencies as well
    const readInstalledOptions = { dev: true };
    const componentPromises = [];
    let components: any[] = [];
    let totalComponentCount = 0;
    
    for (const packageJsonDir of packageJsonDirs) {
        componentPromises.push(new Promise<void>((resolve, reject) => {
            cycloneDxBom.createbom(componentType, includeSerialNumber, includeLicenseText, packageJsonDir, readInstalledOptions, (err: any, bom: any) => {
                components = components.concat(bom.components);
                totalComponentCount += bom.components.length;
                resolve();
            });
        }));
    }

    await Promise.all(componentPromises);
    const uniqComponents = _.uniqBy(components, (comp) => comp.purl);
    console.log(`Found a total of ${totalComponentCount} of dependencies of which ${uniqComponents.length} are unique which means that there are ${totalComponentCount - uniqComponents.length} duplicate dependencies`);
    return uniqComponents.length >= minDepCount;
}

async function getUsersManualConfirmation(project: Project) {
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}/tree/${project.commitHash}) be added to the data set? (y/n):`, (yesOrNo) => {
            resolve(yesOrNo.toLowerCase() === 'y');
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    await client.post(`/repos/${project.name}/forks`);
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.put(`/repos/${project.forkedName}/vulnerability-alerts`);
}

function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..');
    execSync(`../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH} https://${config.GITHUB_TOKEN}@github.com/${project.forkedName}`, { cwd: __dirname });
}
