import fs from 'fs';
import config from './config';
import { getManager } from 'typeorm';
import { Project } from './entities/project';
import { CliSelectOptions, GitHubSearchObject } from './interfaces/types';
import { downLoadProjectAndInstallDependencies, getGitHubRestClient, getMergedCycloneDxBom, saveToDbWithErrorHandling } from './util';
import { createInterface } from 'readline';
import { execSync } from 'child_process';
import path from 'path';

export async function select(options: CliSelectOptions) {
    const { items: projects }: GitHubSearchObject = JSON.parse(fs.readFileSync(options.inputFile, 'utf-8'));
    const entityManager = getManager();
    for (const proj of projects) {
        const project = entityManager.create(Project, {
            name: proj.name,
            forkedName: `${config.GITHUB_USERNAME}/${proj.name.split('/')[1]}`,
            commitHash: proj.lastCommitSHA,
        });

        const USE_LATEST_COMMIT = true;
        const packageJsonDirs = await downLoadProjectAndInstallDependencies(project, USE_LATEST_COMMIT, false, options.noDownloadOrInstall);

        if (!options.minDepCount || await checkMinDepCount(options.minDepCount, packageJsonDirs)) {
            if (!await getUsersManualConfirmation(project)) {
                continue;
            }
            console.log('Forking project');
            await forkProject(project);
            console.log('Enabling dependabot for forked project');
            await enableDependabotForForkedProject(project);
            console.log('Enable whitesource bolt for forked project');
            enableWhiteSourceBoltForForkedProject(project);
            console.log('Saving project to dataset');
            await saveToDbWithErrorHandling(entityManager, Project, project, `Saving a valid project to database failed. Project: ${JSON.stringify(project)}`);
        } else {
            console.log(`Skipping project ${project.name} because it doesn't meet the minimum required dependency amount of ${options.minDepCount}`);
        }
    }
    console.log('Select operation completed');
}

async function checkMinDepCount(minDepCount: number, packageJsonDirs: string[]) {
    const bom = await getMergedCycloneDxBom(packageJsonDirs);
    return bom.components.length >= minDepCount;
}

async function getUsersManualConfirmation(project: Project) {
    const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise<boolean>((resolve, reject) => {
        readline.question(`Should project ${project.name} (${config.GITHUB_URL}/${project.name}/tree/${project.commitHash}) be added to the data set? (y/n):`, (yesOrNo) => {
            resolve(yesOrNo.toLowerCase() === 'y');
        });
    });
}

async function forkProject(project: Project) {
    const client = getGitHubRestClient();
    await client.post(`/repos/${project.name}/forks`);
}

async function enableDependabotForForkedProject(project: Project) {
    const client = getGitHubRestClient();
    await client.put(`/repos/${project.forkedName}/vulnerability-alerts`);
}

function enableWhiteSourceBoltForForkedProject(project: Project) {
    const whitesourceConfigPath = path.join(__dirname, '..');
    execSync(`../scripts/enableWhiteSourceBolt.sh ${whitesourceConfigPath} ${config.TMP_DIR_PATH} https://${config.GITHUB_TOKEN}@github.com/${project.forkedName}`, { cwd: __dirname });
}
